{"version":3,"file":"compiler.mjs","sources":["../../../../../../packages/compiler/src/ml_parser/tags.ts","../../../../../../packages/compiler/src/ml_parser/html_tags.ts","../../../../../../packages/compiler/src/selector.ts","../../../../../../packages/compiler/src/core.ts","../../../../../../packages/compiler/src/util.ts","../../../../../../packages/compiler/src/i18n/big_integer.ts","../../../../../../packages/compiler/src/i18n/digest.ts","../../../../../../packages/compiler/src/output/output_ast.ts","../../../../../../packages/compiler/src/constant_pool.ts","../../../../../../packages/compiler/src/render3/r3_identifiers.ts","../../../../../../packages/compiler/src/output/source_map.ts","../../../../../../packages/compiler/src/output/abstract_emitter.ts","../../../../../../packages/compiler/src/render3/util.ts","../../../../../../packages/compiler/src/render3/r3_factory.ts","../../../../../../packages/compiler/src/render3/r3_ast.ts","../../../../../../packages/compiler/src/i18n/i18n_ast.ts","../../../../../../packages/compiler/src/i18n/serializers/serializer.ts","../../../../../../packages/compiler/src/i18n/serializers/xml_helper.ts","../../../../../../packages/compiler/src/i18n/serializers/xmb.ts","../../../../../../packages/compiler/src/render3/view/i18n/util.ts","../../../../../../packages/compiler/src/render3/view/util.ts","../../../../../../packages/compiler/src/injectable_compiler_2.ts","../../../../../../packages/compiler/src/assertions.ts","../../../../../../packages/compiler/src/ml_parser/interpolation_config.ts","../../../../../../packages/compiler/src/chars.ts","../../../../../../packages/compiler/src/parse_util.ts","../../../../../../packages/compiler/src/output/abstract_js_emitter.ts","../../../../../../packages/compiler/src/output/output_jit_trusted_types.ts","../../../../../../packages/compiler/src/output/output_jit.ts","../../../../../../packages/compiler/src/render3/r3_injector_compiler.ts","../../../../../../packages/compiler/src/render3/r3_jit.ts","../../../../../../packages/compiler/src/render3/r3_module_compiler.ts","../../../../../../packages/compiler/src/render3/r3_pipe_compiler.ts","../../../../../../packages/compiler/src/expression_parser/ast.ts","../../../../../../packages/compiler/src/compiler_util/expression_converter.ts","../../../../../../packages/compiler/src/shadow_css.ts","../../../../../../packages/compiler/src/render3/view/style_parser.ts","../../../../../../packages/compiler/src/render3/view/styling_builder.ts","../../../../../../packages/compiler/src/expression_parser/lexer.ts","../../../../../../packages/compiler/src/expression_parser/parser.ts","../../../../../../packages/compiler/src/ml_parser/ast.ts","../../../../../../packages/compiler/src/ml_parser/entities.ts","../../../../../../packages/compiler/src/ml_parser/lexer.ts","../../../../../../packages/compiler/src/ml_parser/parser.ts","../../../../../../packages/compiler/src/ml_parser/html_parser.ts","../../../../../../packages/compiler/src/ml_parser/html_whitespaces.ts","../../../../../../packages/compiler/src/output/map_util.ts","../../../../../../packages/compiler/src/schema/dom_security_schema.ts","../../../../../../packages/compiler/src/schema/element_schema_registry.ts","../../../../../../packages/compiler/src/schema/dom_element_schema_registry.ts","../../../../../../packages/compiler/src/schema/trusted_types_sinks.ts","../../../../../../packages/compiler/src/template_parser/binding_parser.ts","../../../../../../packages/compiler/src/style_url_resolver.ts","../../../../../../packages/compiler/src/template_parser/template_preparser.ts","../../../../../../packages/compiler/src/render3/r3_template_transform.ts","../../../../../../packages/compiler/src/render3/view/i18n/context.ts","../../../../../../packages/compiler/src/render3/view/i18n/icu_serializer.ts","../../../../../../packages/compiler/src/i18n/serializers/placeholder.ts","../../../../../../packages/compiler/src/i18n/i18n_parser.ts","../../../../../../packages/compiler/src/i18n/parse_util.ts","../../../../../../packages/compiler/src/render3/view/i18n/meta.ts","../../../../../../packages/compiler/src/render3/view/i18n/get_msg_utils.ts","../../../../../../packages/compiler/src/render3/view/i18n/localize_utils.ts","../../../../../../packages/compiler/src/render3/view/template.ts","../../../../../../packages/compiler/src/render3/view/compiler.ts","../../../../../../packages/compiler/src/resource_loader.ts","../../../../../../packages/compiler/src/jit_compiler_facade.ts","../../../../../../packages/compiler/src/version.ts","../../../../../../packages/compiler/src/config.ts","../../../../../../packages/compiler/src/i18n/extractor_merger.ts","../../../../../../packages/compiler/src/ml_parser/xml_tags.ts","../../../../../../packages/compiler/src/ml_parser/xml_parser.ts","../../../../../../packages/compiler/src/i18n/serializers/xliff.ts","../../../../../../packages/compiler/src/i18n/serializers/xliff2.ts","../../../../../../packages/compiler/src/i18n/serializers/xtb.ts","../../../../../../packages/compiler/src/i18n/translation_bundle.ts","../../../../../../packages/compiler/src/i18n/i18n_html_parser.ts","../../../../../../packages/compiler/src/i18n/message_bundle.ts","../../../../../../packages/compiler/src/i18n/index.ts","../../../../../../packages/compiler/src/render3/partial/api.ts","../../../../../../packages/compiler/src/render3/view/t2_binder.ts","../../../../../../packages/compiler/src/render3/r3_class_metadata_compiler.ts","../../../../../../packages/compiler/src/render3/partial/class_metadata.ts","../../../../../../packages/compiler/src/render3/partial/util.ts","../../../../../../packages/compiler/src/render3/partial/directive.ts","../../../../../../packages/compiler/src/render3/partial/component.ts","../../../../../../packages/compiler/src/render3/partial/factory.ts","../../../../../../packages/compiler/src/render3/partial/injectable.ts","../../../../../../packages/compiler/src/render3/partial/injector.ts","../../../../../../packages/compiler/src/render3/partial/ng_module.ts","../../../../../../packages/compiler/src/render3/partial/pipe.ts","../../../../../../packages/compiler/src/compiler.ts","../../../../../../packages/compiler/public_api.ts","../../../../../../packages/compiler/compiler.ts","../../../../../../packages/compiler/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport enum TagContentType {\n  RAW_TEXT,\n  ESCAPABLE_RAW_TEXT,\n  PARSABLE_DATA\n}\n\nexport interface TagDefinition {\n  closedByParent: boolean;\n  implicitNamespacePrefix: string|null;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n  preventNamespaceInheritance: boolean;\n\n  isClosedByChild(name: string): boolean;\n  getContentType(prefix?: string): TagContentType;\n}\n\nexport function splitNsName(elementName: string): [string|null, string] {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n\n  const colonIndex = elementName.indexOf(':', 1);\n\n  if (colonIndex === -1) {\n    throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n\n// `<ng-container>` tags work the same regardless the namespace\nexport function isNgContainer(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-container';\n}\n\n// `<ng-content>` tags work the same regardless the namespace\nexport function isNgContent(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-content';\n}\n\n// `<ng-template>` tags work the same regardless the namespace\nexport function isNgTemplate(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\n\nexport function getNsPrefix(fullName: string): string;\nexport function getNsPrefix(fullName: null): null;\nexport function getNsPrefix(fullName: string|null): string|null {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nexport function mergeNsAndName(prefix: string, localName: string): string {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TagContentType, TagDefinition} from './tags';\n\nexport class HtmlTagDefinition implements TagDefinition {\n  private closedByChildren: {[key: string]: boolean} = {};\n  private contentType: TagContentType|\n      {default: TagContentType, [namespace: string]: TagContentType};\n\n  closedByParent: boolean = false;\n  implicitNamespacePrefix: string|null;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean = false;\n  preventNamespaceInheritance: boolean;\n\n  constructor({\n    closedByChildren,\n    implicitNamespacePrefix,\n    contentType = TagContentType.PARSABLE_DATA,\n    closedByParent = false,\n    isVoid = false,\n    ignoreFirstLf = false,\n    preventNamespaceInheritance = false\n  }: {\n    closedByChildren?: string[],\n    closedByParent?: boolean,\n    implicitNamespacePrefix?: string,\n    contentType?: TagContentType|{default: TagContentType, [namespace: string]: TagContentType},\n    isVoid?: boolean,\n    ignoreFirstLf?: boolean,\n    preventNamespaceInheritance?: boolean\n  } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n    this.preventNamespaceInheritance = preventNamespaceInheritance;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n\n  getContentType(prefix?: string): TagContentType {\n    if (typeof this.contentType === 'object') {\n      const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n      return overrideType ?? this.contentType.default;\n    }\n    return this.contentType;\n  }\n}\n\nlet _DEFAULT_TAG_DEFINITION!: HtmlTagDefinition;\n\n// see https://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nlet TAG_DEFINITIONS!: {[key: string]: HtmlTagDefinition};\n\nexport function getHtmlTagDefinition(tagName: string): HtmlTagDefinition {\n  if (!TAG_DEFINITIONS) {\n    _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n    TAG_DEFINITIONS = {\n      'base': new HtmlTagDefinition({isVoid: true}),\n      'meta': new HtmlTagDefinition({isVoid: true}),\n      'area': new HtmlTagDefinition({isVoid: true}),\n      'embed': new HtmlTagDefinition({isVoid: true}),\n      'link': new HtmlTagDefinition({isVoid: true}),\n      'img': new HtmlTagDefinition({isVoid: true}),\n      'input': new HtmlTagDefinition({isVoid: true}),\n      'param': new HtmlTagDefinition({isVoid: true}),\n      'hr': new HtmlTagDefinition({isVoid: true}),\n      'br': new HtmlTagDefinition({isVoid: true}),\n      'source': new HtmlTagDefinition({isVoid: true}),\n      'track': new HtmlTagDefinition({isVoid: true}),\n      'wbr': new HtmlTagDefinition({isVoid: true}),\n      'p': new HtmlTagDefinition({\n        closedByChildren: [\n          'address', 'article', 'aside',   'blockquote', 'div',  'dl',  'fieldset',\n          'footer',  'form',    'h1',      'h2',         'h3',   'h4',  'h5',\n          'h6',      'header',  'hgroup',  'hr',         'main', 'nav', 'ol',\n          'p',       'pre',     'section', 'table',      'ul'\n        ],\n        closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),\n      'tbody': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot'], closedByParent: true}),\n      'tfoot': new HtmlTagDefinition({closedByChildren: ['tbody'], closedByParent: true}),\n      'tr': new HtmlTagDefinition({closedByChildren: ['tr'], closedByParent: true}),\n      'td': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'th': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'col': new HtmlTagDefinition({isVoid: true}),\n      'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),\n      'foreignObject': new HtmlTagDefinition({\n        // Usually the implicit namespace here would be redundant since it will be inherited from\n        // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser\n        // works is that the parent node of an end tag is its own start tag which means that\n        // the `preventNamespaceInheritance` on `foreignObject` would have it default to the\n        // implicit namespace which is `html`, unless specified otherwise.\n        implicitNamespacePrefix: 'svg',\n        // We want to prevent children of foreignObject from inheriting its namespace, because\n        // the point of the element is to allow nodes from other namespaces to be inserted.\n        preventNamespaceInheritance: true,\n      }),\n      'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),\n      'li': new HtmlTagDefinition({closedByChildren: ['li'], closedByParent: true}),\n      'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),\n      'dd': new HtmlTagDefinition({closedByChildren: ['dt', 'dd'], closedByParent: true}),\n      'rb': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'rt': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'rtc': new HtmlTagDefinition({closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true}),\n      'rp': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'optgroup': new HtmlTagDefinition({closedByChildren: ['optgroup'], closedByParent: true}),\n      'option':\n          new HtmlTagDefinition({closedByChildren: ['option', 'optgroup'], closedByParent: true}),\n      'pre': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'listing': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'style': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'script': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'title': new HtmlTagDefinition({\n        // The browser supports two separate `title` tags which have to use\n        // a different content type: `HTMLTitleElement` and `SVGTitleElement`\n        contentType: {default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA}\n      }),\n      'textarea': new HtmlTagDefinition(\n          {contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true}),\n    };\n  }\n  // We have to make both a case-sensitive and a case-insensitive lookup, because\n  // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.\n  return TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ??\n      _DEFAULT_TAG_DEFINITION;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getHtmlTagDefinition} from './ml_parser/html_tags';\n\nconst _SELECTOR_REGEXP = new RegExp(\n    '(\\\\:not\\\\()|' +               // 1: \":not(\"\n        '(([\\\\.\\\\#]?)[-\\\\w]+)|' +  // 2: \"tag\"; 3: \".\"/\"#\";\n        // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n        // 4: attribute; 5: attribute_string; 6: attribute_value\n        '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +  // \"[name]\", \"[name=value]\",\n                                                                        // \"[name=\"value\"]\",\n                                                                        // \"[name='value']\"\n        '(\\\\))|' +                                                      // 7: \")\"\n        '(\\\\s*,\\\\s*)',                                                  // 8: \",\"\n    'g');\n\n/**\n * These offsets should match the match-groups in `_SELECTOR_REGEXP` offsets.\n */\nconst enum SelectorRegexp {\n  ALL = 0,  // The whole match\n  NOT = 1,\n  TAG = 2,\n  PREFIX = 3,\n  ATTRIBUTE = 4,\n  ATTRIBUTE_STRING = 5,\n  ATTRIBUTE_VALUE = 6,\n  NOT_END = 7,\n  SEPARATOR = 8,\n}\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string|null = null;\n  classNames: string[] = [];\n  /**\n   * The selectors are encoded in pairs where:\n   * - even locations are attribute names\n   * - odd locations are attribute values.\n   *\n   * Example:\n   * Selector: `[key1=value1][key2]` would parse to:\n   * ```\n   * ['key1', 'value1', 'key2', '']\n   * ```\n   */\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n\n  static parse(selector: string): CssSelector[] {\n    const results: CssSelector[] = [];\n    const _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n          cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match: string[]|null;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[SelectorRegexp.NOT]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[SelectorRegexp.TAG];\n      if (tag) {\n        const prefix = match[SelectorRegexp.PREFIX];\n        if (prefix === '#') {\n          // #hash\n          current.addAttribute('id', tag.substr(1));\n        } else if (prefix === '.') {\n          // Class\n          current.addClassName(tag.substr(1));\n        } else {\n          // Element\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[SelectorRegexp.ATTRIBUTE];\n\n      if (attribute) {\n        current.addAttribute(\n            current.unescapeAttribute(attribute), match[SelectorRegexp.ATTRIBUTE_VALUE]);\n      }\n      if (match[SelectorRegexp.NOT_END]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[SelectorRegexp.SEPARATOR]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n\n  /**\n   * Unescape `\\$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * but we might want to match an attribute that contains `$`.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to unescape.\n   * @returns the unescaped string.\n   */\n  unescapeAttribute(attr: string): string {\n    let result = '';\n    let escaping = false;\n    for (let i = 0; i < attr.length; i++) {\n      const char = attr.charAt(i);\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '$' && !escaping) {\n        throw new Error(\n            `Error in attribute selector \"${attr}\". ` +\n            `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n      }\n      escaping = false;\n      result += char;\n    }\n    return result;\n  }\n\n  /**\n   * Escape `$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * with this method we are escaping `$` with `\\$'.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to escape.\n   * @returns the escaped string. \n   */\n  escapeAttribute(attr: string): string {\n    return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n  }\n\n  isElementSelector(): boolean {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n        this.notSelectors.length === 0;\n  }\n\n  hasElementSelector(): boolean {\n    return !!this.element;\n  }\n\n  setElement(element: string|null = null) {\n    this.element = element;\n  }\n\n  /** Gets a template string for an element that matches the selector. */\n  getMatchingElementTemplate(): string {\n    const tagName = this.element || 'div';\n    const classAttr = this.classNames.length > 0 ? ` class=\"${this.classNames.join(' ')}\"` : '';\n\n    let attrs = '';\n    for (let i = 0; i < this.attrs.length; i += 2) {\n      const attrName = this.attrs[i];\n      const attrValue = this.attrs[i + 1] !== '' ? `=\"${this.attrs[i + 1]}\"` : '';\n      attrs += ` ${attrName}${attrValue}`;\n    }\n\n    return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :\n                                                  `<${tagName}${classAttr}${attrs}></${tagName}>`;\n  }\n\n  getAttrs(): string[] {\n    const result: string[] = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n\n  addAttribute(name: string, value: string = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n\n  addClassName(name: string) {\n    this.classNames.push(name.toLowerCase());\n  }\n\n  toString(): string {\n    let res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.escapeAttribute(this.attrs[i]);\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher<T = any> {\n  static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher<null> {\n    const notMatcher = new SelectorMatcher<null>();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n\n  private _elementMap = new Map<string, SelectorContext<T>[]>();\n  private _elementPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _classMap = new Map<string, SelectorContext<T>[]>();\n  private _classPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _attrValueMap = new Map<string, Map<string, SelectorContext<T>[]>>();\n  private _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher<T>>>();\n  private _listContexts: SelectorListContext[] = [];\n\n  addSelectables(cssSelectors: CssSelector[], callbackCtxt?: T) {\n    let listContext: SelectorListContext = null!;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt as T, listContext);\n    }\n  }\n\n  /**\n   * Add an object that can be found later on by calling `match`.\n   * @param cssSelector A css selector\n   * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n   */\n  private _addSelectable(\n      cssSelector: CssSelector, callbackCtxt: T, listContext: SelectorListContext) {\n    let matcher: SelectorMatcher<T> = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext<T>[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher<T>>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n\n  private _addTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, selectable: SelectorContext<T>) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n\n  private _addPartial(map: Map<string, SelectorMatcher<T>>, name: string): SelectorMatcher<T> {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher<T>();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n\n  /**\n   * Find the objects that have been added via `addSelectable`\n   * whose css selector is contained in the given css selector.\n   * @param cssSelector A css selector\n   * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n   * @return boolean true if a match was found\n   */\n  match(cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = false;\n    const element = cssSelector.element!;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n        result;\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result =\n            this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n            this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n            result;\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n\n        const terminalValuesMap = this._attrValueMap.get(name)!;\n        if (value) {\n          result =\n              this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const partialValuesMap = this._attrValuePartialMap.get(name)!;\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let selectables: SelectorContext<T>[] = map.get(name) || [];\n    const starSelectables: SelectorContext<T>[] = map.get('*')!;\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable: SelectorContext<T>;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchPartial(\n      map: Map<string, SelectorMatcher<T>>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\n\nexport class SelectorListContext {\n  alreadyMatched: boolean = false;\n\n  constructor(public selectors: CssSelector[]) {}\n}\n\n// Store context to pass back selector and context when a selector is matched\nexport class SelectorContext<T = any> {\n  notSelectors: CssSelector[];\n\n  constructor(\n      public selector: CssSelector, public cbContext: T, public listContext: SelectorListContext) {\n    this.notSelectors = selector.notSelectors;\n  }\n\n  finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Attention:\n// This file duplicates types and values from @angular/core\n// so that we are able to make @angular/compiler independent of @angular/core.\n// This is important to prevent a build cycle, as @angular/core needs to\n// be compiled with the compiler.\n\nimport {CssSelector} from './selector';\n\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nexport const emitDistinctChangesOnlyDefaultValue = true;\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  None = 2,\n  ShadowDom = 3\n}\n\nexport enum ChangeDetectionStrategy {\n  OnPush = 0,\n  Default = 1\n}\n\nexport interface Input {\n  bindingPropertyName?: string;\n}\n\nexport interface Output {\n  bindingPropertyName?: string;\n}\n\nexport interface HostBinding {\n  hostPropertyName?: string;\n}\n\nexport interface HostListener {\n  eventName?: string;\n  args?: string[];\n}\n\nexport interface SchemaMetadata {\n  name: string;\n}\n\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements'\n};\n\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema'\n};\n\nexport interface Type extends Function {\n  new(...args: any[]): any;\n}\nexport const Type = Function;\n\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 1 << 0,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 1 << 1,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 1 << 2,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 1 << 3,\n  /**\n   * This token is being injected into a pipe.\n   * @internal\n   */\n  ForPipe = 1 << 4,\n}\n\nexport enum MissingTranslationStrategy {\n  Error = 0,\n  Warning = 1,\n  Ignore = 2,\n}\n\n/**\n * Flags used to generate R3-style CSS Selectors. They are pasted from\n * core/src/render3/projection.ts because they cannot be referenced directly.\n */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// These are a copy the CSS types from core/src/render3/interfaces/projection.ts\n// They are duplicated here as they cannot be directly referenced from core.\nexport type R3CssSelector = (string|SelectorFlags)[];\nexport type R3CssSelectorList = R3CssSelector[];\n\nfunction parserSelectorToSimpleSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\n\nfunction parserSelectorToNegativeSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n\n  if (selector.element) {\n    return [\n      SelectorFlags.NOT | SelectorFlags.ELEMENT, selector.element, ...selector.attrs, ...classes\n    ];\n  } else if (selector.attrs.length) {\n    return [SelectorFlags.NOT | SelectorFlags.ATTRIBUTE, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length ?\n        [SelectorFlags.NOT | SelectorFlags.CLASS, ...selector.classNames] :\n        [];\n  }\n}\n\nfunction parserSelectorToR3Selector(selector: CssSelector): R3CssSelector {\n  const positive = parserSelectorToSimpleSelector(selector);\n\n  const negative: R3CssSelectorList = selector.notSelectors && selector.notSelectors.length ?\n      selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :\n      [];\n\n  return positive.concat(...negative);\n}\n\nexport function parseSelectorToR3Selector(selector: string|null): R3CssSelectorList {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\n// Pasted from render3/interfaces/definition since it cannot be referenced directly\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10\n}\n\n// Pasted from render3/interfaces/node.ts\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n   * Signals class declaration.\n   *\n   * Each value following `Classes` designates a class name to include on the element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div class=\"foo bar baz\">...<d/vi>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n   * ```\n   */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   */\n  I18n = 6,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function splitAtColon(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, ':', defaultValues);\n}\n\nexport function splitAtPeriod(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, '.', defaultValues);\n}\n\nfunction _splitAt(input: string, character: string, defaultValues: string[]): string[] {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n\nexport function noUndefined<T>(val: T|undefined): T {\n  return val === undefined ? null! : val;\n}\n\nexport function error(msg: string): never {\n  throw new Error(`Internal Error: ${msg}`);\n}\n\n// Escape characters that have a special meaning in Regular Expressions\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nexport type Byte = number;\n\nexport function utf8Encode(str: string): Byte[] {\n  let encoded: Byte[] = [];\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(\n          (codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(\n          ((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80,\n          ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    }\n  }\n\n  return encoded;\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  if (!token.toString) {\n    return 'object';\n  }\n\n  // WARNING: do not try to `JSON.stringify(token)` here\n  // see https://github.com/angular/angular/issues/23440\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\n\nexport interface Console {\n  log(message: string): void;\n  warn(message: string): void;\n}\n\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n\n// Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\nconst _global: {[name: string]: any} = __global || __window || __self;\nexport {_global as global};\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value!);\n  }\n  return list;\n}\n\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nexport function partitionArray<T, F = T>(\n    arr: (T|F)[], conditionFn: (value: T|F) => boolean): [T[], F[]] {\n  const truthy: T[] = [];\n  const falsy: F[] = [];\n  for (const item of arr) {\n    (conditionFn(item) ? truthy : falsy).push(item as any);\n  }\n  return [truthy, falsy];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a big integer using a buffer of its individual digits, with the least significant\n * digit stored at the beginning of the array (little endian).\n *\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\n * to reduce memory pressure of allocation for the digits array.\n */\nexport class BigInteger {\n  static zero(): BigInteger {\n    return new BigInteger([0]);\n  }\n\n  static one(): BigInteger {\n    return new BigInteger([1]);\n  }\n\n  /**\n   * Creates a big integer using its individual digits in little endian storage.\n   */\n  private constructor(private readonly digits: number[]) {}\n\n  /**\n   * Creates a clone of this instance.\n   */\n  clone(): BigInteger {\n    return new BigInteger(this.digits.slice());\n  }\n\n  /**\n   * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n   * `this` but instead returns a new instance, unlike `addToSelf`.\n   */\n  add(other: BigInteger): BigInteger {\n    const result = this.clone();\n    result.addToSelf(other);\n    return result;\n  }\n\n  /**\n   * Adds `other` to the instance itself, thereby mutating its value.\n   */\n  addToSelf(other: BigInteger): void {\n    const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n    let carry = 0;\n    for (let i = 0; i < maxNrOfDigits; i++) {\n      let digitSum = carry;\n      if (i < this.digits.length) {\n        digitSum += this.digits[i];\n      }\n      if (i < other.digits.length) {\n        digitSum += other.digits[i];\n      }\n\n      if (digitSum >= 10) {\n        this.digits[i] = digitSum - 10;\n        carry = 1;\n      } else {\n        this.digits[i] = digitSum;\n        carry = 0;\n      }\n    }\n\n    // Apply a remaining carry if needed.\n    if (carry > 0) {\n      this.digits[maxNrOfDigits] = 1;\n    }\n  }\n\n  /**\n   * Builds the decimal string representation of the big integer. As this is stored in\n   * little endian, the digits are concatenated in reverse order.\n   */\n  toString(): string {\n    let res = '';\n    for (let i = this.digits.length - 1; i >= 0; i--) {\n      res += this.digits[i];\n    }\n    return res;\n  }\n}\n\n/**\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n */\nexport class BigIntForMultiplication {\n  /**\n   * Stores all memoized power-of-twos, where each index represents `this.number * 2^index`.\n   */\n  private readonly powerOfTwos: BigInteger[];\n\n  constructor(value: BigInteger) {\n    this.powerOfTwos = [value];\n  }\n\n  /**\n   * Returns the big integer itself.\n   */\n  getValue(): BigInteger {\n    return this.powerOfTwos[0];\n  }\n\n  /**\n   * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n   * value for `b` is represented by a storage model that is optimized for this computation.\n   *\n   * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n   * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n   * used as exponent into the power-of-two multiplication of `b`.\n   *\n   * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n   * algorithm unrolls into the following iterations:\n   *\n   *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n   * -----------|------------|------|------------|------|--------\n   *  0         | 0b00101010 | 0    | 1337       | No   | 0\n   *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n   *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n   *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n   *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n   *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n   *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n   *\n   * The computed product of 56154 is indeed the correct result.\n   *\n   * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n   * power-of-two values to reduce the workload in computing those values.\n   */\n  multiplyBy(num: number): BigInteger {\n    const product = BigInteger.zero();\n    this.multiplyByAndAddTo(num, product);\n    return product;\n  }\n\n  /**\n   * See `multiplyBy()` for details. This function allows for the computed product to be added\n   * directly to the provided result big integer.\n   */\n  multiplyByAndAddTo(num: number, result: BigInteger): void {\n    for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n      if (num & 1) {\n        const value = this.getMultipliedByPowerOfTwo(exponent);\n        result.addToSelf(value);\n      }\n    }\n  }\n\n  /**\n   * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n   */\n  private getMultipliedByPowerOfTwo(exponent: number): BigInteger {\n    // Compute the powers up until the requested exponent, where each value is computed from its\n    // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n    // added to itself) to reach `this.number * 2^exponent`.\n    for (let i = this.powerOfTwos.length; i <= exponent; i++) {\n      const previousPower = this.powerOfTwos[i - 1];\n      this.powerOfTwos[i] = previousPower.add(previousPower);\n    }\n    return this.powerOfTwos[exponent];\n  }\n}\n\n/**\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n * representation that is lazily computed upon request.\n */\nexport class BigIntExponentiation {\n  private readonly exponents = [new BigIntForMultiplication(BigInteger.one())];\n\n  constructor(private readonly base: number) {}\n\n  /**\n   * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n   * further multiplication operations.\n   */\n  toThePowerOf(exponent: number): BigIntForMultiplication {\n    // Compute the results up until the requested exponent, where every value is computed from its\n    // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n    // to reach `this.base^exponent`.\n    for (let i = this.exponents.length; i <= exponent; i++) {\n      const value = this.exponents[i - 1].multiplyBy(this.base);\n      this.exponents[i] = new BigIntForMultiplication(value);\n    }\n    return this.exponents[exponent];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Byte, newArray, utf8Encode} from '../util';\nimport {BigIntExponentiation} from './big_integer';\n\nimport * as i18n from './i18n_ast';\n\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nexport function digest(message: i18n.Message): string {\n  return message.id || computeDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nexport function computeDigest(message: i18n.Message): string {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nexport function decimalDigest(message: i18n.Message): string {\n  return message.id || computeDecimalDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nexport function computeDecimalDigest(message: i18n.Message): string {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid ?\n        `<ph tag name=\"${ph.startName}\"/>` :\n        `<ph tag name=\"${ph.startName}\">${\n            ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n}\n\nconst serializerVisitor = new _SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map(a => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  override visitIcu(icu: i18n.Icu, context: any): any {\n    let strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  const utf8 = utf8Encode(str);\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = newArray(80);\n  let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\n\n  words32[len >> 5] |= 0x80 << (24 - len % 32);\n  words32[((len + 64 >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\n\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  return bytesToHexString(words32ToByteString([a, b, c, d, e]));\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): [number, number] {\n  const utf8 = utf8Encode(str);\n\n  let hi = hash32(utf8, 0);\n  let lo = hash32(utf8, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nexport function computeMsgId(msg: string, meaning: string = ''): string {\n  let msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    const meaningFingerprint = fingerprint(meaning);\n    msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n  }\n\n  const hi = msgFingerprint[0];\n  const lo = msgFingerprint[1];\n\n  return wordsToDecimalString(hi & 0x7fffffff, lo);\n}\n\nfunction hash32(bytes: Byte[], c: number): number {\n  let a = 0x9e3779b9, b = 0x9e3779b9;\n  let i: number;\n\n  const len = bytes.length;\n\n  for (i = 0; i + 12 <= len; i += 12) {\n    a = add32(a, wordAt(bytes, i, Endian.Little));\n    b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n    c = add32(c, wordAt(bytes, i + 8, Endian.Little));\n    const res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n\n  a = add32(a, wordAt(bytes, i, Endian.Little));\n  b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n  // the first byte of c is reserved for the length\n  c = add32(c, len);\n  c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);\n\n  return mix(a, b, c)[2];\n}\n\n// clang-format off\nfunction mix(a: number, b: number, c: number): [number, number, number] {\n  a = sub32(a, b); a = sub32(a, c); a ^= c >>> 13;\n  b = sub32(b, c); b = sub32(b, a); b ^= a << 8;\n  c = sub32(c, a); c = sub32(c, b); c ^= b >>> 13;\n  a = sub32(a, b); a = sub32(a, c); a ^= c >>> 12;\n  b = sub32(b, c); b = sub32(b, a); b ^= a << 16;\n  c = sub32(c, a); c = sub32(c, b); c ^= b >>> 5;\n  a = sub32(a, b); a = sub32(a, c); a ^= c >>> 3;\n  b = sub32(b, c); b = sub32(b, a); b ^= a << 10;\n  c = sub32(c, a); c = sub32(c, b); c ^= b >>> 15;\n  return [a, b, c];\n}\n// clang-format on\n\n// Utils\n\nenum Endian {\n  Little,\n  Big,\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\nfunction add64(a: [number, number], b: [number, number]): [number, number] {\n  const ah = a[0], al = a[1];\n  const bh = b[0], bl = b[1];\n  const result = add32to64(al, bl);\n  const carry = result[0];\n  const l = result[1];\n  const h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\nfunction sub32(a: number, b: number): number {\n  const low = (a & 0xffff) - (b & 0xffff);\n  const high = (a >> 16) - (b >> 16) + (low >> 16);\n  return (high << 16) | (low & 0xffff);\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\n// Rotate a 64b number left `count` position\nfunction rol64(num: [number, number], count: number): [number, number] {\n  const hi = num[0], lo = num[1];\n  const h = (hi << count) | (lo >>> (32 - count));\n  const l = (lo << count) | (hi >>> (32 - count));\n  return [h, l];\n}\n\nfunction bytesToWords32(bytes: Byte[], endian: Endian): number[] {\n  const size = (bytes.length + 3) >>> 2;\n  const words32 = [];\n\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(bytes: Byte[], index: number): Byte {\n  return index >= bytes.length ? 0 : bytes[index];\n}\n\nfunction wordAt(bytes: Byte[], index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 8 * i;\n    }\n  }\n  return word;\n}\n\nfunction words32ToByteString(words32: number[]): Byte[] {\n  return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), [] as Byte[]);\n}\n\nfunction word32ToByteString(word: number): Byte[] {\n  let bytes: Byte[] = [];\n  for (let i = 0; i < 4; i++) {\n    bytes.push((word >>> 8 * (3 - i)) & 0xff);\n  }\n  return bytes;\n}\n\nfunction bytesToHexString(bytes: Byte[]): string {\n  let hex: string = '';\n  for (let i = 0; i < bytes.length; i++) {\n    const b = byteAt(bytes, i);\n    hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n  }\n  return hex.toLowerCase();\n}\n\n/**\n * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\n * power-of-256 results with memoized power-of-two computations for efficient multiplication.\n *\n * For our purposes, this can be safely stored as a global without memory concerns. The reason is\n * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\n * exponent.\n */\nconst base256 = new BigIntExponentiation(256);\n\n/**\n * Represents two 32-bit words as a single decimal number. This requires a big integer storage\n * model as JS numbers are not accurate enough to represent the 64-bit number.\n *\n * Based on https://www.danvk.org/hex2dec.html\n */\nfunction wordsToDecimalString(hi: number, lo: number): string {\n  // Encode the four bytes in lo in the lower digits of the decimal number.\n  // Note: the multiplication results in lo itself but represented by a big integer using its\n  // decimal digits.\n  const decimal = base256.toThePowerOf(0).multiplyBy(lo);\n\n  // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\n  // this multiplication factor is applied.\n  base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\n\n  return decimal.toString();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {computeMsgId} from '../i18n/digest';\nimport {Message} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\nimport {I18nMeta} from '../render3/view/i18n/meta';\n\n//// Types\nexport enum TypeModifier {\n  None = 0,\n  Const = 1 << 0,\n}\n\nexport abstract class Type {\n  constructor(public modifiers: TypeModifier = TypeModifier.None) {}\n  abstract visitType(visitor: TypeVisitor, context: any): any;\n\n  hasModifier(modifier: TypeModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\n\nexport enum BuiltinTypeName {\n  Dynamic,\n  Bool,\n  String,\n  Int,\n  Number,\n  Function,\n  Inferred,\n  None,\n}\n\nexport class BuiltinType extends Type {\n  constructor(public name: BuiltinTypeName, modifiers?: TypeModifier) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\n\nexport class ExpressionType extends Type {\n  constructor(\n      public value: Expression, modifiers?: TypeModifier, public typeParams: Type[]|null = null) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitExpressionType(this, context);\n  }\n}\n\n\nexport class ArrayType extends Type {\n  constructor(public of: Type, modifiers?: TypeModifier) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitArrayType(this, context);\n  }\n}\n\n\nexport class MapType extends Type {\n  public valueType: Type|null;\n  constructor(valueType: Type|null|undefined, modifiers?: TypeModifier) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitMapType(this, context);\n  }\n}\n\nexport const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nexport const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n\nexport interface TypeVisitor {\n  visitBuiltinType(type: BuiltinType, context: any): any;\n  visitExpressionType(type: ExpressionType, context: any): any;\n  visitArrayType(type: ArrayType, context: any): any;\n  visitMapType(type: MapType, context: any): any;\n}\n\n///// Expressions\n\nexport enum UnaryOperator {\n  Minus,\n  Plus,\n}\n\nexport enum BinaryOperator {\n  Equals,\n  NotEquals,\n  Identical,\n  NotIdentical,\n  Minus,\n  Plus,\n  Divide,\n  Multiply,\n  Modulo,\n  And,\n  Or,\n  BitwiseAnd,\n  Lower,\n  LowerEquals,\n  Bigger,\n  BiggerEquals,\n  NullishCoalesce,\n}\n\nexport function nullSafeIsEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T|null, other: T|null) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalentPredicate<T>(\n    base: T[], other: T[], equivalentPredicate: (baseElement: T, otherElement: T) => boolean) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function areAllEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T[], other: T[]) {\n  return areAllEquivalentPredicate(\n      base, other, (baseElement: T, otherElement: T) => baseElement.isEquivalent(otherElement));\n}\n\nexport abstract class Expression {\n  public type: Type|null;\n  public sourceSpan: ParseSourceSpan|null;\n\n  constructor(type: Type|null|undefined, sourceSpan?: ParseSourceSpan|null) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\n\n  /**\n   * Calculates whether this expression produces the same value as the given expression.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(e: Expression): boolean;\n\n  /**\n   * Return true if the expression is constant.\n   */\n  abstract isConstant(): boolean;\n\n  prop(name: string, sourceSpan?: ParseSourceSpan|null): ReadPropExpr {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n\n  key(index: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadKeyExpr {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n\n  callFn(params: Expression[], sourceSpan?: ParseSourceSpan|null, pure?: boolean):\n      InvokeFunctionExpr {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n\n  instantiate(params: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null):\n      InstantiateExpr {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n\n  conditional(\n      trueCase: Expression, falseCase: Expression|null = null,\n      sourceSpan?: ParseSourceSpan|null): ConditionalExpr {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n\n  equals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  and(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs: Expression, sourceSpan?: ParseSourceSpan|null, parens: boolean = true):\n      BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n  }\n  or(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan?: ParseSourceSpan|null): Expression {\n    // Note: We use equals by purpose here to compare to null and undefined in JS.\n    // We use the typed null to allow strictNullChecks to narrow types.\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n\n  toStmt(): Statement {\n    return new ExpressionStatement(this, null);\n  }\n}\n\nexport class ReadVarExpr extends Expression {\n  constructor(public name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadVarExpr(this, context);\n  }\n\n  set(value: Expression): WriteVarExpr {\n    return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n  }\n}\n\nexport class TypeofExpr extends Expression {\n  constructor(public expr: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n}\n\nexport class WrappedNodeExpr<T> extends Expression {\n  constructor(public node: T, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n}\n\nexport class WriteVarExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public name: string, value: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteVarExpr(this, context);\n  }\n\n  toDeclStmt(type?: Type|null, modifiers?: StmtModifier): DeclareVarStmt {\n    return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n  }\n\n  toConstDecl(): DeclareVarStmt {\n    return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);\n  }\n}\n\n\nexport class WriteKeyExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public index: Expression, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteKeyExpr(this, context);\n  }\n}\n\n\nexport class WritePropExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public name: string, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWritePropExpr(this, context);\n  }\n}\n\nexport class InvokeFunctionExpr extends Expression {\n  constructor(\n      public fn: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public pure = false) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n        areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n}\n\n\nexport class TaggedTemplateExpr extends Expression {\n  constructor(\n      public tag: Expression, public template: TemplateLiteral, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&\n        areAllEquivalentPredicate(\n               this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&\n        areAllEquivalent(this.template.expressions, e.template.expressions);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTaggedTemplateExpr(this, context);\n  }\n}\n\n\nexport class InstantiateExpr extends Expression {\n  constructor(\n      public classExpr: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n        areAllEquivalent(this.args, e.args);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n}\n\n\nexport class LiteralExpr extends Expression {\n  constructor(\n      public value: number|string|boolean|null|undefined, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralExpr(this, context);\n  }\n}\n\nexport class TemplateLiteral {\n  constructor(public elements: TemplateLiteralElement[], public expressions: Expression[]) {}\n}\nexport class TemplateLiteralElement {\n  rawText: string;\n  constructor(public text: string, public sourceSpan?: ParseSourceSpan, rawText?: string) {\n    // If `rawText` is not provided, try to extract the raw string from its\n    // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n    // string instead by escaping the following control sequences:\n    // - \"\\\" would otherwise indicate that the next character is a control character.\n    // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n    // indicate the end of the template literal element.\n    this.rawText =\n        rawText ?? sourceSpan?.toString() ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n}\n\nexport class LiteralPiece {\n  constructor(public text: string, public sourceSpan: ParseSourceSpan) {}\n}\nexport class PlaceholderPiece {\n  /**\n   * Create a new instance of a `PlaceholderPiece`.\n   *\n   * @param text the name of this placeholder (e.g. `PH_1`).\n   * @param sourceSpan the location of this placeholder in its localized message the source code.\n   * @param associatedMessage reference to another message that this placeholder is associated with.\n   * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n   * been extracted out from the message containing the placeholder.\n   */\n  constructor(\n      public text: string, public sourceSpan: ParseSourceSpan, public associatedMessage?: Message) {\n  }\n}\n\nexport type MessagePiece = LiteralPiece|PlaceholderPiece;\n\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nconst LEGACY_ID_INDICATOR = '␟';\n\nexport class LocalizedString extends Expression {\n  constructor(\n      readonly metaBlock: I18nMeta, readonly messageParts: LiteralPiece[],\n      readonly placeHolderNames: PlaceholderPiece[], readonly expressions: Expression[],\n      sourceSpan?: ParseSourceSpan|null) {\n    super(STRING_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    // return e instanceof LocalizedString && this.message === e.message;\n    return false;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLocalizedString(this, context);\n  }\n\n  /**\n   * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n   * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n   * `parseI18nMeta()`.\n   *\n   * @param meta The metadata to serialize\n   * @param messagePart The first part of the tagged string\n   */\n  serializeI18nHead(): CookedRawString {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach(legacyId => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(\n        metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n  }\n\n  getMessagePartSourceSpan(i: number): ParseSourceSpan|null {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n\n  getPlaceholderSourceSpan(i: number): ParseSourceSpan {\n    return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ??\n        this.sourceSpan;\n  }\n\n  /**\n   * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n   * can be used in a `$localize` tagged string.\n   *\n   * The format is `:<placeholder-name>[@@<associated-id>]:`.\n   *\n   * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n   * refers.\n   *\n   * @param partIndex The index of the message part to serialize.\n   */\n  serializeI18nTemplatePart(partIndex: number): CookedRawString {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR}${\n          computeMsgId(\n              placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n    }\n    return createCookedRawString(\n        metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n  }\n}\n\n/**\n * A structure to hold the cooked and raw strings of a template literal element, along with its\n * source-span range.\n */\nexport interface CookedRawString {\n  cooked: string;\n  raw: string;\n  range: ParseSourceSpan|null;\n}\n\nconst escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str: string): string =>\n    str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(\n    metaBlock: string, messagePart: string, range: ParseSourceSpan|null): CookedRawString {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range,\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(\n          `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n      range,\n    };\n  }\n}\n\nexport class ExternalExpr extends Expression {\n  constructor(\n      public value: ExternalReference, type?: Type|null, public typeParams: Type[]|null = null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ExternalExpr && this.value.name === e.value.name &&\n        this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitExternalExpr(this, context);\n  }\n}\n\nexport class ExternalReference {\n  constructor(public moduleName: string|null, public name: string|null, public runtime?: any|null) {\n  }\n  // Note: no isEquivalent method here as we use this as an interface too.\n}\n\nexport class ConditionalExpr extends Expression {\n  public trueCase: Expression;\n\n  constructor(\n      public condition: Expression, trueCase: Expression, public falseCase: Expression|null = null,\n      type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || trueCase.type, sourceSpan);\n    this.trueCase = trueCase;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n        this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitConditionalExpr(this, context);\n  }\n}\n\n\nexport class NotExpr extends Expression {\n  constructor(public condition: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(BOOL_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitNotExpr(this, context);\n  }\n}\n\nexport class FnParam {\n  constructor(public name: string, public type: Type|null = null) {}\n\n  isEquivalent(param: FnParam): boolean {\n    return this.name === param.name;\n  }\n}\n\n\nexport class FunctionExpr extends Expression {\n  constructor(\n      public params: FnParam[], public statements: Statement[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public name?: string|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n        areAllEquivalent(this.statements, e.statements);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitFunctionExpr(this, context);\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareFunctionStmt {\n    return new DeclareFunctionStmt(\n        name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n  }\n}\n\n\nexport class UnaryOperatorExpr extends Expression {\n  constructor(\n      public operator: UnaryOperator, public expr: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || NUMBER_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof UnaryOperatorExpr && this.operator === e.operator &&\n        this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n}\n\n\nexport class BinaryOperatorExpr extends Expression {\n  public lhs: Expression;\n  constructor(\n      public operator: BinaryOperator, lhs: Expression, public rhs: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || lhs.type, sourceSpan);\n    this.lhs = lhs;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n        this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n}\n\n\nexport class ReadPropExpr extends Expression {\n  constructor(\n      public receiver: Expression, public name: string, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadPropExpr(this, context);\n  }\n\n  set(value: Expression): WritePropExpr {\n    return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class ReadKeyExpr extends Expression {\n  constructor(\n      public receiver: Expression, public index: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n\n  set(value: Expression): WriteKeyExpr {\n    return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class LiteralArrayExpr extends Expression {\n  public entries: Expression[];\n  constructor(entries: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n\n  override isConstant() {\n    return this.entries.every(e => e.isConstant());\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n}\n\nexport class LiteralMapEntry {\n  constructor(public key: string, public value: Expression, public quoted: boolean) {}\n  isEquivalent(e: LiteralMapEntry): boolean {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n}\n\nexport class LiteralMapExpr extends Expression {\n  public valueType: Type|null = null;\n  constructor(\n      public entries: LiteralMapEntry[], type?: MapType|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n\n  override isConstant() {\n    return this.entries.every(e => e.value.isConstant());\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n}\n\nexport class CommaExpr extends Expression {\n  constructor(public parts: Expression[], sourceSpan?: ParseSourceSpan|null) {\n    super(parts[parts.length - 1].type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCommaExpr(this, context);\n  }\n}\n\nexport interface ExpressionVisitor {\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any;\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): any;\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;\n  visitWritePropExpr(expr: WritePropExpr, context: any): any;\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any;\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\n  visitLiteralExpr(ast: LiteralExpr, context: any): any;\n  visitLocalizedString(ast: LocalizedString, context: any): any;\n  visitExternalExpr(ast: ExternalExpr, context: any): any;\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any;\n  visitNotExpr(ast: NotExpr, context: any): any;\n  visitFunctionExpr(ast: FunctionExpr, context: any): any;\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any;\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any;\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\n  visitCommaExpr(ast: CommaExpr, context: any): any;\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\n  visitTypeofExpr(ast: TypeofExpr, context: any): any;\n}\n\nexport const NULL_EXPR = new LiteralExpr(null, null, null);\nexport const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n\n//// Statements\nexport enum StmtModifier {\n  None = 0,\n  Final = 1 << 0,\n  Private = 1 << 1,\n  Exported = 1 << 2,\n  Static = 1 << 3,\n}\n\nexport class LeadingComment {\n  constructor(public text: string, public multiline: boolean, public trailingNewline: boolean) {}\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nexport class JSDocComment extends LeadingComment {\n  constructor(public tags: JSDocTag[]) {\n    super('', /* multiline */ true, /* trailingNewline */ true);\n  }\n  override toString(): string {\n    return serializeTags(this.tags);\n  }\n}\n\nexport abstract class Statement {\n  constructor(\n      public modifiers: StmtModifier = StmtModifier.None,\n      public sourceSpan: ParseSourceSpan|null = null, public leadingComments?: LeadingComment[]) {}\n  /**\n   * Calculates whether this statement produces the same value as the given statement.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(stmt: Statement): boolean;\n\n  abstract visitStatement(visitor: StatementVisitor, context: any): any;\n\n  hasModifier(modifier: StmtModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n\n  addLeadingComment(leadingComment: LeadingComment): void {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\n\n\nexport class DeclareVarStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public value?: Expression, type?: Type|null, modifiers?: StmtModifier,\n      sourceSpan?: ParseSourceSpan|null, leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || (value && value.type) || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n        (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\n\nexport class DeclareFunctionStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public params: FnParam[], public statements: Statement[],\n      type?: Type|null, modifiers?: StmtModifier, sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n        areAllEquivalent(this.statements, stmt.statements);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\n\nexport class ExpressionStatement extends Statement {\n  constructor(\n      public expr: Expression, sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\n\n\nexport class ReturnStatement extends Statement {\n  constructor(\n      public value: Expression, sourceSpan: ParseSourceSpan|null = null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\n\nexport class IfStmt extends Statement {\n  constructor(\n      public condition: Expression, public trueCase: Statement[],\n      public falseCase: Statement[] = [], sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n        areAllEquivalent(this.trueCase, stmt.trueCase) &&\n        areAllEquivalent(this.falseCase, stmt.falseCase);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitIfStmt(this, context);\n  }\n}\n\nexport interface StatementVisitor {\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\n  visitReturnStmt(stmt: ReturnStatement, context: any): any;\n  visitIfStmt(stmt: IfStmt, context: any): any;\n}\n\nexport class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\n  visitType(ast: Type, context: any): any {\n    return ast;\n  }\n  visitExpression(ast: Expression, context: any): any {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type: BuiltinType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type: ExpressionType, context: any): any {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach(param => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type: ArrayType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitMapType(type: MapType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n    return ast;\n  }\n  visitTypeofExpr(ast: TypeofExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitWriteVarExpr(ast: WriteVarExpr, context: any): any {\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWriteKeyExpr(ast: WriteKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWritePropExpr(ast: WritePropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any {\n    ast.tag.visitExpression(this, context);\n    this.visitAllExpressions(ast.template.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    if (ast.typeParams) {\n      ast.typeParams.forEach(type => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase!.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast: NotExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs: Expression[], context: any): void {\n    exprs.forEach(expr => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitAllStatements(stmts: Statement[], context: any): void {\n    stmts.forEach(stmt => stmt.visitStatement(this, context));\n  }\n}\n\nexport function leadingComment(\n    text: string, multiline: boolean = false, trailingNewline: boolean = true): LeadingComment {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\n\nexport function jsDocComment(tags: JSDocTag[] = []): JSDocComment {\n  return new JSDocComment(tags);\n}\n\nexport function variable(\n    name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadVarExpr {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nexport function importExpr(\n    id: ExternalReference, typeParams: Type[]|null = null,\n    sourceSpan?: ParseSourceSpan|null): ExternalExpr {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nexport function importType(\n    id: ExternalReference, typeParams?: Type[]|null, typeModifiers?: TypeModifier): ExpressionType|\n    null {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nexport function expressionType(\n    expr: Expression, typeModifiers?: TypeModifier, typeParams?: Type[]|null): ExpressionType {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nexport function typeofExpr(expr: Expression) {\n  return new TypeofExpr(expr);\n}\n\nexport function literalArr(\n    values: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralArrayExpr {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nexport function literalMap(\n    values: {key: string, quoted: boolean, value: Expression}[],\n    type: MapType|null = null): LiteralMapExpr {\n  return new LiteralMapExpr(\n      values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\n\nexport function unary(\n    operator: UnaryOperator, expr: Expression, type?: Type,\n    sourceSpan?: ParseSourceSpan|null): UnaryOperatorExpr {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\n\nexport function not(expr: Expression, sourceSpan?: ParseSourceSpan|null): NotExpr {\n  return new NotExpr(expr, sourceSpan);\n}\n\nexport function fn(\n    params: FnParam[], body: Statement[], type?: Type|null, sourceSpan?: ParseSourceSpan|null,\n    name?: string|null): FunctionExpr {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nexport function ifStmt(\n    condition: Expression, thenClause: Statement[], elseClause?: Statement[],\n    sourceSpan?: ParseSourceSpan, leadingComments?: LeadingComment[]) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\n\nexport function taggedTemplate(\n    tag: Expression, template: TemplateLiteral, type?: Type|null,\n    sourceSpan?: ParseSourceSpan|null): TaggedTemplateExpr {\n  return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n}\n\nexport function literal(\n    value: any, type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralExpr {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nexport function localizedString(\n    metaBlock: I18nMeta, messageParts: LiteralPiece[], placeholderNames: PlaceholderPiece[],\n    expressions: Expression[], sourceSpan?: ParseSourceSpan|null): LocalizedString {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nexport function isNull(exp: Expression): boolean {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n\n// The list of JSDoc tags that we currently support. Extend it if needed.\nexport const enum JSDocTagName {\n  Desc = 'desc',\n  Id = 'id',\n  Meaning = 'meaning',\n}\n\n/*\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier. See e.g. `ts.JSDocTag` and `ts.JSDocComment`.\n */\nexport type JSDocTag = {\n  // `tagName` is e.g. \"param\" in an `@param` declaration\n  tagName: JSDocTagName|string,\n  // Any remaining text on the tag, e.g. the description\n  text?: string,\n}|{\n  // no `tagName` for plain text documentation that occurs before any `@param` lines\n  tagName?: undefined, text: string,\n};\n\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag: JSDocTag): string {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\n\nfunction serializeTags(tags: JSDocTag[]): string {\n  if (tags.length === 0) return '';\n\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n    return `*${tagToString(tags[0])} `;\n  }\n\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\n\nconst CONSTANT_PREFIX = '_c';\n\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = o.variable('<unknown>');\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  // TODO(issue/24571): remove '!'.\n  shared!: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n\n  private nextNameIndex = 0;\n\n  constructor(private readonly isClosureCompilerEnabled: boolean = false) {}\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if ((literal instanceof o.LiteralExpr && !isLongStringLiteral(literal)) ||\n        literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      let definition: o.WriteVarExpr;\n      let usage: o.Expression;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        // For string literals, Closure will **always** inline the string at\n        // **all** usages, duplicating it each time. For large strings, this\n        // unnecessarily bloats bundle size. To work around this restriction, we\n        // wrap the string in a function, and call that function for each usage.\n        // This tricks Closure into using inline logic for functions instead of\n        // string literals. Function calls are only inlined if the body is small\n        // enough to be worth it. By doing this, very large strings will be\n        // shared across multiple usages, rather than duplicating the string at\n        // each usage site.\n        //\n        // const myStr = function() { return \"very very very long string\"; };\n        // const usage1 = myStr();\n        // const usage2 = myStr();\n        definition = o.variable(name).set(new o.FunctionExpr(\n            [],  // Params.\n            [\n              // Statements.\n              new o.ReturnStatement(literal),\n            ],\n            ));\n        usage = o.variable(name).callFn([]);\n      } else {\n        // Just declare and use the variable directly, without a function call\n        // indirection. This saves a few bytes and avoids an unncessary call.\n        definition = o.variable(name).set(literal);\n        usage = o.variable(name);\n      }\n\n      this.statements.push(definition.toDeclStmt(o.INFERRED_TYPE, o.StmtModifier.Final));\n      fixup.fixup(usage);\n    }\n\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name!, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(o.variable(name)\n                               .set(pureFunctionDeclaration)\n                               .toDeclStmt(o.INFERRED_TYPE, o.StmtModifier.Final));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string {\n    return `${prefix}${this.nextNameIndex++}`;\n  }\n\n  private freshName(): string {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr(node: o.ReadVarExpr) {\n    return `VAR:${node.name}`;\n  }\n\n  visitTypeofExpr(node: o.TypeofExpr, context: any): string {\n    return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitTaggedTemplateExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitUnaryOperatorExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n  visitLocalizedString = invalid;\n}\n\nfunction invalid<T>(this: o.ExpressionVisitor, arg: o.Expression|o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\nfunction isLongStringLiteral(expr: o.Expression): boolean {\n  return expr instanceof o.LiteralExpr && typeof expr.value === 'string' &&\n      expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\n\nconst CORE = '@angular/core';\n\nexport class Identifiers {\n  /* Methods */\n  static NEW_METHOD = 'factory';\n  static TRANSFORM_METHOD = 'transform';\n  static PATCH_DEPS = 'patchedDeps';\n\n  static core: o.ExternalReference = {name: null, moduleName: CORE};\n\n  /* Instructions */\n  static namespaceHTML: o.ExternalReference = {name: 'ɵɵnamespaceHTML', moduleName: CORE};\n\n  static namespaceMathML: o.ExternalReference = {name: 'ɵɵnamespaceMathML', moduleName: CORE};\n\n  static namespaceSVG: o.ExternalReference = {name: 'ɵɵnamespaceSVG', moduleName: CORE};\n\n  static element: o.ExternalReference = {name: 'ɵɵelement', moduleName: CORE};\n\n  static elementStart: o.ExternalReference = {name: 'ɵɵelementStart', moduleName: CORE};\n\n  static elementEnd: o.ExternalReference = {name: 'ɵɵelementEnd', moduleName: CORE};\n\n  static advance: o.ExternalReference = {name: 'ɵɵadvance', moduleName: CORE};\n\n  static syntheticHostProperty:\n      o.ExternalReference = {name: 'ɵɵsyntheticHostProperty', moduleName: CORE};\n\n  static syntheticHostListener:\n      o.ExternalReference = {name: 'ɵɵsyntheticHostListener', moduleName: CORE};\n\n  static attribute: o.ExternalReference = {name: 'ɵɵattribute', moduleName: CORE};\n\n  static attributeInterpolate1:\n      o.ExternalReference = {name: 'ɵɵattributeInterpolate1', moduleName: CORE};\n  static attributeInterpolate2:\n      o.ExternalReference = {name: 'ɵɵattributeInterpolate2', moduleName: CORE};\n  static attributeInterpolate3:\n      o.ExternalReference = {name: 'ɵɵattributeInterpolate3', moduleName: CORE};\n  static attributeInterpolate4:\n      o.ExternalReference = {name: 'ɵɵattributeInterpolate4', moduleName: CORE};\n  static attributeInterpolate5:\n      o.ExternalReference = {name: 'ɵɵattributeInterpolate5', moduleName: CORE};\n  static attributeInterpolate6:\n      o.ExternalReference = {name: 'ɵɵattributeInterpolate6', moduleName: CORE};\n  static attributeInterpolate7:\n      o.ExternalReference = {name: 'ɵɵattributeInterpolate7', moduleName: CORE};\n  static attributeInterpolate8:\n      o.ExternalReference = {name: 'ɵɵattributeInterpolate8', moduleName: CORE};\n  static attributeInterpolateV:\n      o.ExternalReference = {name: 'ɵɵattributeInterpolateV', moduleName: CORE};\n\n  static classProp: o.ExternalReference = {name: 'ɵɵclassProp', moduleName: CORE};\n\n  static elementContainerStart:\n      o.ExternalReference = {name: 'ɵɵelementContainerStart', moduleName: CORE};\n\n  static elementContainerEnd:\n      o.ExternalReference = {name: 'ɵɵelementContainerEnd', moduleName: CORE};\n\n  static elementContainer: o.ExternalReference = {name: 'ɵɵelementContainer', moduleName: CORE};\n\n  static styleMap: o.ExternalReference = {name: 'ɵɵstyleMap', moduleName: CORE};\n\n  static styleMapInterpolate1:\n      o.ExternalReference = {name: 'ɵɵstyleMapInterpolate1', moduleName: CORE};\n  static styleMapInterpolate2:\n      o.ExternalReference = {name: 'ɵɵstyleMapInterpolate2', moduleName: CORE};\n  static styleMapInterpolate3:\n      o.ExternalReference = {name: 'ɵɵstyleMapInterpolate3', moduleName: CORE};\n  static styleMapInterpolate4:\n      o.ExternalReference = {name: 'ɵɵstyleMapInterpolate4', moduleName: CORE};\n  static styleMapInterpolate5:\n      o.ExternalReference = {name: 'ɵɵstyleMapInterpolate5', moduleName: CORE};\n  static styleMapInterpolate6:\n      o.ExternalReference = {name: 'ɵɵstyleMapInterpolate6', moduleName: CORE};\n  static styleMapInterpolate7:\n      o.ExternalReference = {name: 'ɵɵstyleMapInterpolate7', moduleName: CORE};\n  static styleMapInterpolate8:\n      o.ExternalReference = {name: 'ɵɵstyleMapInterpolate8', moduleName: CORE};\n  static styleMapInterpolateV:\n      o.ExternalReference = {name: 'ɵɵstyleMapInterpolateV', moduleName: CORE};\n\n  static classMap: o.ExternalReference = {name: 'ɵɵclassMap', moduleName: CORE};\n\n  static classMapInterpolate1:\n      o.ExternalReference = {name: 'ɵɵclassMapInterpolate1', moduleName: CORE};\n  static classMapInterpolate2:\n      o.ExternalReference = {name: 'ɵɵclassMapInterpolate2', moduleName: CORE};\n  static classMapInterpolate3:\n      o.ExternalReference = {name: 'ɵɵclassMapInterpolate3', moduleName: CORE};\n  static classMapInterpolate4:\n      o.ExternalReference = {name: 'ɵɵclassMapInterpolate4', moduleName: CORE};\n  static classMapInterpolate5:\n      o.ExternalReference = {name: 'ɵɵclassMapInterpolate5', moduleName: CORE};\n  static classMapInterpolate6:\n      o.ExternalReference = {name: 'ɵɵclassMapInterpolate6', moduleName: CORE};\n  static classMapInterpolate7:\n      o.ExternalReference = {name: 'ɵɵclassMapInterpolate7', moduleName: CORE};\n  static classMapInterpolate8:\n      o.ExternalReference = {name: 'ɵɵclassMapInterpolate8', moduleName: CORE};\n  static classMapInterpolateV:\n      o.ExternalReference = {name: 'ɵɵclassMapInterpolateV', moduleName: CORE};\n\n  static styleProp: o.ExternalReference = {name: 'ɵɵstyleProp', moduleName: CORE};\n\n  static stylePropInterpolate1:\n      o.ExternalReference = {name: 'ɵɵstylePropInterpolate1', moduleName: CORE};\n  static stylePropInterpolate2:\n      o.ExternalReference = {name: 'ɵɵstylePropInterpolate2', moduleName: CORE};\n  static stylePropInterpolate3:\n      o.ExternalReference = {name: 'ɵɵstylePropInterpolate3', moduleName: CORE};\n  static stylePropInterpolate4:\n      o.ExternalReference = {name: 'ɵɵstylePropInterpolate4', moduleName: CORE};\n  static stylePropInterpolate5:\n      o.ExternalReference = {name: 'ɵɵstylePropInterpolate5', moduleName: CORE};\n  static stylePropInterpolate6:\n      o.ExternalReference = {name: 'ɵɵstylePropInterpolate6', moduleName: CORE};\n  static stylePropInterpolate7:\n      o.ExternalReference = {name: 'ɵɵstylePropInterpolate7', moduleName: CORE};\n  static stylePropInterpolate8:\n      o.ExternalReference = {name: 'ɵɵstylePropInterpolate8', moduleName: CORE};\n  static stylePropInterpolateV:\n      o.ExternalReference = {name: 'ɵɵstylePropInterpolateV', moduleName: CORE};\n\n  static nextContext: o.ExternalReference = {name: 'ɵɵnextContext', moduleName: CORE};\n\n  static templateCreate: o.ExternalReference = {name: 'ɵɵtemplate', moduleName: CORE};\n\n  static text: o.ExternalReference = {name: 'ɵɵtext', moduleName: CORE};\n\n  static enableBindings: o.ExternalReference = {name: 'ɵɵenableBindings', moduleName: CORE};\n\n  static disableBindings: o.ExternalReference = {name: 'ɵɵdisableBindings', moduleName: CORE};\n\n  static getCurrentView: o.ExternalReference = {name: 'ɵɵgetCurrentView', moduleName: CORE};\n\n  static textInterpolate: o.ExternalReference = {name: 'ɵɵtextInterpolate', moduleName: CORE};\n  static textInterpolate1: o.ExternalReference = {name: 'ɵɵtextInterpolate1', moduleName: CORE};\n  static textInterpolate2: o.ExternalReference = {name: 'ɵɵtextInterpolate2', moduleName: CORE};\n  static textInterpolate3: o.ExternalReference = {name: 'ɵɵtextInterpolate3', moduleName: CORE};\n  static textInterpolate4: o.ExternalReference = {name: 'ɵɵtextInterpolate4', moduleName: CORE};\n  static textInterpolate5: o.ExternalReference = {name: 'ɵɵtextInterpolate5', moduleName: CORE};\n  static textInterpolate6: o.ExternalReference = {name: 'ɵɵtextInterpolate6', moduleName: CORE};\n  static textInterpolate7: o.ExternalReference = {name: 'ɵɵtextInterpolate7', moduleName: CORE};\n  static textInterpolate8: o.ExternalReference = {name: 'ɵɵtextInterpolate8', moduleName: CORE};\n  static textInterpolateV: o.ExternalReference = {name: 'ɵɵtextInterpolateV', moduleName: CORE};\n\n  static restoreView: o.ExternalReference = {name: 'ɵɵrestoreView', moduleName: CORE};\n\n  static pureFunction0: o.ExternalReference = {name: 'ɵɵpureFunction0', moduleName: CORE};\n  static pureFunction1: o.ExternalReference = {name: 'ɵɵpureFunction1', moduleName: CORE};\n  static pureFunction2: o.ExternalReference = {name: 'ɵɵpureFunction2', moduleName: CORE};\n  static pureFunction3: o.ExternalReference = {name: 'ɵɵpureFunction3', moduleName: CORE};\n  static pureFunction4: o.ExternalReference = {name: 'ɵɵpureFunction4', moduleName: CORE};\n  static pureFunction5: o.ExternalReference = {name: 'ɵɵpureFunction5', moduleName: CORE};\n  static pureFunction6: o.ExternalReference = {name: 'ɵɵpureFunction6', moduleName: CORE};\n  static pureFunction7: o.ExternalReference = {name: 'ɵɵpureFunction7', moduleName: CORE};\n  static pureFunction8: o.ExternalReference = {name: 'ɵɵpureFunction8', moduleName: CORE};\n  static pureFunctionV: o.ExternalReference = {name: 'ɵɵpureFunctionV', moduleName: CORE};\n\n  static pipeBind1: o.ExternalReference = {name: 'ɵɵpipeBind1', moduleName: CORE};\n  static pipeBind2: o.ExternalReference = {name: 'ɵɵpipeBind2', moduleName: CORE};\n  static pipeBind3: o.ExternalReference = {name: 'ɵɵpipeBind3', moduleName: CORE};\n  static pipeBind4: o.ExternalReference = {name: 'ɵɵpipeBind4', moduleName: CORE};\n  static pipeBindV: o.ExternalReference = {name: 'ɵɵpipeBindV', moduleName: CORE};\n\n  static hostProperty: o.ExternalReference = {name: 'ɵɵhostProperty', moduleName: CORE};\n\n  static property: o.ExternalReference = {name: 'ɵɵproperty', moduleName: CORE};\n\n  static propertyInterpolate:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolate', moduleName: CORE};\n  static propertyInterpolate1:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolate1', moduleName: CORE};\n  static propertyInterpolate2:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolate2', moduleName: CORE};\n  static propertyInterpolate3:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolate3', moduleName: CORE};\n  static propertyInterpolate4:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolate4', moduleName: CORE};\n  static propertyInterpolate5:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolate5', moduleName: CORE};\n  static propertyInterpolate6:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolate6', moduleName: CORE};\n  static propertyInterpolate7:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolate7', moduleName: CORE};\n  static propertyInterpolate8:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolate8', moduleName: CORE};\n  static propertyInterpolateV:\n      o.ExternalReference = {name: 'ɵɵpropertyInterpolateV', moduleName: CORE};\n\n  static i18n: o.ExternalReference = {name: 'ɵɵi18n', moduleName: CORE};\n  static i18nAttributes: o.ExternalReference = {name: 'ɵɵi18nAttributes', moduleName: CORE};\n  static i18nExp: o.ExternalReference = {name: 'ɵɵi18nExp', moduleName: CORE};\n  static i18nStart: o.ExternalReference = {name: 'ɵɵi18nStart', moduleName: CORE};\n  static i18nEnd: o.ExternalReference = {name: 'ɵɵi18nEnd', moduleName: CORE};\n  static i18nApply: o.ExternalReference = {name: 'ɵɵi18nApply', moduleName: CORE};\n  static i18nPostprocess: o.ExternalReference = {name: 'ɵɵi18nPostprocess', moduleName: CORE};\n\n  static pipe: o.ExternalReference = {name: 'ɵɵpipe', moduleName: CORE};\n\n  static projection: o.ExternalReference = {name: 'ɵɵprojection', moduleName: CORE};\n  static projectionDef: o.ExternalReference = {name: 'ɵɵprojectionDef', moduleName: CORE};\n\n  static reference: o.ExternalReference = {name: 'ɵɵreference', moduleName: CORE};\n\n  static inject: o.ExternalReference = {name: 'ɵɵinject', moduleName: CORE};\n\n  static injectAttribute: o.ExternalReference = {name: 'ɵɵinjectAttribute', moduleName: CORE};\n\n  static directiveInject: o.ExternalReference = {name: 'ɵɵdirectiveInject', moduleName: CORE};\n  static invalidFactory: o.ExternalReference = {name: 'ɵɵinvalidFactory', moduleName: CORE};\n  static invalidFactoryDep: o.ExternalReference = {name: 'ɵɵinvalidFactoryDep', moduleName: CORE};\n\n  static templateRefExtractor:\n      o.ExternalReference = {name: 'ɵɵtemplateRefExtractor', moduleName: CORE};\n\n  static forwardRef: o.ExternalReference = {name: 'forwardRef', moduleName: CORE};\n  static resolveForwardRef: o.ExternalReference = {name: 'resolveForwardRef', moduleName: CORE};\n\n  static ɵɵdefineInjectable: o.ExternalReference = {name: 'ɵɵdefineInjectable', moduleName: CORE};\n  static declareInjectable: o.ExternalReference = {name: 'ɵɵngDeclareInjectable', moduleName: CORE};\n  static InjectableDeclaration:\n      o.ExternalReference = {name: 'ɵɵInjectableDeclaration', moduleName: CORE};\n\n  static resolveWindow: o.ExternalReference = {name: 'ɵɵresolveWindow', moduleName: CORE};\n  static resolveDocument: o.ExternalReference = {name: 'ɵɵresolveDocument', moduleName: CORE};\n  static resolveBody: o.ExternalReference = {name: 'ɵɵresolveBody', moduleName: CORE};\n\n  static defineComponent: o.ExternalReference = {name: 'ɵɵdefineComponent', moduleName: CORE};\n  static declareComponent: o.ExternalReference = {name: 'ɵɵngDeclareComponent', moduleName: CORE};\n\n  static setComponentScope: o.ExternalReference = {name: 'ɵɵsetComponentScope', moduleName: CORE};\n\n  static ChangeDetectionStrategy: o.ExternalReference = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n  };\n  static ViewEncapsulation: o.ExternalReference = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n  };\n\n  static ComponentDeclaration: o.ExternalReference = {\n    name: 'ɵɵComponentDeclaration',\n    moduleName: CORE,\n  };\n\n  static FactoryDeclaration: o.ExternalReference = {\n    name: 'ɵɵFactoryDeclaration',\n    moduleName: CORE,\n  };\n  static declareFactory: o.ExternalReference = {name: 'ɵɵngDeclareFactory', moduleName: CORE};\n  static FactoryTarget: o.ExternalReference = {name: 'ɵɵFactoryTarget', moduleName: CORE};\n\n  static defineDirective: o.ExternalReference = {name: 'ɵɵdefineDirective', moduleName: CORE};\n  static declareDirective: o.ExternalReference = {name: 'ɵɵngDeclareDirective', moduleName: CORE};\n\n  static DirectiveDeclaration: o.ExternalReference = {\n    name: 'ɵɵDirectiveDeclaration',\n    moduleName: CORE,\n  };\n\n  static InjectorDef: o.ExternalReference = {name: 'ɵɵInjectorDef', moduleName: CORE};\n  static InjectorDeclaration:\n      o.ExternalReference = {name: 'ɵɵInjectorDeclaration', moduleName: CORE};\n\n  static defineInjector: o.ExternalReference = {name: 'ɵɵdefineInjector', moduleName: CORE};\n  static declareInjector: o.ExternalReference = {name: 'ɵɵngDeclareInjector', moduleName: CORE};\n\n  static NgModuleDeclaration: o.ExternalReference = {\n    name: 'ɵɵNgModuleDeclaration',\n    moduleName: CORE,\n  };\n\n  static ModuleWithProviders: o.ExternalReference = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE,\n  };\n\n  static defineNgModule: o.ExternalReference = {name: 'ɵɵdefineNgModule', moduleName: CORE};\n  static declareNgModule: o.ExternalReference = {name: 'ɵɵngDeclareNgModule', moduleName: CORE};\n  static setNgModuleScope: o.ExternalReference = {name: 'ɵɵsetNgModuleScope', moduleName: CORE};\n\n  static PipeDeclaration: o.ExternalReference = {name: 'ɵɵPipeDeclaration', moduleName: CORE};\n\n  static definePipe: o.ExternalReference = {name: 'ɵɵdefinePipe', moduleName: CORE};\n  static declarePipe: o.ExternalReference = {name: 'ɵɵngDeclarePipe', moduleName: CORE};\n\n  static declareClassMetadata:\n      o.ExternalReference = {name: 'ɵɵngDeclareClassMetadata', moduleName: CORE};\n  static setClassMetadata: o.ExternalReference = {name: 'ɵsetClassMetadata', moduleName: CORE};\n\n  static queryRefresh: o.ExternalReference = {name: 'ɵɵqueryRefresh', moduleName: CORE};\n  static viewQuery: o.ExternalReference = {name: 'ɵɵviewQuery', moduleName: CORE};\n  static loadQuery: o.ExternalReference = {name: 'ɵɵloadQuery', moduleName: CORE};\n  static contentQuery: o.ExternalReference = {name: 'ɵɵcontentQuery', moduleName: CORE};\n\n  static NgOnChangesFeature: o.ExternalReference = {name: 'ɵɵNgOnChangesFeature', moduleName: CORE};\n\n  static InheritDefinitionFeature:\n      o.ExternalReference = {name: 'ɵɵInheritDefinitionFeature', moduleName: CORE};\n\n  static CopyDefinitionFeature:\n      o.ExternalReference = {name: 'ɵɵCopyDefinitionFeature', moduleName: CORE};\n\n  static ProvidersFeature: o.ExternalReference = {name: 'ɵɵProvidersFeature', moduleName: CORE};\n\n  static listener: o.ExternalReference = {name: 'ɵɵlistener', moduleName: CORE};\n\n  static getInheritedFactory: o.ExternalReference = {\n    name: 'ɵɵgetInheritedFactory',\n    moduleName: CORE,\n  };\n\n  // sanitization-related functions\n  static sanitizeHtml: o.ExternalReference = {name: 'ɵɵsanitizeHtml', moduleName: CORE};\n  static sanitizeStyle: o.ExternalReference = {name: 'ɵɵsanitizeStyle', moduleName: CORE};\n  static sanitizeResourceUrl:\n      o.ExternalReference = {name: 'ɵɵsanitizeResourceUrl', moduleName: CORE};\n  static sanitizeScript: o.ExternalReference = {name: 'ɵɵsanitizeScript', moduleName: CORE};\n  static sanitizeUrl: o.ExternalReference = {name: 'ɵɵsanitizeUrl', moduleName: CORE};\n  static sanitizeUrlOrResourceUrl:\n      o.ExternalReference = {name: 'ɵɵsanitizeUrlOrResourceUrl', moduleName: CORE};\n  static trustConstantHtml: o.ExternalReference = {name: 'ɵɵtrustConstantHtml', moduleName: CORE};\n  static trustConstantResourceUrl:\n      o.ExternalReference = {name: 'ɵɵtrustConstantResourceUrl', moduleName: CORE};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {utf8Encode} from '../util';\n\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION = 3;\n\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\ntype Segment = {\n  col0: number,\n  sourceUrl?: string,\n  sourceLine0?: number,\n  sourceCol0?: number,\n};\n\nexport type SourceMap = {\n  version: number,\n  file?: string,\n      sourceRoot: string,\n      sources: string[],\n      sourcesContent: (string|null)[],\n      mappings: string,\n};\n\nexport class SourceMapGenerator {\n  private sourcesContent: Map<string, string|null> = new Map();\n  private lines: Segment[][] = [];\n  private lastCol0: number = 0;\n  private hasMappings = false;\n\n  constructor(private file: string|null = null) {}\n\n  // The content is `null` when the content is expected to be loaded using the URL\n  addSource(url: string, content: string|null = null): this {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n\n  addLine(): this {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n\n  addMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({col0, sourceUrl, sourceLine0, sourceCol0});\n    return this;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get currentLine(): Segment[]|null {\n    return this.lines.slice(-1)[0];\n  }\n\n  toJSON(): SourceMap|null {\n    if (!this.hasMappings) {\n      return null;\n    }\n\n    const sourcesIndex = new Map<string, number>();\n    const sources: string[] = [];\n    const sourcesContent: (string|null)[] = [];\n\n    Array.from(this.sourcesContent.keys()).forEach((url: string, i: number) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n\n    let mappings: string = '';\n    let lastCol0: number = 0;\n    let lastSourceIndex: number = 0;\n    let lastSourceLine0: number = 0;\n    let lastSourceCol0: number = 0;\n\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n\n      mappings += segments\n                      .map(segment => {\n                        // zero-based starting column of the line in the generated code\n                        let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                        lastCol0 = segment.col0;\n\n                        if (segment.sourceUrl != null) {\n                          // zero-based index into the “sources” list\n                          segAsStr +=\n                              toBase64VLQ(sourcesIndex.get(segment.sourceUrl)! - lastSourceIndex);\n                          lastSourceIndex = sourcesIndex.get(segment.sourceUrl)!;\n                          // the zero-based starting line in the original source\n                          segAsStr += toBase64VLQ(segment.sourceLine0! - lastSourceLine0);\n                          lastSourceLine0 = segment.sourceLine0!;\n                          // the zero-based starting column in the original source\n                          segAsStr += toBase64VLQ(segment.sourceCol0! - lastSourceCol0);\n                          lastSourceCol0 = segment.sourceCol0!;\n                        }\n\n                        return segAsStr;\n                      })\n                      .join(',');\n      mappings += ';';\n    });\n\n    mappings = mappings.slice(0, -1);\n\n    return {\n      'file': this.file || '',\n      'version': VERSION,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings,\n    };\n  }\n\n  toJsComment(): string {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n                              '';\n  }\n}\n\nexport function toBase64String(value: string): string {\n  let b64 = '';\n  const encoded = utf8Encode(value);\n  for (let i = 0; i < encoded.length;) {\n    const i1 = encoded[i++];\n    const i2 = i < encoded.length ? encoded[i++] : null;\n    const i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n\nfunction toBase64VLQ(value: number): string {\n  value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction toBase64Digit(value: number): string {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n\n  return B64_DIGITS[value];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext {\n    return new EmitterVisitorContext(0);\n  }\n\n  private _lines: _EmittedLine[];\n\n  constructor(private _indent: number) {\n    this._lines = [new _EmittedLine(_indent)];\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get _currentLine(): _EmittedLine {\n    return this._lines[this._lines.length - 1];\n  }\n\n  println(from?: {sourceSpan: ParseSourceSpan|null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean {\n    return this._currentLine.parts.length === 0;\n  }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan|null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx]!;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  protected printLeadingComments(stmt: o.Statement, ctx: EmitterVisitorContext): void {\n    if (stmt.leadingComments === undefined) {\n      return;\n    }\n    for (const comment of stmt.leadingComments) {\n      if (comment instanceof o.JSDocComment) {\n        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n      } else {\n        if (comment.multiline) {\n          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n        } else {\n          comment.text.split('\\n').forEach((line) => {\n            ctx.println(stmt, `// ${line}`);\n          });\n        }\n      }\n    }\n  }\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitTaggedTemplateExpr(expr: o.TaggedTemplateExpr, ctx: EmitterVisitorContext): any {\n    expr.tag.visitExpression(this, ctx);\n    ctx.print(expr, '`' + expr.template.elements[0].rawText);\n    for (let i = 1; i < expr.template.elements.length; i++) {\n      ctx.print(expr, '${');\n      expr.template.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(expr, `}${expr.template.elements[i].rawText}`);\n    }\n    ctx.print(expr, '`');\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase!.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.UnaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.UnaryOperator.Minus:\n        opStr = '-';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ctx.print(ast, opStr);\n    ast.expr.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      case o.BinaryOperator.NullishCoalesce:\n        opStr = '??';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {escapeIdentifier} from '../output/abstract_emitter';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers} from './r3_identifiers';\n\nexport function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n  if (numParams === 0) {\n    return o.expressionType(type);\n  }\n  const params: o.Type[] = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(o.DYNAMIC_TYPE);\n  }\n  return o.expressionType(type, undefined, params);\n}\n\nexport interface R3Reference {\n  value: o.Expression;\n  type: o.Expression;\n}\n\n/**\n * Result of compilation of a render3 code unit, e.g. component, directive, pipe, etc.\n */\nexport interface R3CompiledExpression {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nconst ANIMATE_SYMBOL_PREFIX = '@';\nexport function prepareSyntheticPropertyName(name: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}`;\n}\n\nexport function prepareSyntheticListenerName(name: string, phase: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\n\nexport function getSafePropertyAccessString(accessor: string, name: string): string {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\n\nexport function prepareSyntheticListenerFunctionName(name: string, phase: string) {\n  return `animation_${name}_${phase}`;\n}\n\nexport function jitOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngJitMode', expr);\n}\n\nexport function devOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngDevMode', expr);\n}\n\nexport function guardedExpression(guard: string, expr: o.Expression): o.Expression {\n  const guardExpr = new o.ExternalExpr({name: guard, moduleName: null});\n  const guardNotDefined = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Identical, new o.TypeofExpr(guardExpr), o.literal('undefined'));\n  const guardUndefinedOrTrue = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined,\n      /* sourceSpan */ undefined, true);\n  return new o.BinaryOperatorExpr(o.BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\n\nexport function wrapReference(value: any): R3Reference {\n  const wrapped = new o.WrappedNodeExpr(value);\n  return {value: wrapped, type: wrapped};\n}\n\nexport function refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean): o.Expression {\n  const values = o.literalArr(refs.map(ref => ref.value));\n  return shouldForwardDeclare ? o.fn([], [new o.ReturnStatement(values)]) : values;\n}\n\n\n/**\n * Describes an expression that may have been wrapped in a `forwardRef()` guard.\n *\n * This is used when describing expressions that can refer to types that may eagerly reference types\n * that have not yet been defined.\n */\nexport interface MaybeForwardRefExpression<T extends o.Expression = o.Expression> {\n  /**\n   * The unwrapped expression.\n   */\n  expression: T;\n  /**\n   * Specified whether the `expression` contains a reference to something that has not yet been\n   * defined, and whether the expression is still wrapped in a `forwardRef()` call.\n   *\n   * If this value is `ForwardRefHandling.None` then the `expression` is safe to use as-is.\n   *\n   * Otherwise the `expression` was wrapped in a call to `forwardRef()` and must not be eagerly\n   * evaluated. Instead it must be wrapped in a function closure that will be evaluated lazily to\n   * allow the definition of the expression to be evaluated first.\n   *\n   * In full AOT compilation it can be safe to unwrap the `forwardRef()` call up front if the\n   * expression will actually be evaluated lazily inside a function call after the value of\n   * `expression` has been defined.\n   *\n   * But in other cases, such as partial AOT compilation or JIT compilation the expression will be\n   * evaluated eagerly in top level code so will need to continue to be wrapped in a `forwardRef()`\n   * call.\n   *\n   */\n  forwardRef: ForwardRefHandling;\n}\n\nexport function createMayBeForwardRefExpression<T extends o.Expression>(\n    expression: T, forwardRef: ForwardRefHandling): MaybeForwardRefExpression<T> {\n  return {expression, forwardRef};\n}\n\n/**\n * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n * `forwardRef()` call.\n *\n * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression\n * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated\n * in the code.\n *\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n */\nexport function convertFromMaybeForwardRefExpression(\n    {expression, forwardRef}: MaybeForwardRefExpression): o.Expression {\n  switch (forwardRef) {\n    case ForwardRefHandling.None:\n    case ForwardRefHandling.Wrapped:\n      return expression;\n    case ForwardRefHandling.Unwrapped:\n      return generateForwardRef(expression);\n  }\n}\n\n/**\n * Generate an expression that has the given `expr` wrapped in the following form:\n *\n * ```\n * forwardRef(() => expr)\n * ```\n */\nexport function generateForwardRef(expr: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.forwardRef).callFn([o.fn([], [new o.ReturnStatement(expr)])]);\n}\n\n/**\n * Specifies how a forward ref has been handled in a MaybeForwardRefExpression\n */\nexport const enum ForwardRefHandling {\n  /** The expression was not wrapped in a `forwardRef()` call in the first place. */\n  None,\n  /** The expression is still wrapped in a `forwardRef()` call. */\n  Wrapped,\n  /** The expression was wrapped in a `forwardRef()` call but has since been unwrapped. */\n  Unwrapped,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectFlags} from '../core';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3ConstructorFactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the interface type being constructed.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the constructor type, intended for use within a class definition\n   * itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /** Number of arguments for the `type`. */\n  typeArgumentCount: number;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\n   * be inherited from `fnOrClass` which is interpreted as the current type. If this is `'invalid'`,\n   * then one or more of the parameters wasn't resolvable and any attempt to use these deps will\n   * result in a runtime error.\n   */\n  deps: R3DependencyMetadata[]|'invalid'|null;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: FactoryTarget;\n}\n\nexport enum R3FactoryDelegateType {\n  Class = 0,\n  Function = 1,\n}\n\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType;\n  delegateDeps: R3DependencyMetadata[];\n}\n\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\n  expression: o.Expression;\n}\n\nexport type R3FactoryMetadata =\n    R3ConstructorFactoryMetadata|R3DelegatedFnOrClassMetadata|R3ExpressionFactoryMetadata;\n\nexport enum FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   * Or `null` if the dependency could not be resolved - making it invalid.\n   */\n  token: o.Expression|null;\n\n  /**\n   * If an @Attribute decorator is present, this is the literal type of the attribute name, or\n   * the unknown type if no literal type is available (e.g. the attribute name is an expression).\n   * Otherwise it is null;\n   */\n  attributeNameType: o.Expression|null;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const t = o.variable('t');\n  let baseFactoryVar: o.ReadVarExpr|null = null;\n\n  // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n  const typeForCtor = !isDelegatedFactoryMetadata(meta) ?\n      new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.internalType) :\n      t;\n\n  let ctorExpr: o.Expression|null = null;\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new o.InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    baseFactoryVar = o.variable(`ɵ${meta.name}_BaseFactory`);\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n\n  const body: o.Statement[] = [];\n  let retExpr: o.Expression|null = null;\n\n  function makeConditionalFactory(nonCtorExpr: o.Expression): o.ReadVarExpr {\n    const r = o.variable('r');\n    body.push(r.set(o.NULL_EXPR).toDeclStmt());\n    const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :\n                                         o.importExpr(R3.invalidFactory).callFn([]).toStmt();\n    body.push(o.ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedFactoryMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n    // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n    const factoryExpr = new (\n        meta.delegateType === R3FactoryDelegateType.Class ?\n            o.InstantiateExpr :\n            o.InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n\n  if (retExpr === null) {\n    // The expression cannot be formed so render an `ɵɵinvalidFactory()` call.\n    body.push(o.importExpr(R3.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    // This factory uses a base factory, so call `ɵɵgetInheritedFactory()` to compute it.\n    const getInheritedFactoryCall =\n        o.importExpr(R3.getInheritedFactory).callFn([meta.internalType]);\n    // Memoize the base factoryFn: `baseFactory || (baseFactory = ɵɵgetInheritedFactory(...))`\n    const baseFactory = new o.BinaryOperatorExpr(\n        o.BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n    body.push(new o.ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    // This is straightforward factory, just return it.\n    body.push(new o.ReturnStatement(retExpr));\n  }\n\n  let factoryFn: o.Expression = o.fn(\n      [new o.FnParam('t', o.DYNAMIC_TYPE)], body, o.INFERRED_TYPE, undefined,\n      `${meta.name}_Factory`);\n\n  if (baseFactoryVar !== null) {\n    // There is a base factory variable so wrap its declaration along with the factory function into\n    // an IIFE.\n    factoryFn = o.fn([], [\n                   new o.DeclareVarStmt(baseFactoryVar.name!), new o.ReturnStatement(factoryFn)\n                 ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);\n  }\n\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n\nexport function createFactoryType(meta: R3FactoryMetadata) {\n  const ctorDepsType =\n      meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : o.NONE_TYPE;\n  return o.expressionType(o.importExpr(\n      R3.FactoryDeclaration,\n      [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\n\nfunction injectDependencies(deps: R3DependencyMetadata[], target: FactoryTarget): o.Expression[] {\n  return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, target: FactoryTarget, index: number): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  if (dep.token === null) {\n    return o.importExpr(R3.invalidFactoryDep).callFn([o.literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    // Build up the injection flags according to the metadata.\n    const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n        (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n        (dep.optional ? InjectFlags.Optional : 0) |\n        (target === FactoryTarget.Pipe ? InjectFlags.ForPipe : 0);\n\n    // If this dependency is optional or otherwise has non-default flags, then additional\n    // parameters describing how to inject the dependency must be passed to the inject function\n    // that's being used.\n    let flagsParam: o.LiteralExpr|null =\n        (flags !== InjectFlags.Default || dep.optional) ? o.literal(flags) : null;\n\n    // Build up the arguments to the injectFn call.\n    const injectArgs = [dep.token];\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n    const injectFn = getInjectFn(target);\n    return o.importExpr(injectFn).callFn(injectArgs);\n  } else {\n    // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n    // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n    // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n    // we want to generate `ɵɵinjectAttribute(foo())`.\n    //\n    // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n    // typings.\n    return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n  }\n}\n\nfunction createCtorDepsType(deps: R3DependencyMetadata[]): o.Type {\n  let hasTypes = false;\n  const attributeTypes = deps.map(dep => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return o.literal(null);\n    }\n  });\n\n  if (hasTypes) {\n    return o.expressionType(o.literalArr(attributeTypes));\n  } else {\n    return o.NONE_TYPE;\n  }\n}\n\nfunction createCtorDepType(dep: R3DependencyMetadata): o.LiteralMapExpr|null {\n  const entries: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  if (dep.attributeNameType !== null) {\n    entries.push({key: 'attribute', value: dep.attributeNameType, quoted: false});\n  }\n  if (dep.optional) {\n    entries.push({key: 'optional', value: o.literal(true), quoted: false});\n  }\n  if (dep.host) {\n    entries.push({key: 'host', value: o.literal(true), quoted: false});\n  }\n  if (dep.self) {\n    entries.push({key: 'self', value: o.literal(true), quoted: false});\n  }\n  if (dep.skipSelf) {\n    entries.push({key: 'skipSelf', value: o.literal(true), quoted: false});\n  }\n\n  return entries.length > 0 ? o.literalMap(entries) : null;\n}\n\nexport function isDelegatedFactoryMetadata(meta: R3FactoryMetadata):\n    meta is R3DelegatedFnOrClassMetadata {\n  return (meta as any).delegateType !== undefined;\n}\n\nexport function isExpressionFactoryMetadata(meta: R3FactoryMetadata):\n    meta is R3ExpressionFactoryMetadata {\n  return (meta as any).expression !== undefined;\n}\n\nfunction getInjectFn(target: FactoryTarget): o.ExternalReference {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return R3.directiveInject;\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return R3.inject;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {AST, BindingType, BoundElementProperty, ParsedEvent, ParsedEventType} from '../expression_parser/ast';\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit<Result>(visitor: Visitor<Result>): Result;\n}\n\n/**\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\n * require the implementation of a visitor for Comments as they are only collected at\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\n * is true.\n */\nexport class Comment implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit<Result>(_visitor: Visitor<Result>): Result {\n    throw new Error('visit() not implemented for Comment');\n  }\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitText(this);\n  }\n}\n\nexport class BoundText implements Node {\n  constructor(public value: AST, public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundText(this);\n  }\n}\n\n/**\n * Represents a text attribute in the template.\n *\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\n */\nexport class TextAttribute implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan?: ParseSourceSpan,\n      public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTextAttribute(this);\n  }\n}\n\nexport class BoundAttribute implements Node {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: AST, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan: ParseSourceSpan|undefined,\n      public i18n: I18nMeta|undefined) {}\n\n  static fromBoundElementProperty(prop: BoundElementProperty, i18n?: I18nMeta): BoundAttribute {\n    if (prop.keySpan === undefined) {\n      throw new Error(\n          `Unexpected state: keySpan must be defined for bound attributes but was not for ${\n              prop.name}: ${prop.sourceSpan}`);\n    }\n    return new BoundAttribute(\n        prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan,\n        prop.keySpan, prop.valueSpan, i18n);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundAttribute(this);\n  }\n}\n\nexport class BoundEvent implements Node {\n  constructor(\n      public name: string, public type: ParsedEventType, public handler: AST,\n      public target: string|null, public phase: string|null, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan) {}\n\n  static fromParsedEvent(event: ParsedEvent) {\n    const target: string|null = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase: string|null =\n        event.type === ParsedEventType.Animation ? event.targetOrPhase : null;\n    if (event.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${\n          event.name}: ${event.sourceSpan}`);\n    }\n    return new BoundEvent(\n        event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan,\n        event.keySpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundEvent(this);\n  }\n}\n\nexport class Element implements Node {\n  constructor(\n      public name: string, public attributes: TextAttribute[], public inputs: BoundAttribute[],\n      public outputs: BoundEvent[], public children: Node[], public references: Reference[],\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitElement(this);\n  }\n}\n\nexport class Template implements Node {\n  constructor(\n      // tagName is the name of the container element, if applicable.\n      // `null` is a special case for when there is a structural directive on an `ng-template` so\n      // the renderer can differentiate between the synthetic template and the one written in the\n      // file.\n      public tagName: string|null,\n      public attributes: TextAttribute[],\n      public inputs: BoundAttribute[],\n      public outputs: BoundEvent[],\n      public templateAttrs: (BoundAttribute|TextAttribute)[],\n      public children: Node[],\n      public references: Reference[],\n      public variables: Variable[],\n      public sourceSpan: ParseSourceSpan,\n      public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null,\n      public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTemplate(this);\n  }\n}\n\nexport class Content implements Node {\n  readonly name = 'ng-content';\n\n  constructor(\n      public selector: string, public attributes: TextAttribute[],\n      public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitContent(this);\n  }\n}\n\nexport class Variable implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitVariable(this);\n  }\n}\n\nexport class Reference implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitReference(this);\n  }\n}\n\nexport class Icu implements Node {\n  constructor(\n      public vars: {[name: string]: BoundText},\n      public placeholders: {[name: string]: Text|BoundText}, public sourceSpan: ParseSourceSpan,\n      public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitIcu(this);\n  }\n}\n\nexport interface Visitor<Result = any> {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node): Result;\n\n  visitElement(element: Element): Result;\n  visitTemplate(template: Template): Result;\n  visitContent(content: Content): Result;\n  visitVariable(variable: Variable): Result;\n  visitReference(reference: Reference): Result;\n  visitTextAttribute(attribute: TextAttribute): Result;\n  visitBoundAttribute(attribute: BoundAttribute): Result;\n  visitBoundEvent(attribute: BoundEvent): Result;\n  visitText(text: Text): Result;\n  visitBoundText(text: BoundText): Result;\n  visitIcu(icu: Icu): Result;\n}\n\nexport class NullVisitor implements Visitor<void> {\n  visitElement(element: Element): void {}\n  visitTemplate(template: Template): void {}\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\nexport class RecursiveVisitor implements Visitor<void> {\n  visitElement(element: Element): void {\n    visitAll(this, element.attributes);\n    visitAll(this, element.inputs);\n    visitAll(this, element.outputs);\n    visitAll(this, element.children);\n    visitAll(this, element.references);\n  }\n  visitTemplate(template: Template): void {\n    visitAll(this, template.attributes);\n    visitAll(this, template.inputs);\n    visitAll(this, template.outputs);\n    visitAll(this, template.children);\n    visitAll(this, template.references);\n    visitAll(this, template.variables);\n  }\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\nexport class TransformVisitor implements Visitor<Node> {\n  visitElement(element: Element): Node {\n    const newAttributes = transformAll(this, element.attributes);\n    const newInputs = transformAll(this, element.inputs);\n    const newOutputs = transformAll(this, element.outputs);\n    const newChildren = transformAll(this, element.children);\n    const newReferences = transformAll(this, element.references);\n    if (newAttributes != element.attributes || newInputs != element.inputs ||\n        newOutputs != element.outputs || newChildren != element.children ||\n        newReferences != element.references) {\n      return new Element(\n          element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences,\n          element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    }\n    return element;\n  }\n\n  visitTemplate(template: Template): Node {\n    const newAttributes = transformAll(this, template.attributes);\n    const newInputs = transformAll(this, template.inputs);\n    const newOutputs = transformAll(this, template.outputs);\n    const newTemplateAttrs = transformAll(this, template.templateAttrs);\n    const newChildren = transformAll(this, template.children);\n    const newReferences = transformAll(this, template.references);\n    const newVariables = transformAll(this, template.variables);\n    if (newAttributes != template.attributes || newInputs != template.inputs ||\n        newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs ||\n        newChildren != template.children || newReferences != template.references ||\n        newVariables != template.variables) {\n      return new Template(\n          template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren,\n          newReferences, newVariables, template.sourceSpan, template.startSourceSpan,\n          template.endSourceSpan);\n    }\n    return template;\n  }\n\n  visitContent(content: Content): Node {\n    return content;\n  }\n\n  visitVariable(variable: Variable): Node {\n    return variable;\n  }\n  visitReference(reference: Reference): Node {\n    return reference;\n  }\n  visitTextAttribute(attribute: TextAttribute): Node {\n    return attribute;\n  }\n  visitBoundAttribute(attribute: BoundAttribute): Node {\n    return attribute;\n  }\n  visitBoundEvent(attribute: BoundEvent): Node {\n    return attribute;\n  }\n  visitText(text: Text): Node {\n    return text;\n  }\n  visitBoundText(text: BoundText): Node {\n    return text;\n  }\n  visitIcu(icu: Icu): Node {\n    return icu;\n  }\n}\n\nexport function visitAll<Result>(visitor: Visitor<Result>, nodes: Node[]): Result[] {\n  const result: Result[] = [];\n  if (visitor.visit) {\n    for (const node of nodes) {\n      const newNode = visitor.visit(node) || node.visit(visitor);\n    }\n  } else {\n    for (const node of nodes) {\n      const newNode = node.visit(visitor);\n      if (newNode) {\n        result.push(newNode);\n      }\n    }\n  }\n  return result;\n}\n\nexport function transformAll<Result extends Node>(\n    visitor: Visitor<Node>, nodes: Result[]): Result[] {\n  const result: Result[] = [];\n  let changed = false;\n  for (const node of nodes) {\n    const newNode = node.visit(visitor);\n    if (newNode) {\n      result.push(newNode as Result);\n    }\n    changed = changed || newNode != node;\n  }\n  return changed ? result : nodes;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\n/**\n * Describes the text contents of a placeholder as it appears in an ICU expression, including its\n * source span information.\n */\nexport interface MessagePlaceholder {\n  /** The text contents of the placeholder */\n  text: string;\n\n  /** The source span of the placeholder */\n  sourceSpan: ParseSourceSpan;\n}\n\nexport class Message {\n  sources: MessageSpan[];\n  id: string = this.customId;\n  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n  legacyIds: string[] = [];\n\n  messageString = serializeMessage(this.nodes);\n\n  /**\n   * @param nodes message AST\n   * @param placeholders maps placeholder names to static content and their source spans\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param customId\n   */\n  constructor(\n      public nodes: Node[], public placeholders: {[phName: string]: MessagePlaceholder},\n      public placeholderToMessage: {[phName: string]: Message}, public meaning: string,\n      public description: string, public customId: string) {\n    if (nodes.length) {\n      this.sources = [{\n        filePath: nodes[0].sourceSpan.start.file.url,\n        startLine: nodes[0].sourceSpan.start.line + 1,\n        startCol: nodes[0].sourceSpan.start.col + 1,\n        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n        endCol: nodes[0].sourceSpan.start.col + 1\n      }];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(public children: Node[], public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitContainer(this, context);\n  }\n}\n\nexport class Icu implements Node {\n  // TODO(issue/24571): remove '!'.\n  public expressionPlaceholder!: string;\n  constructor(\n      public expression: string, public type: string, public cases: {[k: string]: Node},\n      public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcu(this, context);\n  }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n      public tag: string, public attrs: {[k: string]: string}, public startName: string,\n      public closeName: string, public children: Node[], public isVoid: boolean,\n      // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan|null,\n      public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\n\nexport class Placeholder implements Node {\n  constructor(public value: string, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\n\nexport class IcuPlaceholder implements Node {\n  /** Used to capture a message computed from a previous processing pass (see `setI18nRefs()`). */\n  previousMessage?: Message;\n  constructor(public value: Icu, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\n\n/**\n * Each HTML node that is affect by an i18n tag will also have an `i18n` property that is of type\n * `I18nMeta`.\n * This information is either a `Message`, which indicates it is the root of an i18n message, or a\n * `Node`, which indicates is it part of a containing `Message`.\n */\nexport type I18nMeta = Message|Node;\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text {\n    return new Text(text.value, text.sourceSpan);\n  }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n    msg.expressionPlaceholder = icu.expressionPlaceholder;\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(\n        ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan,\n        ph.startSourceSpan, ph.endSourceSpan);\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach(child => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n}\n\n\n/**\n * Serialize the message to the Localize backtick string format that would appear in compiled code.\n */\nfunction serializeMessage(messageNodes: Node[]): string {\n  const visitor = new LocalizeMessageStringVisitor();\n  const str = messageNodes.map(n => n.visit(visitor)).join('');\n  return str;\n}\n\nclass LocalizeMessageStringVisitor implements Visitor {\n  visitText(text: Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: Container): any {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: Icu): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder): any {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n\n  visitPlaceholder(ph: Placeholder): any {\n    return `{$${ph.name}}`;\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder): any {\n    return `{$${ph.name}}`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from '../i18n_ast';\n\nexport abstract class Serializer {\n  // - The `placeholders` and `placeholderToMessage` properties are irrelevant in the input messages\n  // - The `id` contains the message id that the serializer is expected to use\n  // - Placeholder names are already map to public names using the provided mapper\n  abstract write(messages: i18n.Message[], locale: string|null): string;\n\n  abstract load(content: string, url: string):\n      {locale: string|null, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}};\n\n  abstract digest(message: i18n.Message): string;\n\n  // Creates a name mapper, see `PlaceholderMapper`\n  // Returning `null` means that no name mapping is used.\n  createNameMapper(message: i18n.Message): PlaceholderMapper|null {\n    return null;\n  }\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string|null;\n\n  toInternalName(publicName: string): string|null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(message: i18n.Message, private mapName: (name: string) => string) {\n    super();\n    message.nodes.forEach(node => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string|null {\n    return this.internalToPublic.hasOwnProperty(internalName) ?\n        this.internalToPublic[internalName] :\n        null;\n  }\n\n  toInternalName(publicName: string): string|null {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n                                                              null;\n  }\n\n  override visitText(text: i18n.Text, context?: any): any {\n    return null;\n  }\n\n  override visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  override visitPlaceholder(ph: i18n.Placeholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  override visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface IVisitor {\n  visitTag(tag: Tag): any;\n  visitText(text: Text): any;\n  visitDeclaration(decl: Declaration): any;\n  visitDoctype(doctype: Doctype): any;\n}\n\nclass _Visitor implements IVisitor {\n  visitTag(tag: Tag): string {\n    const strAttrs = this._serializeAttributes(tag.attrs);\n\n    if (tag.children.length == 0) {\n      return `<${tag.name}${strAttrs}/>`;\n    }\n\n    const strChildren = tag.children.map(node => node.visit(this));\n    return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n  }\n\n  visitText(text: Text): string {\n    return text.value;\n  }\n\n  visitDeclaration(decl: Declaration): string {\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n  }\n\n  private _serializeAttributes(attrs: {[k: string]: string}) {\n    const strAttrs = Object.keys(attrs).map((name: string) => `${name}=\"${attrs[name]}\"`).join(' ');\n    return strAttrs.length > 0 ? ' ' + strAttrs : '';\n  }\n\n  visitDoctype(doctype: Doctype): any {\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n  }\n}\n\nconst _visitor = new _Visitor();\n\nexport function serialize(nodes: Node[]): string {\n  return nodes.map((node: Node): string => node.visit(_visitor)).join('');\n}\n\nexport interface Node {\n  visit(visitor: IVisitor): any;\n}\n\nexport class Declaration implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(unescapedAttrs: {[k: string]: string}) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDeclaration(this);\n  }\n}\n\nexport class Doctype implements Node {\n  constructor(public rootTag: string, public dtd: string) {}\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDoctype(this);\n  }\n}\n\nexport class Tag implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(\n      public name: string, unescapedAttrs: {[k: string]: string} = {},\n      public children: Node[] = []) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitTag(this);\n  }\n}\n\nexport class Text implements Node {\n  value: string;\n  constructor(unescapedValue: string) {\n    this.value = escapeXml(unescapedValue);\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitText(this);\n  }\n}\n\nexport class CR extends Text {\n  constructor(ws: number = 0) {\n    super(`\\n${new Array(ws + 1).join(' ')}`);\n  }\n}\n\nconst _ESCAPED_CHARS: [RegExp, string][] = [\n  [/&/g, '&amp;'],\n  [/\"/g, '&quot;'],\n  [/'/g, '&apos;'],\n  [/</g, '&lt;'],\n  [/>/g, '&gt;'],\n];\n\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nexport function escapeXml(text: string): string {\n  return _ESCAPED_CHARS.reduce(\n      (text: string, entry: [RegExp, string]) => text.replace(entry[0], entry[1]), text);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {decimalDigest} from '../digest';\nimport * as i18n from '../i18n_ast';\n\nimport {PlaceholderMapper, Serializer, SimplePlaceholderMapper} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG = 'source';\n\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\nexport class Xmb extends Serializer {\n  override write(messages: i18n.Message[], locale: string|null): string {\n    const exampleVisitor = new ExampleVisitor();\n    const visitor = new _Visitor();\n    let rootNode = new xml.Tag(_MESSAGES_TAG);\n\n    messages.forEach(message => {\n      const attrs: {[k: string]: string} = {id: message.id};\n\n      if (message.description) {\n        attrs['desc'] = message.description;\n      }\n\n      if (message.meaning) {\n        attrs['meaning'] = message.meaning;\n      }\n\n      let sourceTags: xml.Tag[] = [];\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        sourceTags.push(new xml.Tag(\n            _SOURCE_TAG, {},\n            [new xml.Text(`${source.filePath}:${source.startLine}${\n                source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n\n      rootNode.children.push(\n          new xml.CR(2),\n          new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n    });\n\n    rootNode.children.push(new xml.CR());\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}),\n      new xml.CR(),\n      new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n      new xml.CR(),\n      exampleVisitor.addDefaultExamples(rootNode),\n      new xml.CR(),\n    ]);\n  }\n\n  override load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    throw new Error('Unsupported');\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n\n\n  override createNameMapper(message: i18n.Message): PlaceholderMapper {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\n\nclass _Visitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const startTagAsText = new xml.Text(`<${ph.tag}>`);\n    const startEx = new xml.Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const startTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx, startTagAsText]);\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [startTagPh];\n    }\n\n    const closeTagAsText = new xml.Text(`</${ph.tag}>`);\n    const closeEx = new xml.Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const closeTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx, closeTagAsText]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const interpolationAsText = new xml.Text(`{{${ph.value}}}`);\n    // Example tag needs to be not-empty for TC.\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, interpolationAsText])\n    ];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const icuExpression = ph.value.expression;\n    const icuType = ph.value.type;\n    const icuCases = Object.keys(ph.value.cases).map((value: string) => value + ' {...}').join(' ');\n    const icuAsText = new xml.Text(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, icuAsText])\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nexport function digest(message: i18n.Message): string {\n  return decimalDigest(message);\n}\n\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor implements xml.IVisitor {\n  addDefaultExamples(node: xml.Node): xml.Node {\n    node.visit(this);\n    return node;\n  }\n\n  visitTag(tag: xml.Tag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new xml.Text(tag.attrs['name'] || '...');\n        tag.children = [new xml.Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n\n  visitText(text: xml.Text): void {}\n  visitDeclaration(decl: xml.Declaration): void {}\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {toPublicName} from '../../../i18n/serializers/xmb';\nimport * as html from '../../../ml_parser/ast';\nimport * as o from '../../../output/output_ast';\nimport * as t from '../../r3_ast';\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nexport const TRANSLATION_VAR_PREFIX = 'i18n_';\n\n/** Name of the i18n attributes **/\nexport const I18N_ATTR = 'i18n';\nexport const I18N_ATTR_PREFIX = 'i18n-';\n\n/** Prefix of var expressions used in ICUs */\nexport const I18N_ICU_VAR_PREFIX = 'VAR_';\n\n/** Prefix of ICU expressions for post processing */\nexport const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n\n/** Placeholder wrapper for i18n expressions **/\nexport const I18N_PLACEHOLDER_SYMBOL = '�';\n\nexport function isI18nAttribute(name: string): boolean {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nexport function isI18nRootNode(meta?: i18n.I18nMeta): meta is i18n.Message {\n  return meta instanceof i18n.Message;\n}\n\nexport function isSingleI18nIcu(meta?: i18n.I18nMeta): boolean {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n}\n\nexport function hasI18nMeta(node: t.Node&{i18n?: i18n.I18nMeta}): boolean {\n  return !!node.i18n;\n}\n\nexport function hasI18nAttrs(element: html.Element): boolean {\n  return element.attrs.some((attr: html.Attribute) => isI18nAttribute(attr.name));\n}\n\nexport function icuFromI18nMessage(message: i18n.Message) {\n  return message.nodes[0] as i18n.IcuPlaceholder;\n}\n\nexport function wrapI18nPlaceholder(content: string|number, contextId: number = 0): string {\n  const blockId = contextId > 0 ? `:${contextId}` : '';\n  return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\n}\n\nexport function assembleI18nBoundString(\n    strings: string[], bindingStartIndex: number = 0, contextId: number = 0): string {\n  if (!strings.length) return '';\n  let acc = '';\n  const lastIdx = strings.length - 1;\n  for (let i = 0; i < lastIdx; i++) {\n    acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\n  }\n  acc += strings[lastIdx];\n  return acc;\n}\n\nexport function getSeqNumberGenerator(startsAt: number = 0): () => number {\n  let current = startsAt;\n  return () => current++;\n}\n\nexport function placeholdersToParams(placeholders: Map<string, string[]>):\n    {[name: string]: o.LiteralExpr} {\n  const params: {[name: string]: o.LiteralExpr} = {};\n  placeholders.forEach((values: string[], key: string) => {\n    params[key] = o.literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n  });\n  return params;\n}\n\nexport function updatePlaceholderMap(map: Map<string, any[]>, name: string, ...values: any[]) {\n  const current = map.get(name) || [];\n  current.push(...values);\n  map.set(name, current);\n}\n\nexport function assembleBoundTextPlaceholders(\n    meta: i18n.I18nMeta, bindingStartIndex: number = 0, contextId: number = 0): Map<string, any[]> {\n  const startIdx = bindingStartIndex;\n  const placeholders = new Map<string, any>();\n  const node =\n      meta instanceof i18n.Message ? meta.nodes.find(node => node instanceof i18n.Container) : meta;\n  if (node) {\n    (node as i18n.Container)\n        .children\n        .filter((child: i18n.Node): child is i18n.Placeholder => child instanceof i18n.Placeholder)\n        .forEach((child: i18n.Placeholder, idx: number) => {\n          const content = wrapI18nPlaceholder(startIdx + idx, contextId);\n          updatePlaceholderMap(placeholders, child.name, content);\n        });\n  }\n  return placeholders;\n}\n\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nexport function i18nFormatPlaceholderNames(\n    params: {[name: string]: o.Expression} = {}, useCamelCase: boolean) {\n  const _params: {[key: string]: o.Expression} = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(\n        key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n  }\n  return _params;\n}\n\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nexport function formatI18nPlaceholderName(name: string, useCamelCase: boolean = true): string {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    // if no \"_\" found - just lowercase the value\n    return name.toLowerCase();\n  }\n  let postfix;\n  // eject last element if it's a number\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift()!.toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\n\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nexport function getTranslationConstPrefix(extra: string): string {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nexport function declareI18nVariable(variable: o.ReadVarExpr): o.Statement {\n  return new o.DeclareVarStmt(\n      variable.name!, undefined, o.INFERRED_TYPE, undefined, variable.sourceSpan);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '../../constant_pool';\nimport {Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport {splitAtColon} from '../../util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {ForwardRefHandling} from '../util';\n\nimport {R3QueryMetadata} from './api';\nimport {isI18nAttribute} from './i18n/util';\n\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n\n/** Name of the temporary to use during data binding */\nexport const TEMPORARY_NAME = '_t';\n\n/** Name of the context parameter passed into a template function */\nexport const CONTEXT_NAME = 'ctx';\n\n/** Name of the RenderFlag passed into a template function */\nexport const RENDER_FLAGS = 'rf';\n\n/** The prefix reference variables */\nexport const REFERENCE_PREFIX = '_r';\n\n/** The name of the implicit context reference */\nexport const IMPLICIT_REFERENCE = '$implicit';\n\n/** Non bindable attribute name **/\nexport const NON_BINDABLE_ATTR = 'ngNonBindable';\n\n/** Name for the variable keeping track of the context returned by `ɵɵrestoreView`. */\nexport const RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';\n\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nexport function temporaryAllocator(statements: o.Statement[], name: string): () => o.ReadVarExpr {\n  let temp: o.ReadVarExpr|null = null;\n  return () => {\n    if (!temp) {\n      statements.push(new o.DeclareVarStmt(TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n      temp = o.variable(name);\n    }\n    return temp;\n  };\n}\n\n\nexport function invalid<T>(this: t.Visitor, arg: o.Expression|o.Statement|t.Node): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nexport function asLiteral(value: any): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(asLiteral));\n  }\n  return o.literal(value, o.INFERRED_TYPE);\n}\n\nexport function conditionallyCreateMapObjectLiteral(\n    keys: {[key: string]: string|string[]}, keepDeclared?: boolean): o.Expression|null {\n  if (Object.getOwnPropertyNames(keys).length > 0) {\n    return mapToExpression(keys, keepDeclared);\n  }\n  return null;\n}\n\nfunction mapToExpression(\n    map: {[key: string]: string|string[]}, keepDeclared?: boolean): o.Expression {\n  return o.literalMap(Object.getOwnPropertyNames(map).map(key => {\n    // canonical syntax: `dirProp: publicProp`\n    // if there is no `:`, use dirProp = elProp\n    const value = map[key];\n    let declaredName: string;\n    let publicName: string;\n    let minifiedName: string;\n    let needsDeclaredName: boolean;\n    if (Array.isArray(value)) {\n      [publicName, declaredName] = value;\n      minifiedName = key;\n      needsDeclaredName = publicName !== declaredName;\n    } else {\n      [declaredName, publicName] = splitAtColon(key, [key, value]);\n      minifiedName = declaredName;\n      // Only include the declared name if extracted from the key, i.e. the key contains a colon.\n      // Otherwise the declared name should be omitted even if it is different from the public name,\n      // as it may have already been minified.\n      needsDeclaredName = publicName !== declaredName && key.includes(':');\n    }\n    return {\n      key: minifiedName,\n      // put quotes around keys that contain potentially unsafe characters\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: (keepDeclared && needsDeclaredName) ?\n          o.literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n          asLiteral(publicName)\n    };\n  }));\n}\n\n/**\n *  Remove trailing null nodes as they are implied.\n */\nexport function trimTrailingNulls(parameters: o.Expression[]): o.Expression[] {\n  while (o.isNull(parameters[parameters.length - 1])) {\n    parameters.pop();\n  }\n  return parameters;\n}\n\nexport function getQueryPredicate(\n    query: R3QueryMetadata, constantPool: ConstantPool): o.Expression {\n  if (Array.isArray(query.predicate)) {\n    let predicate: o.Expression[] = [];\n    query.predicate.forEach((selector: string): void => {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      const selectors = selector.split(',').map(token => o.literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(o.literalArr(predicate), true);\n  } else {\n    // The original predicate may have been wrapped in a `forwardRef()` call.\n    switch (query.predicate.forwardRef) {\n      case ForwardRefHandling.None:\n      case ForwardRefHandling.Unwrapped:\n        return query.predicate.expression;\n      case ForwardRefHandling.Wrapped:\n        return o.importExpr(R3.resolveForwardRef).callFn([query.predicate.expression]);\n    }\n  }\n}\n\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nexport class DefinitionMap<T = any> {\n  values: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  set(key: keyof T, value: o.Expression|null): void {\n    if (value) {\n      this.values.push({key: key as string, value, quoted: false});\n    }\n  }\n\n  toLiteralMap(): o.LiteralMapExpr {\n    return o.literalMap(this.values);\n  }\n}\n\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nexport function getAttrsForDirectiveMatching(elOrTpl: t.Element|\n                                             t.Template): {[name: string]: string} {\n  const attributesMap: {[name: string]: string} = {};\n\n\n  if (elOrTpl instanceof t.Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n  } else {\n    elOrTpl.attributes.forEach(a => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n\n    elOrTpl.inputs.forEach(i => {\n      attributesMap[i.name] = '';\n    });\n    elOrTpl.outputs.forEach(o => {\n      attributesMap[o.name] = '';\n    });\n  }\n\n  return attributesMap;\n}\n\n/** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\nexport function chainedInstruction(\n    reference: o.ExternalReference, calls: o.Expression[][], span?: ParseSourceSpan|null) {\n  let expression = o.importExpr(reference, null, span) as o.Expression;\n\n  if (calls.length > 0) {\n    for (let i = 0; i < calls.length; i++) {\n      expression = expression.callFn(calls[i], span);\n    }\n  } else {\n    // Add a blank invocation, in case the `calls` array is empty.\n    expression = expression.callFn([], span);\n  }\n\n  return expression;\n}\n\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nexport function getInterpolationArgsLength(interpolation: Interpolation) {\n  const {expressions, strings} = interpolation;\n  if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n    // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n    // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n    // `textInterpolate`.\n    return 1;\n  } else {\n    return expressions.length + strings.length;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {compileFactoryFunction, FactoryTarget, R3DependencyMetadata, R3FactoryDelegateType, R3FactoryMetadata} from './render3/r3_factory';\nimport {Identifiers} from './render3/r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, ForwardRefHandling, generateForwardRef, MaybeForwardRefExpression, R3CompiledExpression, R3Reference, typeWithParameters} from './render3/util';\nimport {DefinitionMap} from './render3/view/util';\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: R3Reference;\n  internalType: o.Expression;\n  typeArgumentCount: number;\n  providedIn: MaybeForwardRefExpression;\n  useClass?: MaybeForwardRefExpression;\n  useFactory?: o.Expression;\n  useExisting?: MaybeForwardRefExpression;\n  useValue?: MaybeForwardRefExpression;\n  deps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(\n    meta: R3InjectableMetadata, resolveForwardRefs: boolean): R3CompiledExpression {\n  let result: {expression: o.Expression, statements: o.Statement[]}|null = null;\n\n  const factoryMeta: R3FactoryMetadata = {\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    target: FactoryTarget.Injectable,\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself and no\n    // deps are specified, in which case 'useClass' is effectively ignored.\n\n    const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);\n    let deps: R3DependencyMetadata[]|undefined = undefined;\n    if (meta.deps !== undefined) {\n      deps = meta.deps;\n    }\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass.expression,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class,\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = {\n        statements: [],\n        expression: delegateToFactory(\n            meta.type.value as o.WrappedNodeExpr<any>,\n            meta.useClass.expression as o.WrappedNodeExpr<any>, resolveForwardRefs)\n      };\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.deps || [],\n        delegateType: R3FactoryDelegateType.Function,\n      });\n    } else {\n      result = {\n        statements: [],\n        expression: o.fn([], [new o.ReturnStatement(meta.useFactory.callFn([]))])\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue.expression,\n    });\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: o.importExpr(Identifiers.inject).callFn([meta.useExisting.expression]),\n    });\n  } else {\n    result = {\n      statements: [],\n      expression: delegateToFactory(\n          meta.type.value as o.WrappedNodeExpr<any>, meta.internalType as o.WrappedNodeExpr<any>,\n          resolveForwardRefs)\n    };\n  }\n\n  const token = meta.internalType;\n\n  const injectableProps =\n      new DefinitionMap<{token: o.Expression, factory: o.Expression, providedIn: o.Expression}>();\n  injectableProps.set('token', token);\n  injectableProps.set('factory', result.expression);\n\n  // Only generate providedIn property if it has a non-null value\n  if ((meta.providedIn.expression as o.LiteralExpr).value !== null) {\n    injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n  }\n\n  const expression = o.importExpr(Identifiers.ɵɵdefineInjectable)\n                         .callFn([injectableProps.toLiteralMap()], undefined, true);\n  return {\n    expression,\n    type: createInjectableType(meta),\n    statements: result.statements,\n  };\n}\n\nexport function createInjectableType(meta: R3InjectableMetadata) {\n  return new o.ExpressionType(o.importExpr(\n      Identifiers.InjectableDeclaration,\n      [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\n\nfunction delegateToFactory(\n    type: o.WrappedNodeExpr<any>, internalType: o.WrappedNodeExpr<any>,\n    unwrapForwardRefs: boolean): o.Expression {\n  if (type.node === internalType.node) {\n    // The types are the same, so we can simply delegate directly to the type's factory.\n    // ```\n    // factory: type.ɵfac\n    // ```\n    return internalType.prop('ɵfac');\n  }\n\n  if (!unwrapForwardRefs) {\n    // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\n    // accepts a sub-type as an argument.\n    // ```\n    // factory: function(t) { return internalType.ɵfac(t); }\n    // ```\n    return createFactoryFunction(internalType);\n  }\n\n  // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before\n  // calling its factory.\n  // ```\n  // factory: function(t) { return core.resolveForwardRef(type).ɵfac(t); }\n  // ```\n  const unwrappedType = o.importExpr(Identifiers.resolveForwardRef).callFn([internalType]);\n  return createFactoryFunction(unwrappedType);\n}\n\nfunction createFactoryFunction(type: o.Expression): o.FunctionExpr {\n  return o.fn(\n      [new o.FnParam('t', o.DYNAMIC_TYPE)],\n      [new o.ReturnStatement(type.prop('ɵfac').callFn([o.variable('t')]))]);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\n  /^\\s*$/,        // empty\n  /[<>]/,         // html tag\n  /^[{}]$/,       // i18n expansion\n  /&(#|[a-z])/i,  // character reference,\n  /^\\/\\//,        // comment\n];\n\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n  } else if (value != null) {\n    const start = value[0] as string;\n    const end = value[1] as string;\n    // Check for unusable interpolation symbols\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n      }\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInterpolationSymbols} from '../assertions';\n\nexport class InterpolationConfig {\n  static fromArray(markers: [string, string]|null): InterpolationConfig {\n    if (!markers) {\n      return DEFAULT_INTERPOLATION_CONFIG;\n    }\n\n    assertInterpolationSymbols('interpolation', markers);\n    return new InterpolationConfig(markers[0], markers[1]);\n  }\n\n  constructor(public start: string, public end: string) {}\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig =\n    new InterpolationConfig('{{', '}}');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $BSPACE = 8;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $7 = 55;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $b = 98;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n\nexport function isNewLine(code: number): boolean {\n  return code === $LF || code === $CR;\n}\n\nexport function isOctalDigit(code: number): boolean {\n  return $0 <= code && code <= $7;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === $SQ || code === $DQ || code === $BT;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from './chars';\nimport {stringify} from './util';\n\nexport class ParseLocation {\n  constructor(\n      public file: ParseSourceFile, public offset: number, public line: number,\n      public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n\n  moveBy(delta: number): ParseLocation {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == chars.$LF) {\n        line--;\n        const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == chars.$LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string, after: string}|null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1),\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url: string) {}\n}\n\nexport class ParseSourceSpan {\n  /**\n   * Create an object that holds information about spans of tokens/nodes captured during\n   * lexing/parsing of text.\n   *\n   * @param start\n   * The location of the start of the span (having skipped leading trivia).\n   * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n   * elements will appear to begin at the start of the opening tag, rather than at the start of any\n   * leading trivia, which could include newlines.\n   *\n   * @param end\n   * The location of the end of the span.\n   *\n   * @param fullStart\n   * The start of the token without skipping the leading trivia.\n   * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n   * from text tokens. Such tooling creates new source-spans relative to the original token's\n   * source-span. If leading trivia characters have been skipped then the new source-spans may be\n   * incorrectly offset.\n   *\n   * @param details\n   * Additional information (such as identifier names) that should be associated with the span.\n   */\n  constructor(\n      public start: ParseLocation, public end: ParseLocation,\n      public fullStart: ParseLocation = start, public details: string|null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR,\n}\n\nexport class ParseError {\n  constructor(\n      public span: ParseSourceSpan, public msg: string,\n      public level: ParseErrorLevel = ParseErrorLevel.ERROR) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n                 this.msg;\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nexport function r3JitTypeSourceSpan(\n    kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n\nlet _anonymousTypeIndex = 0;\n\nexport function identifierName(compileIdentifier: CompileIdentifierMetadata|null|undefined): string|\n    null {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  if (ref['__forward_ref__']) {\n    // We do not want to try to stringify a `forwardRef()` function because that would cause the\n    // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n    return '__forward_ref__';\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    // case: anonymous functions!\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\n\nexport interface CompileIdentifierMetadata {\n  reference: any;\n}\n\nexport function sanitizeIdentifier(name: string): string {\n  return name.replace(/\\W/g, '_');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {AbstractEmitterVisitor, EmitterVisitorContext, escapeIdentifier} from './abstract_emitter';\nimport * as o from './output_ast';\n\n/**\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\n * be available in all environments.\n *\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\n * creates an inline helper with the same functionality.\n *\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\n * array.\n */\nconst makeTemplateObjectPolyfill =\n    '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\n\nexport abstract class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n  constructor() {\n    super(false);\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `var ${stmt.name}`);\n    if (stmt.value) {\n      ctx.print(stmt, ' = ');\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  override visitTaggedTemplateExpr(ast: o.TaggedTemplateExpr, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // tag`...`\n    // ```\n    // which is effectively like:\n    // ```\n    // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    const elements = ast.template.elements;\n    ast.tag.visitExpression(this, ctx);\n    ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n    ast.template.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  override visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n    this._visitParams(ast.params, ctx);\n    ctx.println(ast, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n    return null;\n  }\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  override visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // $localize `...`\n    // ```\n    // which is effectively like:\n    // ```\n    // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n    const parts = [ast.serializeI18nHead()];\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      parts.push(ast.serializeI18nTemplatePart(i));\n    }\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n    ast.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n\n  private _visitParams(params: o.FnParam[], ctx: EmitterVisitorContext): void {\n    this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy within the JIT\n * compiler. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../util';\n\n/**\n * While Angular only uses Trusted Types internally for the time being,\n * references to Trusted Types could leak into our core.d.ts, which would force\n * anyone compiling against @angular/core to provide the @types/trusted-types\n * package in their compilation unit.\n *\n * Until https://github.com/microsoft/TypeScript/issues/30024 is resolved, we\n * will keep Angular's public API surface free of references to Trusted Types.\n * For internal and semi-private APIs that need to reference Trusted Types, the\n * minimal type definitions for the Trusted Types API provided by this module\n * should be used instead. They are marked as \"declare\" to prevent them from\n * being renamed by compiler optimization.\n *\n * Adapted from\n * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/trusted-types/index.d.ts\n * but restricted to the API surface used within Angular.\n */\n\nexport declare interface TrustedScript {\n  __brand__: 'TrustedScript';\n}\n\nexport declare interface TrustedTypePolicyFactory {\n  createPolicy(policyName: string, policyOptions: {\n    createScript?: (input: string) => string,\n  }): TrustedTypePolicy;\n}\n\nexport declare interface TrustedTypePolicy {\n  createScript(input: string): TrustedScript;\n}\n\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy|null|undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy|null {\n  if (policy === undefined) {\n    policy = null;\n    if (global.trustedTypes) {\n      try {\n        policy =\n            (global.trustedTypes as TrustedTypePolicyFactory).createPolicy('angular#unsafe-jit', {\n              createScript: (s: string) => s,\n            });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script: string): TrustedScript|string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nexport function newTrustedFunctionForJIT(...args: string[]): Function {\n  if (!global.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(global);\n\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {identifierName} from '../parse_util';\n\nimport {EmitterVisitorContext} from './abstract_emitter';\nimport {AbstractJsEmitterVisitor} from './abstract_js_emitter';\nimport * as o from './output_ast';\nimport {newTrustedFunctionForJIT} from './output_jit_trusted_types';\n\nexport interface ExternalReferenceResolver {\n  resolveExternalReference(ref: o.ExternalReference): unknown;\n}\n\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nexport class JitEvaluator {\n  /**\n   *\n   * @param sourceUrl The URL of the generated code.\n   * @param statements An array of Angular statement AST nodes to be evaluated.\n   * @param refResolver Resolves `o.ExternalReference`s into values.\n   * @param createSourceMaps If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns A map of all the variables in the generated code.\n   */\n  evaluateStatements(\n      sourceUrl: string, statements: o.Statement[], refResolver: ExternalReferenceResolver,\n      createSourceMaps: boolean): {[key: string]: any} {\n    const converter = new JitEmitterVisitor(refResolver);\n    const ctx = EmitterVisitorContext.createRoot();\n    // Ensure generated code is in strict mode\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [\n        o.literal('use strict').toStmt(),\n        ...statements,\n      ];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n\n  /**\n   * Evaluate a piece of JIT generated code.\n   * @param sourceUrl The URL of this generated code.\n   * @param ctx A context object that contains an AST of the code to be evaluated.\n   * @param vars A map containing the names and values of variables that the evaluated code might\n   * reference.\n   * @param createSourceMap If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns The result of evaluating the code.\n   */\n  evaluateCode(\n      sourceUrl: string, ctx: EmitterVisitorContext, vars: {[key: string]: any},\n      createSourceMap: boolean): any {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames: string[] = [];\n    const fnArgValues: any[] = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n      // E.g. ```\n      // function anonymous(a,b,c\n      // /**/) { ... }```\n      // We don't want to hard code this fact, so we auto detect it via an empty function first.\n      const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n\n  /**\n   * Execute a JIT generated function by calling it.\n   *\n   * This method can be overridden in tests to capture the functions that are generated\n   * by this `JitEvaluator` class.\n   *\n   * @param fn A function to execute.\n   * @param args The arguments to pass to the function being executed.\n   * @returns The return value of the executed function.\n   */\n  executeFunction(fn: Function, args: any[]) {\n    return fn(...args);\n  }\n}\n\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nexport class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  private _evalArgNames: string[] = [];\n  private _evalArgValues: any[] = [];\n  private _evalExportedVars: string[] = [];\n\n  constructor(private refResolver: ExternalReferenceResolver) {\n    super();\n  }\n\n  createReturnStmt(ctx: EmitterVisitorContext) {\n    const stmt = new o.ReturnStatement(new o.LiteralMapExpr(this._evalExportedVars.map(\n        resultVar => new o.LiteralMapEntry(resultVar, o.variable(resultVar), false))));\n    stmt.visitStatement(this, ctx);\n  }\n\n  getArgs(): {[key: string]: any} {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n\n  override visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n\n  private _emitReferenceToExternal(ast: o.Expression, value: any, ctx: EmitterVisitorContext):\n      void {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({reference: value}) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\n\n\nfunction isUseStrictStatement(statement: o.Statement): boolean {\n  return statement.isEquivalent(o.literal('use strict').toStmt());\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference} from './util';\nimport {DefinitionMap} from './view/util';\n\nexport interface R3InjectorMetadata {\n  name: string;\n  type: R3Reference;\n  internalType: o.Expression;\n  providers: o.Expression|null;\n  imports: o.Expression[];\n}\n\nexport function compileInjector(meta: R3InjectorMetadata): R3CompiledExpression {\n  const definitionMap = new DefinitionMap<{providers: o.Expression; imports: o.Expression;}>();\n\n  if (meta.providers !== null) {\n    definitionMap.set('providers', meta.providers);\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', o.literalArr(meta.imports));\n  }\n\n  const expression =\n      o.importExpr(R3.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createInjectorType(meta);\n  return {expression, type, statements: []};\n}\n\nexport function createInjectorType(meta: R3InjectorMetadata): o.Type {\n  return new o.ExpressionType(\n      o.importExpr(R3.InjectorDeclaration, [new o.ExpressionType(meta.type.type)]));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\nimport {ExternalReferenceResolver} from '../output/output_jit';\n\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nexport class R3JitReflector implements ExternalReferenceResolver {\n  constructor(private context: {[key: string]: unknown}) {}\n\n  resolveExternalReference(ref: o.ExternalReference): unknown {\n    // This reflector only handles @angular/core imports.\n    if (ref.moduleName !== '@angular/core') {\n      throw new Error(`Cannot resolve external reference to ${\n          ref.moduleName}, only references to @angular/core are supported.`);\n    }\n    if (!this.context.hasOwnProperty(ref.name!)) {\n      throw new Error(`No value provided for @angular/core symbol '${ref.name!}'.`);\n    }\n    return this.context[ref.name!];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3DeclareNgModuleFacade} from '../compiler_facade_interface';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {jitOnlyGuardedExpression, R3CompiledExpression, R3Reference, refsToArray} from './util';\nimport {DefinitionMap} from './view/util';\n\n/**\n * Metadata required by the module compiler to generate a module def (`ɵmod`) for a type.\n */\nexport interface R3NgModuleMetadata {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the module type being compiled, intended for use within a class\n   * definition itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /**\n   * An expression intended for use by statements that are adjacent (i.e. tightly coupled) to but\n   * not internal to a class definition.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  adjacentType: o.Expression;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * Whether to emit the selector scope values (declarations, imports, exports) inline into the\n   * module definition, or to generate additional statements which patch them on. Inline emission\n   * does not allow components to be tree-shaken, but is useful for JIT mode.\n   */\n  emitInline: boolean;\n\n  /**\n   * Whether to generate closure wrappers for bootstrap, declarations, imports, and exports.\n   */\n  containsForwardDecls: boolean;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas: R3Reference[]|null;\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id: o.Expression|null;\n}\n\n/**\n * The shape of the object literal that is passed to the `ɵɵdefineNgModule()` call.\n */\ninterface R3NgModuleDefMap {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the bootstrap components\n   * specified by the module.\n   */\n  bootstrap?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the directives and pipes\n   * declared by the module.\n   */\n  declarations?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the imports of the module.\n   */\n  imports?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the exports of the module.\n   */\n  exports?: o.Expression;\n  /**\n   * A literal array expression containing the schemas that declare elements to be allowed in the\n   * NgModule.\n   */\n  schemas?: o.LiteralArrayExpr;\n  /**\n   * An expression evaluating to the unique ID of an NgModule.\n   * */\n  id?: o.Expression;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const {\n    internalType,\n    bootstrap,\n    declarations,\n    imports,\n    exports,\n    schemas,\n    containsForwardDecls,\n    emitInline,\n    id\n  } = meta;\n\n  const statements: o.Statement[] = [];\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', internalType);\n\n  if (bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\n  }\n\n  // If requested to emit scope information inline, pass the `declarations`, `imports` and `exports`\n  // to the `ɵɵdefineNgModule()` call. The JIT compilation uses this.\n  if (emitInline) {\n    if (declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n    }\n\n    if (imports.length > 0) {\n      definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\n    }\n\n    if (exports.length > 0) {\n      definitionMap.set('exports', refsToArray(exports, containsForwardDecls));\n    }\n  }\n\n  // If not emitting inline, the scope information is not passed into `ɵɵdefineNgModule` as it would\n  // prevent tree-shaking of the declarations, imports and exports references.\n  else {\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  }\n\n  if (schemas !== null && schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(schemas.map(ref => ref.value)));\n  }\n\n  if (id !== null) {\n    definitionMap.set('id', id);\n  }\n\n  const expression =\n      o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements};\n}\n\n/**\n * This function is used in JIT mode to generate the call to `ɵɵdefineNgModule()` from a call to\n * `ɵɵngDeclareNgModule()`.\n */\nexport function compileNgModuleDeclarationExpression(meta: R3DeclareNgModuleFacade): o.Expression {\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', new o.WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new o.WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new o.WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new o.WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new o.WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new o.WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new o.WrappedNodeExpr(meta.id));\n  }\n  return o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\n\nexport function createNgModuleType(\n    {type: moduleType, declarations, imports, exports}: R3NgModuleMetadata): o.ExpressionType {\n  return new o.ExpressionType(o.importExpr(R3.NgModuleDeclaration, [\n    new o.ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),\n    tupleTypeOf(exports)\n  ]));\n}\n\n/**\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement|null {\n  const {adjacentType: moduleType, declarations, imports, exports, containsForwardDecls} = meta;\n\n  const scopeMap = new DefinitionMap<\n      {declarations: o.Expression, imports: o.Expression, exports: o.Expression}>();\n\n  if (declarations.length > 0) {\n    scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n  }\n\n  if (imports.length > 0) {\n    scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\n  }\n\n  if (exports.length > 0) {\n    scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\n  }\n\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n\n  // setNgModuleScope(...)\n  const fnCall = new o.InvokeFunctionExpr(\n      /* fn */ o.importExpr(R3.setNgModuleScope),\n      /* args */[moduleType, scopeMap.toLiteralMap()]);\n\n  // (ngJitMode guard) && setNgModuleScope(...)\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n\n  // function() { (ngJitMode guard) && setNgModuleScope(...); }\n  const iife = new o.FunctionExpr(\n      /* params */[],\n      /* statements */[guardedCall.toStmt()]);\n\n  // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n  const iifeCall = new o.InvokeFunctionExpr(\n      /* fn */ iife,\n      /* args */[]);\n\n  return iifeCall.toStmt();\n}\n\nfunction tupleTypeOf(exp: R3Reference[]): o.Type {\n  const types = exp.map(ref => o.typeofExpr(ref.type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../output/output_ast';\n\nimport {R3DependencyMetadata} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\nexport interface R3PipeMetadata {\n  /**\n   * Name of the pipe type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the pipe itself.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the pipe being compiled, intended for use within a class definition\n   * itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside an\n   * IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * Name of the pipe.\n   */\n  pipeName: string;\n\n  /**\n   * Dependencies of the pipe's constructor.\n   */\n  deps: R3DependencyMetadata[]|null;\n\n  /**\n   * Whether the pipe is marked as pure.\n   */\n  pure: boolean;\n}\n\nexport function compilePipeFromMetadata(metadata: R3PipeMetadata): R3CompiledExpression {\n  const definitionMapValues: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  // e.g. `name: 'myPipe'`\n  definitionMapValues.push({key: 'name', value: o.literal(metadata.pipeName), quoted: false});\n\n  // e.g. `type: MyPipe`\n  definitionMapValues.push({key: 'type', value: metadata.type.value, quoted: false});\n\n  // e.g. `pure: true`\n  definitionMapValues.push({key: 'pure', value: o.literal(metadata.pure), quoted: false});\n\n  const expression =\n      o.importExpr(R3.definePipe).callFn([o.literalMap(definitionMapValues)], undefined, true);\n  const type = createPipeType(metadata);\n\n  return {expression, type, statements: []};\n}\n\nexport function createPipeType(metadata: R3PipeMetadata): o.Type {\n  return new o.ExpressionType(o.importExpr(R3.PipeDeclaration, [\n    typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n    new o.ExpressionType(new o.LiteralExpr(metadata.pipeName)),\n  ]));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class ParserError {\n  public message: string;\n  constructor(\n      message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n    this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n  }\n}\n\nexport class ParseSpan {\n  constructor(public start: number, public end: number) {}\n  toAbsolute(absoluteOffset: number): AbsoluteSourceSpan {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\n\nexport abstract class AST {\n  constructor(\n      public span: ParseSpan,\n      /**\n       * Absolute location of the expression AST in a source code file.\n       */\n      public sourceSpan: AbsoluteSourceSpan) {}\n\n  abstract visit(visitor: AstVisitor, context?: any): any;\n\n  toString(): string {\n    return 'AST';\n  }\n}\n\nexport abstract class ASTWithName extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n}\n\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public prefix: string,\n      public uninterpretedExpression: string, public location: any) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitQuote(this, context);\n  }\n  override toString(): string {\n    return 'Quote';\n  }\n}\n\nexport class EmptyExpr extends AST {\n  override visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nexport class ThisReceiver extends ImplicitReceiver {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public condition: AST, public trueExp: AST,\n      public falseExp: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class PropertyWrite extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string, public value: AST) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyWrite(this, context);\n  }\n}\n\nexport class SafePropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class SafeKeyedRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeKeyedRead(this, context);\n  }\n}\n\nexport class KeyedWrite extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST,\n      public value: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedWrite(this, context);\n  }\n}\n\nexport class BindingPipe extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public exp: AST, public name: string,\n      public args: any[], nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public value: any) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport type LiteralMapKey = {\n  key: string; quoted: boolean;\n};\n\nexport class LiteralMap extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public keys: LiteralMapKey[],\n      public values: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public strings: any[],\n      public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operation: string, public left: AST,\n      public right: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n}\n\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nexport class Unary extends Binary {\n  // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n  // depend on these fields when operating on `Unary`.\n  override left: never = null as never;\n  override right: never = null as never;\n  override operation: never = null as never;\n\n  /**\n   * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n   */\n  static createMinus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n  }\n\n  /**\n   * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n   */\n  static createPlus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n  }\n\n  /**\n   * During the deprecation period this constructor is private, to avoid consumers from creating\n   * a `Unary` with the fallback properties for `Binary`.\n   */\n  private constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operator: string, public expr: AST,\n      binaryOp: string, binaryLeft: AST, binaryRight: AST) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n  }\n\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class Call extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public args: AST[],\n      public argumentSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitCall(this, context);\n  }\n}\n\nexport class SafeCall extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public args: AST[],\n      public argumentSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeCall(this, context);\n  }\n}\n\n\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nexport class AbsoluteSourceSpan {\n  constructor(public readonly start: number, public readonly end: number) {}\n}\n\nexport class ASTWithSource extends AST {\n  constructor(\n      public ast: AST, public source: string|null, public location: string, absoluteOffset: number,\n      public errors: ParserError[]) {\n    super(\n        new ParseSpan(0, source === null ? 0 : source.length),\n        new AbsoluteSourceSpan(\n            absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  override toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\n/**\n * TemplateBinding refers to a particular key-value pair in a microsyntax\n * expression. A few examples are:\n *\n *   |---------------------|--------------|---------|--------------|\n *   |     expression      |     key      |  value  | binding type |\n *   |---------------------|--------------|---------|--------------|\n *   | 1. let item         |    item      |  null   |   variable   |\n *   | 2. of items         |   ngForOf    |  items  |  expression  |\n *   | 3. let x = y        |      x       |    y    |   variable   |\n *   | 4. index as i       |      i       |  index  |   variable   |\n *   | 5. trackBy: func    | ngForTrackBy |   func  |  expression  |\n *   | 6. *ngIf=\"cond\"     |     ngIf     |   cond  |  expression  |\n *   |---------------------|--------------|---------|--------------|\n *\n * (6) is a notable exception because it is a binding from the template key in\n * the LHS of a HTML attribute to the expression in the RHS. All other bindings\n * in the example above are derived solely from the RHS.\n */\nexport type TemplateBinding = VariableBinding|ExpressionBinding;\n\nexport class VariableBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key name of the LHS along with its span.\n   * @param value optional value for the RHS along with its span.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier,\n      public readonly value: TemplateBindingIdentifier|null) {}\n}\n\nexport class ExpressionBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n   * span. Note that the length of the span may not be the same as\n   * `key.source.length`. For example,\n   * 1. key.source = ngFor, key.span is for \"ngFor\"\n   * 2. key.source = ngForOf, key.span is for \"of\"\n   * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n   * @param value optional expression for the RHS.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier, public readonly value: ASTWithSource|null) {}\n}\n\nexport interface TemplateBindingIdentifier {\n  source: string;\n  span: AbsoluteSourceSpan;\n}\n\nexport interface AstVisitor {\n  /**\n   * The `visitUnary` method is declared as optional for backwards compatibility. In an upcoming\n   * major release, this method will be made required.\n   */\n  visitUnary?(ast: Unary, context: any): any;\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  /**\n   * The `visitThisReceiver` method is declared as optional for backwards compatibility.\n   * In an upcoming major release, this method will be made required.\n   */\n  visitThisReceiver?(ast: ThisReceiver, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitKeyedWrite(ast: KeyedWrite, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitPropertyWrite(ast: PropertyWrite, context: any): any;\n  visitQuote(ast: Quote, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any;\n  visitCall(ast: Call, context: any): any;\n  visitSafeCall(ast: SafeCall, context: any): any;\n  visitASTWithSource?(ast: ASTWithSource, context: any): any;\n  /**\n   * This function is optionally defined to allow classes that implement this\n   * interface to selectively decide if the specified `ast` should be visited.\n   * @param ast node to visit\n   * @param context context that gets passed to the node and all its children\n   */\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visit(ast: AST, context?: any): any {\n    // The default implementation just visits every node.\n    // Classes that extend RecursiveAstVisitor should override this function\n    // to selectively visit the specified node.\n    ast.visit(this, context);\n  }\n  visitUnary(ast: Unary, context: any): any {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast: Binary, context: any): any {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast: Chain, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast: ThisReceiver, context: any): any {}\n  visitThisReceiver(ast: ThisReceiver, context: any): any {}\n  visitInterpolation(ast: Interpolation, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n    this.visit(ast.value, context);\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {}\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.value, context);\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitCall(ast: Call, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitSafeCall(ast: SafeCall, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitQuote(ast: Quote, context: any): any {}\n  // This is not part of the AstVisitor interface, just a helper method\n  visitAll(asts: AST[], context: any): any {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\n\nexport class AstTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): AST {\n    return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    return new PropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    return new PropertyWrite(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name,\n        ast.value.visit(this));\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    return new SafePropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    switch (ast.operator) {\n      case '+':\n        return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      case '-':\n        return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      default:\n        throw new Error(`Unknown unary operator ${ast.operator}`);\n    }\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    return new Binary(\n        ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    return new Conditional(\n        ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this),\n        ast.falseExp.visit(this));\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    return new BindingPipe(\n        ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args),\n        ast.nameSpan);\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    return new KeyedWrite(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this),\n        ast.value.visit(this));\n  }\n\n  visitCall(ast: Call, context: any): AST {\n    return new Call(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args),\n        ast.argumentSpan);\n  }\n\n  visitSafeCall(ast: SafeCall, context: any): AST {\n    return new SafeCall(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args),\n        ast.argumentSpan);\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    for (let i = 0; i < asts.length; ++i) {\n      res[i] = asts[i].visit(this);\n    }\n    return res;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitQuote(ast: Quote, context: any): AST {\n    return new Quote(\n        ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);\n  }\n\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): AST {\n    return new SafeKeyedRead(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n  }\n}\n\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nexport class AstMemoryEfficientTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): Interpolation {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions)\n      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n    return ast;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return ast;\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const value = ast.value.visit(this);\n    if (receiver !== ast.receiver || value !== ast.value) {\n      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n    }\n    return ast;\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    const values = this.visitAll(ast.values);\n    if (values !== ast.values) {\n      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n    }\n    return ast;\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    const expr = ast.expr.visit(this);\n    if (expr !== ast.expr) {\n      switch (ast.operator) {\n        case '+':\n          return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n        case '-':\n          return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n        default:\n          throw new Error(`Unknown unary operator ${ast.operator}`);\n      }\n    }\n    return ast;\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    const left = ast.left.visit(this);\n    const right = ast.right.visit(this);\n    if (left !== ast.left || right !== ast.right) {\n      return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n    }\n    return ast;\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new PrefixNot(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    const condition = ast.condition.visit(this);\n    const trueExp = ast.trueExp.visit(this);\n    const falseExp = ast.falseExp.visit(this);\n    if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n      return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n    }\n    return ast;\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    const exp = ast.exp.visit(this);\n    const args = this.visitAll(ast.args);\n    if (exp !== ast.exp || args !== ast.args) {\n      return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n    }\n    return ast;\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.receiver || key !== ast.key) {\n      return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    const value = ast.value.visit(this);\n    if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {\n      return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n    }\n    return ast;\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    let modified = false;\n    for (let i = 0; i < asts.length; ++i) {\n      const original = asts[i];\n      const value = original.visit(this);\n      res[i] = value;\n      modified = modified || value !== original;\n    }\n    return modified ? res : asts;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new Chain(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n\n  visitCall(ast: Call, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n    }\n    return ast;\n  }\n\n  visitSafeCall(ast: SafeCall, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new SafeCall(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n    }\n    return ast;\n  }\n\n  visitQuote(ast: Quote, context: any): AST {\n    return ast;\n  }\n\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.receiver || key !== ast.key) {\n      return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n}\n\n// Bindings\n\nexport class ParsedProperty {\n  public readonly isLiteral: boolean;\n  public readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public expression: ASTWithSource, public type: ParsedPropertyType,\n      public sourceSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan,\n      public valueSpan: ParseSourceSpan|undefined) {\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\n\nexport enum ParsedPropertyType {\n  DEFAULT,\n  LITERAL_ATTR,\n  ANIMATION\n}\n\nexport const enum ParsedEventType {\n  // DOM or Directive event\n  Regular,\n  // Animation specific event\n  Animation,\n}\n\nexport class ParsedEvent {\n  // Regular events have a target\n  // Animation events have a phase\n  constructor(\n      public name: string, public targetOrPhase: string, public type: ParsedEventType,\n      public handler: ASTWithSource, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan) {}\n}\n\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nexport class ParsedVariable {\n  constructor(\n      public readonly name: string, public readonly value: string,\n      public readonly sourceSpan: ParseSourceSpan, public readonly keySpan: ParseSourceSpan,\n      public readonly valueSpan?: ParseSourceSpan) {}\n}\n\nexport const enum BindingType {\n  // A regular binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n  Animation,\n}\n\nexport class BoundElementProperty {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: ASTWithSource, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan: ParseSourceSpan|undefined) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport * as o from '../output/output_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class EventHandlerVars {\n  static event = o.variable('$event');\n}\n\nexport interface LocalResolver {\n  getLocal(name: string): o.Expression|null;\n  notifyImplicitReceiverUse(): void;\n  globals?: Set<string>;\n  maybeRestoreView(): void;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string, baseSourceSpan?: ParseSourceSpan, implicitReceiverAccesses?: Set<string>,\n    globals?: Set<string>): o.Statement[] {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver(globals);\n  }\n  const actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false, baseSourceSpan,\n      implicitReceiverAccesses);\n  const actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const lastIndex = actionStmts.length - 1;\n  if (lastIndex >= 0) {\n    const lastStatement = actionStmts[lastIndex];\n    // Ensure that the value of the last expression statement is returned\n    if (lastStatement instanceof o.ExpressionStatement) {\n      actionStmts[lastIndex] = new o.ReturnStatement(lastStatement.expr);\n    }\n  }\n  return actionStmts;\n}\n\nexport interface BuiltinConverter {\n  (args: o.Expression[]): o.Expression;\n}\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\n\nexport class ConvertPropertyBindingResult {\n  constructor(public stmts: o.Statement[], public currValExpr: o.Expression) {}\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false);\n  const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n  const stmts: o.Statement[] = getStatementsFromVisitor(visitor, bindingId);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  return new ConvertPropertyBindingResult(stmts, outputExpr);\n}\n\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nexport function convertUpdateArguments(\n    localResolver: LocalResolver, contextVariableExpression: o.Expression,\n    expressionWithArgumentsToExtract: cdAst.Interpolation, bindingId: string) {\n  const visitor = new _AstToIrVisitor(\n      localResolver, contextVariableExpression, bindingId, /* supportsInterpolation */ true);\n  const outputExpr = visitor.visitInterpolation(expressionWithArgumentsToExtract, _Mode.Expression);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const stmts = getStatementsFromVisitor(visitor, bindingId);\n  const args = outputExpr.args;\n  return {stmts, args};\n}\n\nfunction getStatementsFromVisitor(visitor: _AstToIrVisitor, bindingId: string) {\n  const stmts: o.Statement[] = [];\n  for (let i = 0; i < visitor.temporaryCount; i++) {\n    stmts.push(temporaryDeclaration(bindingId, i));\n  }\n  return stmts;\n}\n\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n\nfunction temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber));\n}\n\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n  constructor(private _converterFactory: BuiltinConverterFactory) {\n    super();\n  }\n  override visitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n  override visitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n  override visitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _nodeMap = new Map<cdAst.AST, cdAst.AST>();\n  private _resultMap = new Map<cdAst.AST, o.Expression>();\n  private _currentTemporary: number = 0;\n  public temporaryCount: number = 0;\n  public usesImplicitReceiver: boolean = false;\n\n  constructor(\n      private _localResolver: LocalResolver, private _implicitReceiver: o.Expression,\n      private bindingId: string, private supportsInterpolation: boolean,\n      private baseSourceSpan?: ParseSourceSpan, private implicitReceiverAccesses?: Set<string>) {}\n\n  visitUnary(ast: cdAst.Unary, mode: _Mode): any {\n    let op: o.UnaryOperator;\n    switch (ast.operator) {\n      case '+':\n        op = o.UnaryOperator.Plus;\n        break;\n      case '-':\n        op = o.UnaryOperator.Minus;\n        break;\n      default:\n        throw new Error(`Unsupported operator ${ast.operator}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.UnaryOperatorExpr(\n            op, this._visit(ast.expr, _Mode.Expression), undefined,\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      case '??':\n        return this.convertNullishCoalesce(ast, mode);\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression),\n            undefined, this.convertSourceSpan(ast.span)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode,\n        value.conditional(\n            this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression),\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    this.usesImplicitReceiver = true;\n    return this._implicitReceiver;\n  }\n\n  visitThisReceiver(ast: cdAst.ThisReceiver, mode: _Mode): any {\n    return this.visitImplicitReceiver(ast, mode);\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): InterpolationExpression {\n    if (!this.supportsInterpolation) {\n      throw new Error('Unexpected interpolation');\n    }\n\n    ensureExpressionMode(mode, ast);\n    let args: o.Expression[] = [];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n    // args returned to just the value, because we're going to pass it to a special instruction.\n    const strings = ast.strings;\n    if (strings.length === 2 && strings[0] === '' && strings[1] === '') {\n      // Single argument interpolate instructions.\n      args = [args[1]];\n    } else if (ast.expressions.length >= 9) {\n      // 9 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n      // an array of arguments\n      args = [o.literalArr(args)];\n    }\n\n    return new InterpolationExpression(args);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode,\n          this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n\n    if (obj === this._implicitReceiver) {\n      this._localResolver.maybeRestoreView();\n    }\n\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(\n        mode, o.literal(ast.value, type, this.convertSourceSpan(ast.span)));\n  }\n\n  private _getLocal(name: string, receiver: cdAst.AST): o.Expression|null {\n    if (this._localResolver.globals?.has(name) && receiver instanceof cdAst.ThisReceiver) {\n      return null;\n    }\n\n    return this._localResolver.getLocal(name);\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name, ast.receiver);\n        if (result) {\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        }\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n    let varExpr: o.ReadPropExpr|null = null;\n    if (receiver === this._implicitReceiver) {\n      const localExpr = this._getLocal(ast.name, ast.receiver);\n      if (localExpr) {\n        if (localExpr instanceof o.ReadPropExpr) {\n          // If the local variable is a property read expression, it's a reference\n          // to a 'context.property' value and will be used as the target of the\n          // write expression.\n          varExpr = localExpr;\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        } else {\n          // Otherwise it's an error.\n          const receiver = ast.name;\n          const value = (ast.value instanceof cdAst.PropertyRead) ? ast.value.name : undefined;\n          throw new Error(`Cannot assign value \"${value}\" to template variable \"${\n              receiver}\". Template variables are read-only.`);\n        }\n      }\n    }\n    // If no local expression could be produced, use the original receiver's\n    // property as the target.\n    if (varExpr === null) {\n      varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n    }\n    return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeKeyedRead(ast: cdAst.SafeKeyedRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any {\n    return asts.map(ast => this._visit(ast, mode));\n  }\n\n  visitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n  }\n\n  visitCall(ast: cdAst.Call, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    }\n\n    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n\n    if (ast instanceof BuiltinFunctionCall) {\n      return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));\n    }\n\n    const receiver = ast.receiver;\n    if (receiver instanceof cdAst.PropertyRead &&\n        receiver.receiver instanceof cdAst.ImplicitReceiver &&\n        !(receiver.receiver instanceof cdAst.ThisReceiver) && receiver.name === '$any') {\n      if (convertedArgs.length !== 1) {\n        throw new Error(`Invalid call to $any, expected 1 argument but received ${\n            convertedArgs.length || 'none'}`);\n      }\n      return convertToStatementIfNeeded(mode, convertedArgs[0] as o.Expression);\n    }\n\n    const call = this._visit(receiver, _Mode.Expression)\n                     .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n    return convertToStatementIfNeeded(mode, call);\n  }\n\n  visitSafeCall(ast: cdAst.SafeCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  private _visit(ast: cdAst.AST, mode: _Mode): any {\n    const result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafePropertyRead|cdAst.SafeKeyedRead|cdAst.SafeCall,\n      mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  .   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let temporary: o.ReadVarExpr|undefined = undefined;\n    if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.Call(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.args,\n              leftMostSafe.argumentSpan));\n    } else if (leftMostSafe instanceof cdAst.SafeKeyedRead) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.KeyedRead(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan,\n              leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.NULL_EXPR, access));\n  }\n\n  private convertNullishCoalesce(ast: cdAst.Binary, mode: _Mode): any {\n    const left: o.Expression = this._visit(ast.left, _Mode.Expression);\n    const right: o.Expression = this._visit(ast.right, _Mode.Expression);\n    const temporary = this.allocateTemporary();\n    this.releaseTemporary(temporary);\n\n    // Generate the following expression. It is identical to how TS\n    // transpiles binary expressions with a nullish coalescing operator.\n    // let temp;\n    // (temp = a) !== null && temp !== undefined ? temp : b;\n    return convertToStatementIfNeeded(\n        mode,\n        temporary.set(left)\n            .notIdentical(o.NULL_EXPR)\n            .and(temporary.notIdentical(o.literal(undefined)))\n            .conditional(temporary, right));\n  }\n\n  // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs to be transformed initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeKeyedRead {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary) {\n        return null;\n      },\n      visitBinary(ast: cdAst.Binary) {\n        return null;\n      },\n      visitChain(ast: cdAst.Chain) {\n        return null;\n      },\n      visitConditional(ast: cdAst.Conditional) {\n        return null;\n      },\n      visitCall(ast: cdAst.Call) {\n        return visit(this, ast.receiver);\n      },\n      visitSafeCall(ast: cdAst.SafeCall) {\n        return visit(this, ast.receiver) || ast;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return null;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return null;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return null;\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return visit(this, ast.receiver);\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return null;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return null;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return null;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return null;\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return null;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return null;\n      },\n      visitNonNullAssert(ast: cdAst.NonNullAssert) {\n        return null;\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return visit(this, ast.receiver);\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return null;\n      },\n      visitQuote(ast: cdAst.Quote) {\n        return null;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      },\n      visitSafeKeyedRead(ast: cdAst.SafeKeyedRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n\n  // Returns true of the AST includes a method or a pipe indicating that, if the\n  // expression is used as the target of a safe property or method access then\n  // the expression should be stored into a temporary variable.\n  private needsTemporaryInSafeAccess(ast: cdAst.AST): boolean {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary): boolean {\n        return visit(this, ast.expr);\n      },\n      visitBinary(ast: cdAst.Binary): boolean {\n        return visit(this, ast.left) || visit(this, ast.right);\n      },\n      visitChain(ast: cdAst.Chain) {\n        return false;\n      },\n      visitConditional(ast: cdAst.Conditional): boolean {\n        return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n      },\n      visitCall(ast: cdAst.Call) {\n        return true;\n      },\n      visitSafeCall(ast: cdAst.SafeCall) {\n        return true;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return false;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return false;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return visitSome(this, ast.expressions);\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return false;\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return false;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return true;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return true;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return false;\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return true;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitNonNullAssert(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return false;\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return false;\n      },\n      visitQuote(ast: cdAst.Quote) {\n        return false;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return false;\n      },\n      visitSafeKeyedRead(ast: cdAst.SafeKeyedRead) {\n        return false;\n      }\n    });\n  }\n\n  private allocateTemporary(): o.ReadVarExpr {\n    const tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n\n  private releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n\n  /**\n   * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n   *\n   * `ParseSpan` objects are relative to the start of the expression.\n   * This method converts these to full `ParseSourceSpan` objects that\n   * show where the span is within the overall source file.\n   *\n   * @param span the relative span to convert.\n   * @returns a `ParseSourceSpan` for the given span or null if no\n   * `baseSourceSpan` was provided to this class.\n   */\n  private convertSourceSpan(span: cdAst.ParseSpan) {\n    if (this.baseSourceSpan) {\n      const start = this.baseSourceSpan.start.moveBy(span.start);\n      const end = this.baseSourceSpan.start.moveBy(span.end);\n      const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n      return new ParseSourceSpan(start, end, fullStart);\n    } else {\n      return null;\n    }\n  }\n\n  /** Adds the name of an AST to the list of implicit receiver accesses. */\n  private addImplicitReceiverAccess(name: string) {\n    if (this.implicitReceiverAccesses) {\n      this.implicitReceiverAccesses.add(name);\n    }\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\nfunction unsupported(): never {\n  throw new Error('Unsupported operation');\n}\n\nclass InterpolationExpression extends o.Expression {\n  constructor(public args: o.Expression[]) {\n    super(null, null);\n  }\n\n  override isConstant = unsupported;\n  override isEquivalent = unsupported;\n  override visitExpression = unsupported;\n}\n\nclass DefaultLocalResolver implements LocalResolver {\n  constructor(public globals?: Set<string>) {}\n  notifyImplicitReceiverUse(): void {}\n  maybeRestoreView(): void {}\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n\nexport class BuiltinFunctionCall extends cdAst.Call {\n  constructor(\n      span: cdAst.ParseSpan, sourceSpan: cdAst.AbsoluteSourceSpan, args: cdAst.AST[],\n      public converter: BuiltinConverter) {\n    super(span, sourceSpan, new cdAst.EmptyExpr(span, sourceSpan), args, null!);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n *\n * Please make sure to keep to edits in sync with the source file.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\n  this feature.\n\n  By default, rules are prefixed with the host element tag name\n  as a descendant selector. This ensures styling does not leak out of the 'top'\n  of the element's ShadowDOM. For example,\n\n  div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n  x-foo div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\n  selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\n\nexport class ShadowCss {\n  strictStyling: boolean = true;\n\n  /*\n   * Shim some cssText with the given selector. Returns cssText that can\n   * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\n   *\n   * When strictStyling is true:\n   * - selector is the attribute added to all elements inside the host,\n   * - hostSelector is the attribute added to the host itself.\n   */\n  shimCssText(cssText: string, selector: string, hostSelector: string = ''): string {\n    const commentsWithHash = extractCommentsWithHash(cssText);\n    cssText = stripComments(cssText);\n    cssText = this._insertDirectives(cssText);\n\n    const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n    return [scopedCssText, ...commentsWithHash].join('\\n');\n  }\n\n  private _insertDirectives(cssText: string): string {\n    cssText = this._insertPolyfillDirectivesInCssText(cssText);\n    return this._insertPolyfillRulesInCssText(cssText);\n  }\n\n  /*\n   * Process styles to convert native ShadowDOM rules that will trip\n   * up the css parser; we rely on decorating the stylesheet with inert rules.\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-next-selector { content: ':host menu-item'; }\n   * ::content menu-item {\n   *\n   * to this:\n   *\n   * scopeName menu-item {\n   *\n   **/\n  private _insertPolyfillDirectivesInCssText(cssText: string): string {\n    // Difference with webcomponents.js: does not handle comments\n    return cssText.replace(_cssContentNextSelectorRe, function(...m: string[]) {\n      return m[2] + '{';\n    });\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-rule {\n   *   content: ':host menu-item';\n   * ...\n   * }\n   *\n   * to this:\n   *\n   * scopeName menu-item {...}\n   *\n   **/\n  private _insertPolyfillRulesInCssText(cssText: string): string {\n    // Difference with webcomponents.js: does not handle comments\n    return cssText.replace(_cssContentRuleRe, (...m: string[]) => {\n      const rule = m[0].replace(m[1], '').replace(m[2], '');\n      return m[4] + rule;\n    });\n  }\n\n  /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n   *\n   *  .foo {... }\n   *\n   *  and converts this to\n   *\n   *  scopeName .foo { ... }\n   */\n  private _scopeCssText(cssText: string, scopeSelector: string, hostSelector: string): string {\n    const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n    // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n    cssText = this._insertPolyfillHostInCssText(cssText);\n    cssText = this._convertColonHost(cssText);\n    cssText = this._convertColonHostContext(cssText);\n    cssText = this._convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n    }\n    cssText = cssText + '\\n' + unscopedRules;\n    return cssText.trim();\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n   * occasions, e.g. -webkit-calc on Safari.)\n   * For example, we convert this rule:\n   *\n   * @polyfill-unscoped-rule {\n   *   content: 'menu-item';\n   * ... }\n   *\n   * to this:\n   *\n   * menu-item {...}\n   *\n   **/\n  private _extractUnscopedRulesFromCssText(cssText: string): string {\n    // Difference with webcomponents.js: does not handle comments\n    let r = '';\n    let m: RegExpExecArray|null;\n    _cssContentUnscopedRuleRe.lastIndex = 0;\n    while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n      const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n      r += rule + '\\n\\n';\n    }\n    return r;\n  }\n\n  /*\n   * convert a rule like :host(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar\n   */\n  private _convertColonHost(cssText: string): string {\n    return cssText.replace(_cssColonHostRe, (_, hostSelectors: string, otherSelectors: string) => {\n      if (hostSelectors) {\n        const convertedSelectors: string[] = [];\n        const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());\n        for (const hostSelector of hostSelectorArray) {\n          if (!hostSelector) break;\n          const convertedSelector =\n              _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n          convertedSelectors.push(convertedSelector);\n        }\n        return convertedSelectors.join(',');\n      } else {\n        return _polyfillHostNoCombinator + otherSelectors;\n      }\n    });\n  }\n\n  /*\n   * convert a rule like :host-context(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n   *\n   * and\n   *\n   * :host-context(.foo:host) .bar { ... }\n   *\n   * to\n   *\n   * .foo<scopeName> .bar { ... }\n   */\n  private _convertColonHostContext(cssText: string): string {\n    return cssText.replace(_cssColonHostContextReGlobal, selectorText => {\n      // We have captured a selector that contains a `:host-context` rule.\n\n      // For backward compatibility `:host-context` may contain a comma separated list of selectors.\n      // Each context selector group will contain a list of host-context selectors that must match\n      // an ancestor of the host.\n      // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\n      const contextSelectorGroups: string[][] = [[]];\n\n      // There may be more than `:host-context` in this selector so `selectorText` could look like:\n      // `:host-context(.one):host-context(.two)`.\n      // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n      // `:host-context` selectors from this selector.\n      let match: RegExpMatchArray|null;\n      while (match = _cssColonHostContextRe.exec(selectorText)) {\n        // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n\n        // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\n        const newContextSelectors =\n            (match[1] ?? '').trim().split(',').map(m => m.trim()).filter(m => m !== '');\n\n        // We must duplicate the current selector group for each of these new selectors.\n        // For example if the current groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c'],\n        //   ['x', 'y', 'z'],\n        // ]\n        // ```\n        // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\n        // groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c', 'm'],\n        //   ['x', 'y', 'z', 'm'],\n        //   ['a', 'b', 'c', 'n'],\n        //   ['x', 'y', 'z', 'n'],\n        // ]\n        // ```\n        const contextSelectorGroupsLength = contextSelectorGroups.length;\n        repeatGroups(contextSelectorGroups, newContextSelectors.length);\n        for (let i = 0; i < newContextSelectors.length; i++) {\n          for (let j = 0; j < contextSelectorGroupsLength; j++) {\n            contextSelectorGroups[j + (i * contextSelectorGroupsLength)].push(\n                newContextSelectors[i]);\n          }\n        }\n\n        // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\n        selectorText = match[2];\n      }\n\n      // The context selectors now must be combined with each other to capture all the possible\n      // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more\n      // info about how this is done.\n      return contextSelectorGroups\n          .map(contextSelectors => combineHostContextSelectors(contextSelectors, selectorText))\n          .join(', ');\n    });\n  }\n\n  /*\n   * Convert combinators like ::shadow and pseudo-elements like ::content\n   * by replacing with space.\n   */\n  private _convertShadowDOMSelectors(cssText: string): string {\n    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n  }\n\n  // change a selector like 'div' to 'name div'\n  private _scopeSelectors(cssText: string, scopeSelector: string, hostSelector: string): string {\n    return processRules(cssText, (rule: CssRule) => {\n      let selector = rule.selector;\n      let content = rule.content;\n      if (rule.selector[0] !== '@') {\n        selector =\n            this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);\n      } else if (\n          rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n          rule.selector.startsWith('@document')) {\n        content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n      } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n        content = this._stripScopingSelectors(rule.content);\n      }\n      return new CssRule(selector, content);\n    });\n  }\n\n  /**\n   * Handle a css text that is within a rule that should not contain scope selectors by simply\n   * removing them! An example of such a rule is `@font-face`.\n   *\n   * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\n   * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\n   * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\n   * can end up with broken css if the imported styles happen to contain @font-face rules.\n   *\n   * For example:\n   *\n   * ```\n   * :host ::ng-deep {\n   *   import 'some/lib/containing/font-face';\n   * }\n   *\n   * Similar logic applies to `@page` rules which can contain a particular set of properties,\n   * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\n   * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\n   * ```\n   */\n  private _stripScopingSelectors(cssText: string): string {\n    return processRules(cssText, rule => {\n      const selector = rule.selector.replace(_shadowDeepSelectors, ' ')\n                           .replace(_polyfillHostNoCombinatorRe, ' ');\n      return new CssRule(selector, rule.content);\n    });\n  }\n\n  private _scopeSelector(\n      selector: string, scopeSelector: string, hostSelector: string, strict: boolean): string {\n    return selector.split(',')\n        .map(part => part.trim().split(_shadowDeepSelectors))\n        .map((deepParts) => {\n          const [shallowPart, ...otherParts] = deepParts;\n          const applyScope = (shallowPart: string) => {\n            if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n              return strict ?\n                  this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                  this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n            } else {\n              return shallowPart;\n            }\n          };\n          return [applyScope(shallowPart), ...otherParts].join(' ');\n        })\n        .join(', ');\n  }\n\n  private _selectorNeedsScoping(selector: string, scopeSelector: string): boolean {\n    const re = this._makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n  }\n\n  private _makeScopeMatcher(scopeSelector: string): RegExp {\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n  }\n\n  private _applySelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    // Difference from webcomponents.js: scopeSelector could not be an array\n    return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n  }\n\n  // scope via name and [is=name]\n  private _applySimpleSelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n      const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;\n      return selector\n          .replace(\n              _polyfillHostNoCombinatorRe,\n              (hnc, selector) => {\n                return selector.replace(\n                    /([^:]*)(:*)(.*)/,\n                    (_: string, before: string, colon: string, after: string) => {\n                      return before + replaceBy + colon + after;\n                    });\n              })\n          .replace(_polyfillHostRe, replaceBy + ' ');\n    }\n\n    return scopeSelector + ' ' + selector;\n  }\n\n  // return a selector with [name] suffix on each simple selector\n  // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n  private _applyStrictSelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_: string, ...parts: string[]) => parts[0]);\n\n    const attrName = '[' + scopeSelector + ']';\n\n    const _scopeSelectorPart = (p: string) => {\n      let scopedP = p.trim();\n\n      if (!scopedP) {\n        return '';\n      }\n\n      if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n        scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n      } else {\n        // remove :host since it should be unnecessary\n        const t = p.replace(_polyfillHostRe, '');\n        if (t.length > 0) {\n          const matches = t.match(/([^:]*)(:*)(.*)/);\n          if (matches) {\n            scopedP = matches[1] + attrName + matches[2] + matches[3];\n          }\n        }\n      }\n\n      return scopedP;\n    };\n\n    const safeContent = new SafeSelector(selector);\n    selector = safeContent.content();\n\n    let scopedSelector = '';\n    let startIndex = 0;\n    let res: RegExpExecArray|null;\n    const sep = /( |>|\\+|~(?!=))\\s*/g;\n\n    // If a selector appears before :host it should not be shimmed as it\n    // matches on ancestor elements and not on elements in the host's shadow\n    // `:host-context(div)` is transformed to\n    // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n    // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n    // Historically `component-tag:host` was matching the component so we also want to preserve\n    // this behavior to avoid breaking legacy apps (it should not match).\n    // The behavior should be:\n    // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n    // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n    //   `:host-context(tag)`)\n    const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n    // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n    let shouldScope = !hasHost;\n\n    while ((res = sep.exec(selector)) !== null) {\n      const separator = res[1];\n      const part = selector.slice(startIndex, res.index).trim();\n      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n      const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n      scopedSelector += `${scopedPart} ${separator} `;\n      startIndex = sep.lastIndex;\n    }\n\n    const part = selector.substring(startIndex);\n    shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n    scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n\n    // replace the placeholders with their original values\n    return safeContent.restore(scopedSelector);\n  }\n\n  private _insertPolyfillHostInCssText(selector: string): string {\n    return selector.replace(_colonHostContextRe, _polyfillHostContext)\n        .replace(_colonHostRe, _polyfillHost);\n  }\n}\n\nclass SafeSelector {\n  private placeholders: string[] = [];\n  private index = 0;\n  private _content: string;\n\n  constructor(selector: string) {\n    // Replaces attribute selectors with placeholders.\n    // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n    selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n\n    // CSS allows for certain special characters to be used in selectors if they're escaped.\n    // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\n    // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\n    // Replace all escape sequences (`\\` followed by a character) with a placeholder so\n    // that our handling of pseudo-selectors doesn't mess with them.\n    selector = this._escapeRegexMatches(selector, /(\\\\.)/g);\n\n    // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n    // WS and \"+\" would otherwise be interpreted as selector separators.\n    this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(exp);\n      this.index++;\n      return pseudo + replaceBy;\n    });\n  }\n\n  restore(content: string): string {\n    return content.replace(/__ph-(\\d+)__/g, (_ph, index) => this.placeholders[+index]);\n  }\n\n  content(): string {\n    return this._content;\n  }\n\n  /**\n   * Replaces all of the substrings that match a regex within a\n   * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\n   */\n  private _escapeRegexMatches(content: string, pattern: RegExp): string {\n    return content.replace(pattern, (_, keep) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n  }\n}\n\nconst _cssContentNextSelectorRe =\n    /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe =\n    /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _parenSuffix = '(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\nconst _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\nconst _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst _shadowDOMSelectorsRe = [\n  /::shadow/g,\n  /::content/g,\n  // Deprecated selectors\n  /\\/shadow-deep\\//g,\n  /\\/shadow\\//g,\n];\n\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\n\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\n\nfunction stripComments(input: string): string {\n  return input.replace(_commentRe, '');\n}\n\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\n\nfunction extractCommentsWithHash(input: string): string[] {\n  return input.match(_commentWithHashRe) || [];\n}\n\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst QUOTE_PLACEHOLDER = '%QUOTED%';\nconst _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nconst _quotedRe = /%QUOTED%/g;\nconst CONTENT_PAIRS = new Map([['{', '}']]);\nconst QUOTE_PAIRS = new Map([[`\"`, `\"`], [`'`, `'`]]);\n\nexport class CssRule {\n  constructor(public selector: string, public content: string) {}\n}\n\nexport function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string {\n  const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);\n  const inputWithEscapedBlocks =\n      escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n  let nextBlockIndex = 0;\n  let nextQuoteIndex = 0;\n  return inputWithEscapedBlocks.escapedString\n      .replace(\n          _ruleRe,\n          (...m: string[]) => {\n            const selector = m[2];\n            let content = '';\n            let suffix = m[4];\n            let contentPrefix = '';\n            if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n              content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n              suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n              contentPrefix = '{';\n            }\n            const rule = ruleCallback(new CssRule(selector, content));\n            return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n          })\n      .replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);\n}\n\nclass StringWithEscapedBlocks {\n  constructor(public escapedString: string, public blocks: string[]) {}\n}\n\nfunction escapeBlocks(\n    input: string, charPairs: Map<string, string>, placeholder: string): StringWithEscapedBlocks {\n  const resultParts: string[] = [];\n  const escapedBlocks: string[] = [];\n  let openCharCount = 0;\n  let nonBlockStartIndex = 0;\n  let blockStartIndex = -1;\n  let openChar: string|undefined;\n  let closeChar: string|undefined;\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '\\\\') {\n      i++;\n    } else if (char === closeChar) {\n      openCharCount--;\n      if (openCharCount === 0) {\n        escapedBlocks.push(input.substring(blockStartIndex, i));\n        resultParts.push(placeholder);\n        nonBlockStartIndex = i;\n        blockStartIndex = -1;\n        openChar = closeChar = undefined;\n      }\n    } else if (char === openChar) {\n      openCharCount++;\n    } else if (openCharCount === 0 && charPairs.has(char)) {\n      openChar = char;\n      closeChar = charPairs.get(char);\n      openCharCount = 1;\n      blockStartIndex = i + 1;\n      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n    }\n  }\n  if (blockStartIndex !== -1) {\n    escapedBlocks.push(input.substring(blockStartIndex));\n    resultParts.push(placeholder);\n  } else {\n    resultParts.push(input.substring(nonBlockStartIndex));\n  }\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n\n/**\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n * to create a selector that matches the same as `:host-context()`.\n *\n * Given a single context selector `A` we need to output selectors that match on the host and as an\n * ancestor of the host:\n *\n * ```\n * A <hostMarker>, A<hostMarker> {}\n * ```\n *\n * When there is more than one context selector we also have to create combinations of those\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\n *\n * ```\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n * ```\n *\n * And so on...\n *\n * @param hostMarker the string that selects the host element.\n * @param contextSelectors an array of context selectors that will be combined.\n * @param otherSelectors the rest of the selectors that are not context selectors.\n */\nfunction combineHostContextSelectors(contextSelectors: string[], otherSelectors: string): string {\n  const hostMarker = _polyfillHostNoCombinator;\n  _polyfillHostRe.lastIndex = 0;  // reset the regex to ensure we get an accurate test\n  const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n\n  // If there are no context selectors then just output a host marker\n  if (contextSelectors.length === 0) {\n    return hostMarker + otherSelectors;\n  }\n\n  const combined: string[] = [contextSelectors.pop() || ''];\n  while (contextSelectors.length > 0) {\n    const length = combined.length;\n    const contextSelector = contextSelectors.pop();\n    for (let i = 0; i < length; i++) {\n      const previousSelectors = combined[i];\n      // Add the new selector as a descendant of the previous selectors\n      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n      // Add the new selector as an ancestor of the previous selectors\n      combined[length + i] = contextSelector + ' ' + previousSelectors;\n      // Add the new selector to act on the same element as the previous selectors\n      combined[i] = contextSelector + previousSelectors;\n    }\n  }\n  // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n  // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n  return combined\n      .map(\n          s => otherSelectorsHasHost ?\n              `${s}${otherSelectors}` :\n              `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\n      .join(',');\n}\n\n/**\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\n * stored.\n *\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\n * newly added groups will be clones of the original.\n *\n * @param groups An array of groups of strings that will be repeated. This array is mutated\n *     in-place.\n * @param multiples The number of times the current groups should appear.\n */\nexport function repeatGroups(groups: string[][], multiples: number): void {\n  const length = groups.length;\n  for (let i = 1; i < multiples; i++) {\n    for (let j = 0; j < length; j++) {\n      groups[j + (i * length)] = groups[j].slice(0);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst enum Char {\n  OpenParen = 40,\n  CloseParen = 41,\n  Colon = 58,\n  Semicolon = 59,\n  BackSlash = 92,\n  QuoteNone = 0,  // indicating we are not inside a quote\n  QuoteDouble = 34,\n  QuoteSingle = 39,\n}\n\n\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nexport function parse(value: string): string[] {\n  // we use a string array here instead of a string map\n  // because a string-map is not guaranteed to retain the\n  // order of the entries whereas a string array can be\n  // constructed in a [key, value, key, value] format.\n  const styles: string[] = [];\n\n  let i = 0;\n  let parenDepth = 0;\n  let quote: Char = Char.QuoteNone;\n  let valueStart = 0;\n  let propStart = 0;\n  let currentProp: string|null = null;\n  let valueHasQuotes = false;\n  while (i < value.length) {\n    const token = value.charCodeAt(i++) as Char;\n    switch (token) {\n      case Char.OpenParen:\n        parenDepth++;\n        break;\n      case Char.CloseParen:\n        parenDepth--;\n        break;\n      case Char.QuoteSingle:\n        // valueStart needs to be there since prop values don't\n        // have quotes in CSS\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteSingle;\n        } else if (quote === Char.QuoteSingle && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.QuoteDouble:\n        // same logic as above\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteDouble;\n        } else if (quote === Char.QuoteDouble && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.Colon:\n        if (!currentProp && parenDepth === 0 && quote === Char.QuoteNone) {\n          currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n          valueStart = i;\n        }\n        break;\n      case Char.Semicolon:\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === Char.QuoteNone) {\n          const styleVal = value.substring(valueStart, i - 1).trim();\n          styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n          propStart = i;\n          valueStart = 0;\n          currentProp = null;\n          valueHasQuotes = false;\n        }\n        break;\n    }\n  }\n\n  if (currentProp && valueStart) {\n    const styleVal = value.substr(valueStart).trim();\n    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n  }\n\n  return styles;\n}\n\nexport function stripUnnecessaryQuotes(value: string): string {\n  const qS = value.charCodeAt(0);\n  const qE = value.charCodeAt(value.length - 1);\n  if (qS == qE && (qS == Char.QuoteSingle || qS == Char.QuoteDouble)) {\n    const tempValue = value.substring(1, value.length - 1);\n    // special case to avoid using a multi-quoted string that was just chomped\n    // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n    if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n      value = tempValue;\n    }\n  }\n  return value;\n}\n\nexport function hyphenate(value: string): string {\n  return value\n      .replace(\n          /[a-z][A-Z]/g,\n          v => {\n            return v.charAt(0) + '-' + v.charAt(1);\n          })\n      .toLowerCase();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AttributeMarker} from '../../core';\nimport {AST, ASTWithSource, BindingPipe, BindingType, EmptyExpr, Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\n\nimport {hyphenate, parse as parseStyle} from './style_parser';\nimport {ValueConverter} from './template';\nimport {DefinitionMap, getInterpolationArgsLength} from './util';\n\nconst IMPORTANT_FLAG = '!important';\n\n/**\n * Minimum amount of binding slots required in the runtime for style/class bindings.\n *\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n * record binding data, property information and metadata.\n *\n * When a binding is registered it will place the following information in the `LView`:\n *\n * slot 1) binding value\n * slot 2) cached value (all other values collected before it in string form)\n *\n * When a binding is registered it will place the following information in the `TData`:\n *\n * slot 1) prop name\n * slot 2) binding index that points to the previous style/class binding (and some extra config\n * values)\n *\n * Let's imagine we have a binding that looks like so:\n *\n * ```\n * <div [style.width]=\"x\" [style.height]=\"y\">\n * ```\n *\n * Our `LView` and `TData` data-structures look like so:\n *\n * ```typescript\n * LView = [\n *   // ...\n *   x, // value of x\n *   \"width: x\",\n *\n *   y, // value of y\n *   \"width: x; height: y\",\n *   // ...\n * ];\n *\n * TData = [\n *   // ...\n *   \"width\", // binding slot 20\n *   0,\n *\n *   \"height\",\n *   20,\n *   // ...\n * ];\n * ```\n *\n * */\nexport const MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n\n/**\n * A styling expression summary that is to be processed by the compiler\n */\nexport interface StylingInstruction {\n  reference: o.ExternalReference;\n  /** Calls to individual styling instructions. Used when chaining calls to the same instruction. */\n  calls: StylingInstructionCall[];\n}\n\nexport interface StylingInstructionCall {\n  sourceSpan: ParseSourceSpan|null;\n  supportsInterpolation: boolean;\n  allocateBindingSlots: number;\n  params: ((convertFn: (value: any) => o.Expression | o.Expression[]) => o.Expression[]);\n}\n\n/**\n * An internal record of the input data for a styling binding\n */\ninterface BoundStylingEntry {\n  hasOverrideFlag: boolean;\n  name: string|null;\n  suffix: string|null;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nexport class StylingBuilder {\n  /** Whether or not there are any static styling values present */\n  private _hasInitialValues = false;\n  /**\n   *  Whether or not there are any styling bindings present\n   *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n   */\n  public hasBindings = false;\n  public hasBindingsWithPipes = false;\n\n  /** the input for [class] (if it exists) */\n  private _classMapInput: BoundStylingEntry|null = null;\n  /** the input for [style] (if it exists) */\n  private _styleMapInput: BoundStylingEntry|null = null;\n  /** an array of each [style.prop] input */\n  private _singleStyleInputs: BoundStylingEntry[]|null = null;\n  /** an array of each [class.name] input */\n  private _singleClassInputs: BoundStylingEntry[]|null = null;\n  private _lastStylingInput: BoundStylingEntry|null = null;\n  private _firstStylingInput: BoundStylingEntry|null = null;\n\n  // maps are used instead of hash maps because a Map will\n  // retain the ordering of the keys\n\n  /**\n   * Represents the location of each style binding in the template\n   * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n   * that `width=0` and `height=1`)\n   */\n  private _stylesIndex = new Map<string, number>();\n\n  /**\n   * Represents the location of each class binding in the template\n   * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n   * that `big=0` and `hidden=1`)\n   */\n  private _classesIndex = new Map<string, number>();\n  private _initialStyleValues: string[] = [];\n  private _initialClassValues: string[] = [];\n\n  constructor(private _directiveExpr: o.Expression|null) {}\n\n  /**\n   * Registers a given input to the styling builder to be later used when producing AOT code.\n   *\n   * The code below will only accept the input if it is somehow tied to styling (whether it be\n   * style/class bindings or static style/class attributes).\n   */\n  registerBoundInput(input: t.BoundAttribute): boolean {\n    // [attr.style] or [attr.class] are skipped in the code below,\n    // they should not be treated as styling-based bindings since\n    // they are intended to be written directly to the attr and\n    // will therefore skip all style/class resolution that is present\n    // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n    // [class.prop]=\"\". [class]=\"\" assignments\n    let binding: BoundStylingEntry|null = null;\n    let name = input.name;\n    switch (input.type) {\n      case BindingType.Property:\n        binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n        break;\n      case BindingType.Style:\n        binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n        break;\n      case BindingType.Class:\n        binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n        break;\n    }\n    return binding ? true : false;\n  }\n\n  registerInputBasedOnName(name: string, expression: AST, sourceSpan: ParseSourceSpan) {\n    let binding: BoundStylingEntry|null = null;\n    const prefix = name.substring(0, 6);\n    const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n    const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n    if (isStyle || isClass) {\n      const isMapBased = name.charAt(5) !== '.';         // style.prop or class.prop makes this a no\n      const property = name.substr(isMapBased ? 5 : 6);  // the dot explains why there's a +1\n      if (isStyle) {\n        binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n      } else {\n        binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n      }\n    }\n    return binding;\n  }\n\n  registerStyleInput(\n      name: string, isMapBased: boolean, value: AST, sourceSpan: ParseSourceSpan,\n      suffix?: string|null): BoundStylingEntry|null {\n    if (isEmptyExpression(value)) {\n      return null;\n    }\n    // CSS custom properties are case-sensitive so we shouldn't normalize them.\n    // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n    if (!isCssCustomProperty(name)) {\n      name = hyphenate(name);\n    }\n    const {property, hasOverrideFlag, suffix: bindingSuffix} = parseProperty(name);\n    suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n    const entry:\n        BoundStylingEntry = {name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag};\n    if (isMapBased) {\n      this._styleMapInput = entry;\n    } else {\n      (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n      registerIntoMap(this._stylesIndex, property);\n    }\n    this._lastStylingInput = entry;\n    this._firstStylingInput = this._firstStylingInput || entry;\n    this._checkForPipes(value);\n    this.hasBindings = true;\n    return entry;\n  }\n\n  registerClassInput(name: string, isMapBased: boolean, value: AST, sourceSpan: ParseSourceSpan):\n      BoundStylingEntry|null {\n    if (isEmptyExpression(value)) {\n      return null;\n    }\n    const {property, hasOverrideFlag} = parseProperty(name);\n    const entry:\n        BoundStylingEntry = {name: property, value, sourceSpan, hasOverrideFlag, suffix: null};\n    if (isMapBased) {\n      this._classMapInput = entry;\n    } else {\n      (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n      registerIntoMap(this._classesIndex, property);\n    }\n    this._lastStylingInput = entry;\n    this._firstStylingInput = this._firstStylingInput || entry;\n    this._checkForPipes(value);\n    this.hasBindings = true;\n    return entry;\n  }\n\n  private _checkForPipes(value: AST) {\n    if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {\n      this.hasBindingsWithPipes = true;\n    }\n  }\n\n  /**\n   * Registers the element's static style string value to the builder.\n   *\n   * @param value the style string (e.g. `width:100px; height:200px;`)\n   */\n  registerStyleAttr(value: string) {\n    this._initialStyleValues = parseStyle(value);\n    this._hasInitialValues = true;\n  }\n\n  /**\n   * Registers the element's static class string value to the builder.\n   *\n   * @param value the className string (e.g. `disabled gold zoom`)\n   */\n  registerClassAttr(value: string) {\n    this._initialClassValues = value.trim().split(/\\s+/g);\n    this._hasInitialValues = true;\n  }\n\n  /**\n   * Appends all styling-related expressions to the provided attrs array.\n   *\n   * @param attrs an existing array where each of the styling expressions\n   * will be inserted into.\n   */\n  populateInitialStylingAttrs(attrs: o.Expression[]): void {\n    // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n    if (this._initialClassValues.length) {\n      attrs.push(o.literal(AttributeMarker.Classes));\n      for (let i = 0; i < this._initialClassValues.length; i++) {\n        attrs.push(o.literal(this._initialClassValues[i]));\n      }\n    }\n\n    // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n    if (this._initialStyleValues.length) {\n      attrs.push(o.literal(AttributeMarker.Styles));\n      for (let i = 0; i < this._initialStyleValues.length; i += 2) {\n        attrs.push(\n            o.literal(this._initialStyleValues[i]), o.literal(this._initialStyleValues[i + 1]));\n      }\n    }\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n   *\n   * The instruction generation code below is used for producing the AOT statement code which is\n   * responsible for registering initial styles (within a directive hostBindings' creation block),\n   * as well as any of the provided attribute values, to the directive host element.\n   */\n  assignHostAttrs(attrs: o.Expression[], definitionMap: DefinitionMap): void {\n    if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n      this.populateInitialStylingAttrs(attrs);\n      definitionMap.set('hostAttrs', o.literalArr(attrs));\n    }\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `classMap`.\n   *\n   * The instruction data will contain all expressions for `classMap` to function\n   * which includes the `[class]` expression params.\n   */\n  buildClassMapInstruction(valueConverter: ValueConverter): StylingInstruction|null {\n    if (this._classMapInput) {\n      return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n    }\n    return null;\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `styleMap`.\n   *\n   * The instruction data will contain all expressions for `styleMap` to function\n   * which includes the `[style]` expression params.\n   */\n  buildStyleMapInstruction(valueConverter: ValueConverter): StylingInstruction|null {\n    if (this._styleMapInput) {\n      return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n    }\n    return null;\n  }\n\n  private _buildMapBasedInstruction(\n      valueConverter: ValueConverter, isClassBased: boolean,\n      stylingInput: BoundStylingEntry): StylingInstruction {\n    // each styling binding value is stored in the LView\n    // map-based bindings allocate two slots: one for the\n    // previous binding value and another for the previous\n    // className or style attribute value.\n    let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n    // these values must be outside of the update block so that they can\n    // be evaluated (the AST visit call) during creation time so that any\n    // pipes can be picked up in time before the template is built\n    const mapValue = stylingInput.value.visit(valueConverter);\n    let reference: o.ExternalReference;\n    if (mapValue instanceof Interpolation) {\n      totalBindingSlotsRequired += mapValue.expressions.length;\n      reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :\n                                 getStyleMapInterpolationExpression(mapValue);\n    } else {\n      reference = isClassBased ? R3.classMap : R3.styleMap;\n    }\n\n    return {\n      reference,\n      calls: [{\n        supportsInterpolation: true,\n        sourceSpan: stylingInput.sourceSpan,\n        allocateBindingSlots: totalBindingSlotsRequired,\n        params: (convertFn: (value: any) => o.Expression|o.Expression[]) => {\n          const convertResult = convertFn(mapValue);\n          const params = Array.isArray(convertResult) ? convertResult : [convertResult];\n          return params;\n        }\n      }]\n    };\n  }\n\n  private _buildSingleInputs(\n      reference: o.ExternalReference, inputs: BoundStylingEntry[], valueConverter: ValueConverter,\n      getInterpolationExpressionFn: ((value: Interpolation) => o.ExternalReference)|null,\n      isClassBased: boolean): StylingInstruction[] {\n    const instructions: StylingInstruction[] = [];\n\n    inputs.forEach(input => {\n      const previousInstruction: StylingInstruction|undefined =\n          instructions[instructions.length - 1];\n      const value = input.value.visit(valueConverter);\n      let referenceForCall = reference;\n\n      // each styling binding value is stored in the LView\n      // but there are two values stored for each binding:\n      //   1) the value itself\n      //   2) an intermediate value (concatenation of style up to this point).\n      //      We need to store the intermediate value so that we don't allocate\n      //      the strings on each CD.\n      let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n      if (value instanceof Interpolation) {\n        totalBindingSlotsRequired += value.expressions.length;\n\n        if (getInterpolationExpressionFn) {\n          referenceForCall = getInterpolationExpressionFn(value);\n        }\n      }\n\n      const call = {\n        sourceSpan: input.sourceSpan,\n        allocateBindingSlots: totalBindingSlotsRequired,\n        supportsInterpolation: !!getInterpolationExpressionFn,\n        params: (convertFn: (value: any) => o.Expression | o.Expression[]) => {\n          // params => stylingProp(propName, value, suffix)\n          const params: o.Expression[] = [];\n          params.push(o.literal(input.name));\n\n          const convertResult = convertFn(value);\n          if (Array.isArray(convertResult)) {\n            params.push(...convertResult);\n          } else {\n            params.push(convertResult);\n          }\n\n          // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n          // if that is detected then we need to pass that in as an optional param.\n          if (!isClassBased && input.suffix !== null) {\n            params.push(o.literal(input.suffix));\n          }\n\n          return params;\n        }\n      };\n\n      // If we ended up generating a call to the same instruction as the previous styling property\n      // we can chain the calls together safely to save some bytes, otherwise we have to generate\n      // a separate instruction call. This is primarily a concern with interpolation instructions\n      // where we may start off with one `reference`, but end up using another based on the\n      // number of interpolations.\n      if (previousInstruction && previousInstruction.reference === referenceForCall) {\n        previousInstruction.calls.push(call);\n      } else {\n        instructions.push({reference: referenceForCall, calls: [call]});\n      }\n    });\n\n    return instructions;\n  }\n\n  private _buildClassInputs(valueConverter: ValueConverter): StylingInstruction[] {\n    if (this._singleClassInputs) {\n      return this._buildSingleInputs(\n          R3.classProp, this._singleClassInputs, valueConverter, null, true);\n    }\n    return [];\n  }\n\n  private _buildStyleInputs(valueConverter: ValueConverter): StylingInstruction[] {\n    if (this._singleStyleInputs) {\n      return this._buildSingleInputs(\n          R3.styleProp, this._singleStyleInputs, valueConverter,\n          getStylePropInterpolationExpression, false);\n    }\n    return [];\n  }\n\n  /**\n   * Constructs all instructions which contain the expressions that will be placed\n   * into the update block of a template function or a directive hostBindings function.\n   */\n  buildUpdateLevelInstructions(valueConverter: ValueConverter) {\n    const instructions: StylingInstruction[] = [];\n    if (this.hasBindings) {\n      const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n      if (styleMapInstruction) {\n        instructions.push(styleMapInstruction);\n      }\n      const classMapInstruction = this.buildClassMapInstruction(valueConverter);\n      if (classMapInstruction) {\n        instructions.push(classMapInstruction);\n      }\n      instructions.push(...this._buildStyleInputs(valueConverter));\n      instructions.push(...this._buildClassInputs(valueConverter));\n    }\n    return instructions;\n  }\n}\n\nfunction registerIntoMap(map: Map<string, number>, key: string) {\n  if (!map.has(key)) {\n    map.set(key, map.size);\n  }\n}\n\nexport function parseProperty(name: string):\n    {property: string, suffix: string|null, hasOverrideFlag: boolean} {\n  let hasOverrideFlag = false;\n  const overrideIndex = name.indexOf(IMPORTANT_FLAG);\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n    hasOverrideFlag = true;\n  }\n\n  let suffix: string|null = null;\n  let property = name;\n  const unitIndex = name.lastIndexOf('.');\n  if (unitIndex > 0) {\n    suffix = name.substr(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n\n  return {property, suffix, hasOverrideFlag};\n}\n\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\nfunction getClassMapInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.classMap;\n    case 3:\n      return R3.classMapInterpolate1;\n    case 5:\n      return R3.classMapInterpolate2;\n    case 7:\n      return R3.classMapInterpolate3;\n    case 9:\n      return R3.classMapInterpolate4;\n    case 11:\n      return R3.classMapInterpolate5;\n    case 13:\n      return R3.classMapInterpolate6;\n    case 15:\n      return R3.classMapInterpolate7;\n    case 17:\n      return R3.classMapInterpolate8;\n    default:\n      return R3.classMapInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated style map.\n * @param interpolation An Interpolation AST\n */\nfunction getStyleMapInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.styleMap;\n    case 3:\n      return R3.styleMapInterpolate1;\n    case 5:\n      return R3.styleMapInterpolate2;\n    case 7:\n      return R3.styleMapInterpolate3;\n    case 9:\n      return R3.styleMapInterpolate4;\n    case 11:\n      return R3.styleMapInterpolate5;\n    case 13:\n      return R3.styleMapInterpolate6;\n    case 15:\n      return R3.styleMapInterpolate7;\n    case 17:\n      return R3.styleMapInterpolate8;\n    default:\n      return R3.styleMapInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\nfunction getStylePropInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.styleProp;\n    case 3:\n      return R3.stylePropInterpolate1;\n    case 5:\n      return R3.stylePropInterpolate2;\n    case 7:\n      return R3.stylePropInterpolate3;\n    case 9:\n      return R3.stylePropInterpolate4;\n    case 11:\n      return R3.stylePropInterpolate5;\n    case 13:\n      return R3.stylePropInterpolate6;\n    case 15:\n      return R3.stylePropInterpolate7;\n    case 17:\n      return R3.stylePropInterpolate8;\n    default:\n      return R3.stylePropInterpolateV;\n  }\n}\n\n/**\n * Checks whether property name is a custom CSS property.\n * See: https://www.w3.org/TR/css-variables-1\n */\nfunction isCssCustomProperty(name: string): boolean {\n  return name.startsWith('--');\n}\n\nfunction isEmptyExpression(ast: AST): boolean {\n  if (ast instanceof ASTWithSource) {\n    ast = ast.ast;\n  }\n  return ast instanceof EmptyExpr;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  PrivateIdentifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new _Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(\n      public index: number, public end: number, public type: TokenType, public numValue: number,\n      public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n\n  isNumber(): boolean {\n    return this.type == TokenType.Number;\n  }\n\n  isString(): boolean {\n    return this.type == TokenType.String;\n  }\n\n  isOperator(operator: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operator;\n  }\n\n  isIdentifier(): boolean {\n    return this.type == TokenType.Identifier;\n  }\n\n  isPrivateIdentifier(): boolean {\n    return this.type == TokenType.PrivateIdentifier;\n  }\n\n  isKeyword(): boolean {\n    return this.type == TokenType.Keyword;\n  }\n\n  isKeywordLet(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'let';\n  }\n\n  isKeywordAs(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'as';\n  }\n\n  isKeywordNull(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'null';\n  }\n\n  isKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n\n  isKeywordTrue(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'true';\n  }\n\n  isKeywordFalse(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'false';\n  }\n\n  isKeywordThis(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'this';\n  }\n\n  isError(): boolean {\n    return this.type == TokenType.Error;\n  }\n\n  toNumber(): number {\n    return this.type == TokenType.Number ? this.numValue : -1;\n  }\n\n  toString(): string|null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.PrivateIdentifier:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, end: number, code: number): Token {\n  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Identifier, 0, text);\n}\n\nfunction newPrivateIdentifierToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.PrivateIdentifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, end: number, n: number): Token {\n  return new Token(index, end, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, end: number, message: string): Token {\n  return new Token(index, end, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, -1, TokenType.Character, 0, '');\n\nclass _Scanner {\n  length: number;\n  peek: number = 0;\n  index: number = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token|null {\n    const input = this.input, length = this.length;\n    let peek = this.peek, index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                                          newCharacterToken(start, this.index, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n        return this.scanPrivateIdentifier();\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanQuestion(start);\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n            start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, this.index, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n      start: number, one: string, twoCode: number, two: string, threeCode?: number,\n      three?: string): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :\n                                        newIdentifierToken(start, this.index, str);\n  }\n\n  /** Scans an ECMAScript private identifier. */\n  scanPrivateIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    if (!isIdentifierStart(this.peek)) {\n      return this.error('Invalid character [#]', -1);\n    }\n    while (isIdentifierPart(this.peek)) this.advance();\n    const identifierName: string = this.input.substring(start, this.index);\n    return newPrivateIdentifierToken(start, this.index, identifierName);\n  }\n\n  scanNumber(start: number): Token {\n    let simple = (this.index === start);\n    let hasSeparators = false;\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek === chars.$_) {\n        // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is\n        // valid while `_101` and `101_` are not. The separator can't be next to the decimal\n        // point or another separator either. Note that it's unlikely that we'll hit a case where\n        // the underscore is at the start, because that's a valid identifier and it will be picked\n        // up earlier in the parsing. We validate for it anyway just in case.\n        if (!chars.isDigit(this.input.charCodeAt(this.index - 1)) ||\n            !chars.isDigit(this.input.charCodeAt(this.index + 1))) {\n          return this.error('Invalid numeric separator', 0);\n        }\n        hasSeparators = true;\n      } else if (this.peek === chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n\n    let str = this.input.substring(start, this.index);\n    if (hasSeparators) {\n      str = str.replace(/_/g, '');\n    }\n    const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, this.index, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let buffer: string = '';\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i: number = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, this.index, buffer + last);\n  }\n\n  scanQuestion(start: number): Token {\n    this.advance();\n    let str: string = '?';\n    // Either `a ?? b` or 'a?.b'.\n    if (this.peek === chars.$QUESTION || this.peek === chars.$PERIOD) {\n      str += this.peek === chars.$PERIOD ? '.' : '?';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(\n        position, this.index,\n        `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n      (code == chars.$_) || (code == chars.$$);\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n      (code == chars.$$);\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\n\nimport {AbsoluteSourceSpan, AST, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, EmptyExpr, ExpressionBinding, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeCall, SafeKeyedRead, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\nimport {EOF, isIdentifier, Lexer, Token, TokenType} from './lexer';\n\nexport interface InterpolationPiece {\n  text: string;\n  start: number;\n  end: number;\n}\nexport class SplitInterpolation {\n  constructor(\n      public strings: InterpolationPiece[], public expressions: InterpolationPiece[],\n      public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n      public templateBindings: TemplateBinding[], public warnings: string[],\n      public errors: ParserError[]) {}\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast =\n        new _ParseAST(input, location, absoluteOffset, tokens, true, this.errors, 0).parseChain();\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  parseBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private checkSimpleExpression(ast: AST): string[] {\n    const checker = new SimpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n\n  parseSimpleBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    const errors = this.checkSimpleExpression(ast);\n    if (errors.length > 0) {\n      this._reportError(\n          `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: string) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const quote = this._parseQuote(input, location, absoluteOffset);\n\n    if (quote != null) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(input, location, absoluteOffset, tokens, false, this.errors, 0)\n        .parseChain();\n  }\n\n  private _parseQuote(input: string|null, location: string, absoluteOffset: number): AST|null {\n    if (input == null) return null;\n    const prefixSeparatorIndex = input.indexOf(':');\n    if (prefixSeparatorIndex == -1) return null;\n    const prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) return null;\n    const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    const span = new ParseSpan(0, input.length);\n    return new Quote(\n        span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```\n   *   <div *ngFor=\"let item of items\">\n   *         ^      ^ absoluteValueOffset for `templateValue`\n   *         absoluteKeyOffset for `templateKey`\n   * ```\n   * contains three bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   *\n   * This is apparent from the de-sugared template:\n   * ```\n   *   <ng-template ngFor let-item [ngForOf]=\"items\">\n   * ```\n   *\n   * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n   * @param templateValue RHS of the microsyntax attribute\n   * @param templateUrl template filename if it's external, component filename if it's inline\n   * @param absoluteKeyOffset start of the `templateKey`\n   * @param absoluteValueOffset start of the `templateValue`\n   */\n  parseTemplateBindings(\n      templateKey: string, templateValue: string, templateUrl: string, absoluteKeyOffset: number,\n      absoluteValueOffset: number): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(templateValue);\n    const parser = new _ParseAST(\n        templateValue, templateUrl, absoluteValueOffset, tokens, false /* parseAction */,\n        this.errors, 0 /* relative offset */);\n    return parser.parseTemplateBindings({\n      source: templateKey,\n      span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n    });\n  }\n\n  parseInterpolation(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource|null {\n    const {strings, expressions, offsets} =\n        this.splitInterpolation(input, location, interpolationConfig);\n    if (expressions.length === 0) return null;\n\n    const expressionNodes: AST[] = [];\n\n    for (let i = 0; i < expressions.length; ++i) {\n      const expressionText = expressions[i].text;\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast =\n          new _ParseAST(input, location, absoluteOffset, tokens, false, this.errors, offsets[i])\n              .parseChain();\n      expressionNodes.push(ast);\n    }\n\n    return this.createInterpolationAst(\n        strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(expression: string, location: string, absoluteOffset: number):\n      ASTWithSource {\n    const sourceToLex = this._stripComments(expression);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast = new _ParseAST(\n                    expression, location, absoluteOffset, tokens,\n                    /* parseAction */ false, this.errors, 0)\n                    .parseChain();\n    const strings = ['', ''];  // The prefix and suffix strings are both empty\n    return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\n  }\n\n  private createInterpolationAst(\n      strings: string[], expressions: AST[], input: string, location: string,\n      absoluteOffset: number): ASTWithSource {\n    const span = new ParseSpan(0, input.length);\n    const interpolation =\n        new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\n    return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\n  }\n\n  /**\n   * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n   * the string.\n   * Returns `null` if there are no interpolations, otherwise a\n   * `SplitInterpolation` with splits that look like\n   *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n   */\n  splitInterpolation(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n    const strings: InterpolationPiece[] = [];\n    const expressions: InterpolationPiece[] = [];\n    const offsets: number[] = [];\n    let i = 0;\n    let atInterpolation = false;\n    let extendLastString = false;\n    let {start: interpStart, end: interpEnd} = interpolationConfig;\n    while (i < input.length) {\n      if (!atInterpolation) {\n        // parse until starting {{\n        const start = i;\n        i = input.indexOf(interpStart, i);\n        if (i === -1) {\n          i = input.length;\n        }\n        const text = input.substring(start, i);\n        strings.push({text, start, end: i});\n\n        atInterpolation = true;\n      } else {\n        // parse from starting {{ to ending }} while ignoring content inside quotes.\n        const fullStart = i;\n        const exprStart = fullStart + interpStart.length;\n        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n        if (exprEnd === -1) {\n          // Could not find the end of the interpolation; do not parse an expression.\n          // Instead we should extend the content on the last raw string.\n          atInterpolation = false;\n          extendLastString = true;\n          break;\n        }\n        const fullEnd = exprEnd + interpEnd.length;\n\n        const text = input.substring(exprStart, exprEnd);\n        if (text.trim().length === 0) {\n          this._reportError(\n              'Blank expressions are not allowed in interpolated strings', input,\n              `at column ${i} in`, location);\n        }\n        expressions.push({text, start: fullStart, end: fullEnd});\n        offsets.push(exprStart);\n\n        i = fullEnd;\n        atInterpolation = false;\n      }\n    }\n    if (!atInterpolation) {\n      // If we are now at a text section, add the remaining content as a raw string.\n      if (extendLastString) {\n        const piece = strings[strings.length - 1];\n        piece.text += input.substring(i);\n        piece.end = input.length;\n      } else {\n        strings.push({text: input.substring(i), start: i, end: input.length});\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string|null, location: string, absoluteOffset: number):\n      ASTWithSource {\n    const span = new ParseSpan(0, input == null ? 0 : input.length);\n    return new ASTWithSource(\n        new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location,\n        absoluteOffset, this.errors);\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i) : input;\n  }\n\n  private _commentStart(input: string): number|null {\n    let outerQuote: number|null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && chars.isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(input: string, location: string, {start, end}: InterpolationConfig):\n      void {\n    let startIndex = -1;\n    let endIndex = -1;\n\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith(start)) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n\n    if (startIndex > -1 && endIndex > -1) {\n      this._reportError(\n          `Got interpolation (${start}${end}) where expression was expected`, input,\n          `at column ${startIndex} in`, location);\n    }\n  }\n\n  /**\n   * Finds the index of the end of an interpolation expression\n   * while ignoring comments and quoted content.\n   */\n  private _getInterpolationEndIndex(input: string, expressionEnd: string, start: number): number {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n\n      // Nothing else in the expression matters after we've\n      // hit a comment so look directly for the end token.\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Generator used to iterate over the character indexes of a string that are outside of quotes.\n   * @param input String to loop through.\n   * @param start Index within the string at which to start.\n   */\n  private * _forEachUnquotedChar(input: string, start: number) {\n    let currentQuote: string|null = null;\n    let escapeCount = 0;\n    for (let i = start; i < input.length; i++) {\n      const char = input[i];\n      // Skip the characters inside quotes. Note that we only care about the outer-most\n      // quotes matching up and we need to account for escape characters.\n      if (chars.isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\n          escapeCount % 2 === 0) {\n        currentQuote = currentQuote === null ? char : null;\n      } else if (currentQuote === null) {\n        yield i;\n      }\n      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n    }\n  }\n}\n\n/** Describes a stateful context an expression parser is in. */\nenum ParseContextFlags {\n  None = 0,\n  /**\n   * A Writable context is one in which a value may be written to an lvalue.\n   * For example, after we see a property access, we may expect a write to the\n   * property via the \"=\" operator.\n   *   prop\n   *        ^ possible \"=\" after\n   */\n  Writable = 1,\n}\n\nexport class _ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n  private context = ParseContextFlags.None;\n\n  // Cache of expression start and input indeces to the absolute source span they map to, used to\n  // prevent creating superfluous source spans in `sourceSpan`.\n  // A serial of the expression start and input index is used for mapping because both are stateful\n  // and may change for subsequent expressions visited by the parser.\n  private sourceSpanCache = new Map<string, AbsoluteSourceSpan>();\n\n  index: number = 0;\n\n  constructor(\n      public input: string, public location: string, public absoluteOffset: number,\n      public tokens: Token[], public parseAction: boolean, private errors: ParserError[],\n      private offset: number) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token {\n    return this.peek(0);\n  }\n\n  /** Whether all the parser input has been processed. */\n  get atEOF(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  /**\n   * Index of the next token to be processed, or the end of the last token if all have been\n   * processed.\n   */\n  get inputIndex(): number {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n\n  /**\n   * End index of the last processed token, or the start of the first token if none have been\n   * processed.\n   */\n  get currentEndIndex(): number {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    // No tokens have been processed yet; return the next token's start or the length of the input\n    // if there is no token.\n    if (this.tokens.length === 0) {\n      return this.input.length + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n\n  /**\n   * Returns the absolute offset of the start of the current token.\n   */\n  get currentAbsoluteOffset(): number {\n    return this.absoluteOffset + this.inputIndex;\n  }\n\n  /**\n   * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n   * provided).\n   *\n   * @param start Position from which the `ParseSpan` will start.\n   * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n   *     natural ending index)\n   */\n  span(start: number, artificialEndIndex?: number): ParseSpan {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n\n    // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n    // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n    // appears to be a deep-seated parser bug.\n    //\n    // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n    // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n    if (start > endIndex) {\n      const tmp = endIndex;\n      endIndex = start;\n      start = tmp;\n    }\n\n    return new ParseSpan(start, endIndex);\n  }\n\n  sourceSpan(start: number, artificialEndIndex?: number): AbsoluteSourceSpan {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(\n          serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n    }\n    return this.sourceSpanCache.get(serial)!;\n  }\n\n  advance() {\n    this.index++;\n  }\n\n  /**\n   * Executes a callback in the provided context.\n   */\n  private withContext<T>(context: ParseContextFlags, cb: () => T): T {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }\n\n  consumeOptionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  /**\n   * Consumes an expected character, otherwise emits an error about the missing expected character\n   * and skips over the token stream until reaching a recoverable point.\n   *\n   * See `this.error` and `this.skip` for more details.\n   */\n  expectCharacter(code: number) {\n    if (this.consumeOptionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  consumeOptionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.consumeOptionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  prettyPrintToken(tok: Token): string {\n    return tok === EOF ? 'end of input' : `token ${tok}`;\n  }\n\n  expectIdentifierOrKeyword(): string|null {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n      }\n      return null;\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n      } else {\n        this.error(\n            `Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n      }\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        }  // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length == 0) {\n      // We have no expressions so create an empty expression that spans the entire input length\n      const artificialStart = this.offset;\n      const artificialEnd = this.offset + this.input.length;\n      return new EmptyExpr(\n          this.span(artificialStart, artificialEnd),\n          this.sourceSpan(artificialStart, artificialEnd));\n    }\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), this.sourceSpan(start), exprs);\n  }\n\n  parsePipe(): AST {\n    const start = this.inputIndex;\n    let result = this.parseExpression();\n    if (this.consumeOptionalOperator('|')) {\n      if (this.parseAction) {\n        this.error('Cannot have a pipe in an action expression');\n      }\n\n      do {\n        const nameStart = this.inputIndex;\n        let nameId = this.expectIdentifierOrKeyword();\n        let nameSpan: AbsoluteSourceSpan;\n        let fullSpanEnd: number|undefined = undefined;\n        if (nameId !== null) {\n          nameSpan = this.sourceSpan(nameStart);\n        } else {\n          // No valid identifier was found, so we'll assume an empty pipe name ('').\n          nameId = '';\n\n          // However, there may have been whitespace present between the pipe character and the next\n          // token in the sequence (or the end of input). We want to track this whitespace so that\n          // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n          // whitespace beyond it. Another way of thinking about this is that the zero-length name\n          // is assumed to be at the end of any whitespace beyond the pipe character.\n          //\n          // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n          // beginning of the next token, or until the end of input if the next token is EOF.\n          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n\n          // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n          // beyond the pipe character.\n          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n        }\n\n        const args: AST[] = [];\n        while (this.consumeOptionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n\n          // If there are additional expressions beyond the name, then the artificial end for the\n          // name is no longer relevant.\n        }\n        result = new BindingPipe(\n            this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n      } while (this.consumeOptionalOperator('|'));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.consumeOptionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.consumeOptionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    const start = this.inputIndex;\n    let result = this.parseLogicalAnd();\n    while (this.consumeOptionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    const start = this.inputIndex;\n    let result = this.parseNullishCoalescing();\n    while (this.consumeOptionalOperator('&&')) {\n      const right = this.parseNullishCoalescing();\n      result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n    }\n    return result;\n  }\n\n  parseNullishCoalescing(): AST {\n    // '??'\n    const start = this.inputIndex;\n    let result = this.parseEquality();\n    while (this.consumeOptionalOperator('??')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    const start = this.inputIndex;\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    const start = this.inputIndex;\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    const start = this.inputIndex;\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    const start = this.inputIndex;\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          let right = this.parsePrefix();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    const start = this.inputIndex;\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.consumeOptionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMember(result, start, false);\n      } else if (this.consumeOptionalOperator('?.')) {\n        if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n          result = this.parseCall(result, start, true);\n        } else {\n          result = this.consumeOptionalCharacter(chars.$LBRACKET) ?\n              this.parseKeyedReadOrWrite(result, start, true) :\n              this.parseAccessMember(result, start, true);\n        }\n      } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n        result = this.parseKeyedReadOrWrite(result, start, false);\n      } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n        result = this.parseCall(result, start, false);\n      } else if (this.consumeOptionalOperator('!')) {\n        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ThisReceiver(this.span(start), this.sourceSpan(start));\n    } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMember(\n          new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n\n    } else if (this.next.isPrivateIdentifier()) {\n      this._reportErrorForPrivateIdentifier(this.next, null);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n\n    do {\n      if (!this.next.isCharacter(terminator)) {\n        result.push(this.parsePipe());\n      } else {\n        break;\n      }\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.consumeOptionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const keyStart = this.inputIndex;\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n\n        // Properties with quoted keys can't use the shorthand syntax.\n        if (quoted) {\n          this.expectCharacter(chars.$COLON);\n          values.push(this.parsePipe());\n        } else if (this.consumeOptionalCharacter(chars.$COLON)) {\n          values.push(this.parsePipe());\n        } else {\n          const span = this.span(keyStart);\n          const sourceSpan = this.sourceSpan(keyStart);\n          values.push(new PropertyRead(\n              span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n        }\n      } while (this.consumeOptionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n  }\n\n  parseAccessMember(readReceiver: AST, start: number, isSafe: boolean): AST {\n    const nameStart = this.inputIndex;\n    const id = this.withContext(ParseContextFlags.Writable, () => {\n      const id = this.expectIdentifierOrKeyword() ?? '';\n      if (id.length === 0) {\n        this.error(`Expected identifier for property access`, readReceiver.span.end);\n      }\n      return id;\n    });\n    const nameSpan = this.sourceSpan(nameStart);\n    let receiver: AST;\n\n    if (isSafe) {\n      if (this.consumeOptionalOperator('=')) {\n        this.error('The \\'?.\\' operator cannot be used in the assignment');\n        receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        receiver = new SafePropertyRead(\n            this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    } else {\n      if (this.consumeOptionalOperator('=')) {\n        if (!this.parseAction) {\n          this.error('Bindings cannot contain assignments');\n          return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n\n        const value = this.parseConditional();\n        receiver = new PropertyWrite(\n            this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);\n      } else {\n        receiver =\n            new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    }\n\n    return receiver;\n  }\n\n  parseCall(receiver: AST, start: number, isSafe: boolean): AST {\n    const argumentStart = this.inputIndex;\n    this.rparensExpected++;\n    const args = this.parseCallArguments();\n    const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n    this.expectCharacter(chars.$RPAREN);\n    this.rparensExpected--;\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) :\n                    new Call(span, sourceSpan, receiver, args, argumentSpan);\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * Parses an identifier, a keyword, a string with an optional `-` in between,\n   * and returns the string along with its absolute source span.\n   */\n  expectTemplateBindingKey(): TemplateBindingIdentifier {\n    let result = '';\n    let operatorFound = false;\n    const start = this.currentAbsoluteOffset;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.consumeOptionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n    return {\n      source: result,\n      span: new AbsoluteSourceSpan(start, start + result.length),\n    };\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```\n   *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n   * ```\n   * contains five bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   * 4. i -> NgForOfContext.index\n   * 5. ngForTrackBy -> func\n   *\n   * For a full description of the microsyntax grammar, see\n   * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n   *\n   * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n   * without the *, along with its absolute span.\n   */\n  parseTemplateBindings(templateKey: TemplateBindingIdentifier): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n\n    // The first binding is for the template key itself\n    // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n    // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n    bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n\n    while (this.index < this.tokens.length) {\n      // If it starts with 'let', then this must be variable declaration\n      const letBinding = this.parseLetBinding();\n      if (letBinding) {\n        bindings.push(letBinding);\n      } else {\n        // Two possible cases here, either `value \"as\" key` or\n        // \"directive-keyword expression\". We don't know which case, but both\n        // \"value\" and \"directive-keyword\" are template binding key, so consume\n        // the key first.\n        const key = this.expectTemplateBindingKey();\n        // Peek at the next token, if it is \"as\" then this must be variable\n        // declaration.\n        const binding = this.parseAsBinding(key);\n        if (binding) {\n          bindings.push(binding);\n        } else {\n          // Otherwise the key must be a directive keyword, like \"of\". Transform\n          // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n          key.source =\n              templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n          bindings.push(...this.parseDirectiveKeywordBindings(key));\n        }\n      }\n      this.consumeStatementTerminator();\n    }\n\n    return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n  }\n\n  parseKeyedReadOrWrite(receiver: AST, start: number, isSafe: boolean): AST {\n    return this.withContext(ParseContextFlags.Writable, () => {\n      this.rbracketsExpected++;\n      const key = this.parsePipe();\n      if (key instanceof EmptyExpr) {\n        this.error(`Key access cannot be empty`);\n      }\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      if (this.consumeOptionalOperator('=')) {\n        if (isSafe) {\n          this.error('The \\'?.\\' operator cannot be used in the assignment');\n        } else {\n          const value = this.parseConditional();\n          return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);\n        }\n      } else {\n        return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) :\n                        new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n      }\n\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    });\n  }\n\n  /**\n   * Parse a directive keyword, followed by a mandatory expression.\n   * For example, \"of items\", \"trackBy: func\".\n   * The bindings are: ngForOf -> items, ngForTrackBy -> func\n   * There could be an optional \"as\" binding that follows the expression.\n   * For example,\n   * ```\n   *   *ngFor=\"let item of items | slice:0:1 as collection\".\n   *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n   *               keyword    bound target   optional 'as' binding\n   * ```\n   *\n   * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n   * absolute span.\n   */\n  private parseDirectiveKeywordBindings(key: TemplateBindingIdentifier): TemplateBinding[] {\n    const bindings: TemplateBinding[] = [];\n    this.consumeOptionalCharacter(chars.$COLON);  // trackBy: trackByFunction\n    const value = this.getDirectiveBoundTarget();\n    let spanEnd = this.currentAbsoluteOffset;\n    // The binding could optionally be followed by \"as\". For example,\n    // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n    // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n    // 'key' in the current context now becomes the \"value\" in the next binding.\n    const asBinding = this.parseAsBinding(key);\n    if (!asBinding) {\n      this.consumeStatementTerminator();\n      spanEnd = this.currentAbsoluteOffset;\n    }\n    const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n    bindings.push(new ExpressionBinding(sourceSpan, key, value));\n    if (asBinding) {\n      bindings.push(asBinding);\n    }\n    return bindings;\n  }\n\n  /**\n   * Return the expression AST for the bound target of a directive keyword\n   * binding. For example,\n   * ```\n   *   *ngIf=\"condition | pipe\"\n   *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n   *   *ngFor=\"let item of items\"\n   *                       ^^^^^ bound target for \"ngForOf\"\n   * ```\n   */\n  private getDirectiveBoundTarget(): ASTWithSource|null {\n    if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n      return null;\n    }\n    const ast = this.parsePipe();  // example: \"condition | async\"\n    const {start, end} = ast.span;\n    const value = this.input.substring(start, end);\n    return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n  }\n\n  /**\n   * Return the binding for a variable declared using `as`. Note that the order\n   * of the key-value pair in this declaration is reversed. For example,\n   * ```\n   *   *ngFor=\"let item of items; index as i\"\n   *                              ^^^^^    ^\n   *                              value    key\n   * ```\n   *\n   * @param value name of the value in the declaration, \"ngIf\" in the example\n   * above, along with its absolute span.\n   */\n  private parseAsBinding(value: TemplateBindingIdentifier): TemplateBinding|null {\n    if (!this.peekKeywordAs()) {\n      return null;\n    }\n    this.advance();  // consume the 'as' keyword\n    const key = this.expectTemplateBindingKey();\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Return the binding for a variable declared using `let`. For example,\n   * ```\n   *   *ngFor=\"let item of items; let i=index;\"\n   *           ^^^^^^^^           ^^^^^^^^^^^\n   * ```\n   * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n   * In the second binding, `i` is bound to `NgForOfContext.index`.\n   */\n  private parseLetBinding(): TemplateBinding|null {\n    if (!this.peekKeywordLet()) {\n      return null;\n    }\n    const spanStart = this.currentAbsoluteOffset;\n    this.advance();  // consume the 'let' keyword\n    const key = this.expectTemplateBindingKey();\n    let value: TemplateBindingIdentifier|null = null;\n    if (this.consumeOptionalOperator('=')) {\n      value = this.expectTemplateBindingKey();\n    }\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Consume the optional statement terminator: semicolon or comma.\n   */\n  private consumeStatementTerminator() {\n    this.consumeOptionalCharacter(chars.$SEMICOLON) || this.consumeOptionalCharacter(chars.$COMMA);\n  }\n\n  /**\n   * Records an error and skips over the token stream until reaching a recoverable point. See\n   * `this.skip` for more details on token skipping.\n   */\n  error(message: string, index: number|null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number|null = null) {\n    if (index == null) index = this.index;\n    return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n                                          `at the end of the expression`;\n  }\n\n  /**\n   * Records an error for an unexpected private identifier being discovered.\n   * @param token Token representing a private identifier.\n   * @param extraMessage Optional additional message being appended to the error.\n   */\n  private _reportErrorForPrivateIdentifier(token: Token, extraMessage: string|null) {\n    let errorMessage =\n        `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n    if (extraMessage !== null) {\n      errorMessage += `, ${extraMessage}`;\n    }\n    this.error(errorMessage);\n  }\n\n  /**\n   * Error recovery should skip tokens until it encounters a recovery point.\n   *\n   * The following are treated as unconditional recovery points:\n   *   - end of input\n   *   - ';' (parseChain() is always the root production, and it expects a ';')\n   *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n   *\n   * The following are conditional recovery points:\n   *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n   *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n   *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n   *       an '(' <expr> ')' production).\n   *       The recovery points of grouping symbols must be conditional as they must be skipped if\n   *       none of the calling productions are not expecting the closing token else we will never\n   *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n   *       That is, we skip a closing symbol if we are not in a grouping production.\n   *   - '=' in a `Writable` context\n   *     - In this context, we are able to recover after seeing the `=` operator, which\n   *       signals the presence of an independent rvalue expression following the `=` operator.\n   *\n   * If a production expects one of these token it increments the corresponding nesting count,\n   * and then decrements it just prior to checking if the token is in the input.\n   */\n  private skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n           !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n           (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) &&\n           (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n      if (this.next.isError()) {\n        this.errors.push(\n            new ParserError(this.next.toString()!, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n  errors: string[] = [];\n\n  override visitPipe() {\n    this.errors.push('pipes');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from './tokens';\n\ninterface BaseNode {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context: any): any;\n}\n\nexport type Node = Attribute|Comment|Element|Expansion|ExpansionCase|Text;\n\nexport abstract class NodeWithI18n implements BaseNode {\n  constructor(public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  abstract visit(visitor: Visitor, context: any): any;\n}\n\nexport class Text extends NodeWithI18n {\n  constructor(\n      public value: string, sourceSpan: ParseSourceSpan, public tokens: InterpolatedTextToken[],\n      i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\nexport class Expansion extends NodeWithI18n {\n  constructor(\n      public switchValue: string, public type: string, public cases: ExpansionCase[],\n      sourceSpan: ParseSourceSpan, public switchValueSourceSpan: ParseSourceSpan, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansion(this, context);\n  }\n}\n\nexport class ExpansionCase implements BaseNode {\n  constructor(\n      public value: string, public expression: Node[], public sourceSpan: ParseSourceSpan,\n      public valueSourceSpan: ParseSourceSpan, public expSourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\n\nexport class Attribute extends NodeWithI18n {\n  constructor(\n      public name: string, public value: string, sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan: ParseSourceSpan|undefined,\n      public valueTokens: InterpolatedAttributeToken[]|undefined, i18n: I18nMeta|undefined) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitAttribute(this, context);\n  }\n}\n\nexport class Element extends NodeWithI18n {\n  constructor(\n      public name: string, public attrs: Attribute[], public children: Node[],\n      sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null = null, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\nexport class Comment implements BaseNode {\n  constructor(public value: string|null, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitComment(this, context);\n  }\n}\n\nexport interface Visitor {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node, context: any): any;\n\n  visitElement(element: Element, context: any): any;\n  visitAttribute(attribute: Attribute, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n  visitExpansion(expansion: Expansion, context: any): any;\n  visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\n}\n\nexport function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {\n  const result: any[] = [];\n\n  const visit = visitor.visit ?\n      (ast: Node) => visitor.visit!(ast, context) || ast.visit(visitor, context) :\n      (ast: Node) => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nexport class RecursiveVisitor implements Visitor {\n  constructor() {}\n\n  visitElement(ast: Element, context: any): any {\n    this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.children);\n    });\n  }\n\n  visitAttribute(ast: Attribute, context: any): any {}\n  visitText(ast: Text, context: any): any {}\n  visitComment(ast: Comment, context: any): any {}\n\n  visitExpansion(ast: Expansion, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.cases);\n    });\n  }\n\n  visitExpansionCase(ast: ExpansionCase, context: any): any {}\n\n  private visitChildren<T extends Node>(\n      context: any, cb: (visit: (<V extends Node>(children: V[]|undefined) => void)) => void) {\n    let results: any[][] = [];\n    let t = this;\n    function visit<T extends Node>(children: T[]|undefined) {\n      if (children) results.push(visitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Mapping between all HTML entity names and their unicode representation.\n// Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping\n// the `&` and `;` from the keys and removing the duplicates.\n// see https://www.w3.org/TR/html51/syntax.html#named-character-references\nexport const NAMED_ENTITIES: Record<string, string> = {\n  'AElig': '\\u00C6',\n  'AMP': '\\u0026',\n  'amp': '\\u0026',\n  'Aacute': '\\u00C1',\n  'Abreve': '\\u0102',\n  'Acirc': '\\u00C2',\n  'Acy': '\\u0410',\n  'Afr': '\\uD835\\uDD04',\n  'Agrave': '\\u00C0',\n  'Alpha': '\\u0391',\n  'Amacr': '\\u0100',\n  'And': '\\u2A53',\n  'Aogon': '\\u0104',\n  'Aopf': '\\uD835\\uDD38',\n  'ApplyFunction': '\\u2061',\n  'af': '\\u2061',\n  'Aring': '\\u00C5',\n  'angst': '\\u00C5',\n  'Ascr': '\\uD835\\uDC9C',\n  'Assign': '\\u2254',\n  'colone': '\\u2254',\n  'coloneq': '\\u2254',\n  'Atilde': '\\u00C3',\n  'Auml': '\\u00C4',\n  'Backslash': '\\u2216',\n  'setminus': '\\u2216',\n  'setmn': '\\u2216',\n  'smallsetminus': '\\u2216',\n  'ssetmn': '\\u2216',\n  'Barv': '\\u2AE7',\n  'Barwed': '\\u2306',\n  'doublebarwedge': '\\u2306',\n  'Bcy': '\\u0411',\n  'Because': '\\u2235',\n  'becaus': '\\u2235',\n  'because': '\\u2235',\n  'Bernoullis': '\\u212C',\n  'Bscr': '\\u212C',\n  'bernou': '\\u212C',\n  'Beta': '\\u0392',\n  'Bfr': '\\uD835\\uDD05',\n  'Bopf': '\\uD835\\uDD39',\n  'Breve': '\\u02D8',\n  'breve': '\\u02D8',\n  'Bumpeq': '\\u224E',\n  'HumpDownHump': '\\u224E',\n  'bump': '\\u224E',\n  'CHcy': '\\u0427',\n  'COPY': '\\u00A9',\n  'copy': '\\u00A9',\n  'Cacute': '\\u0106',\n  'Cap': '\\u22D2',\n  'CapitalDifferentialD': '\\u2145',\n  'DD': '\\u2145',\n  'Cayleys': '\\u212D',\n  'Cfr': '\\u212D',\n  'Ccaron': '\\u010C',\n  'Ccedil': '\\u00C7',\n  'Ccirc': '\\u0108',\n  'Cconint': '\\u2230',\n  'Cdot': '\\u010A',\n  'Cedilla': '\\u00B8',\n  'cedil': '\\u00B8',\n  'CenterDot': '\\u00B7',\n  'centerdot': '\\u00B7',\n  'middot': '\\u00B7',\n  'Chi': '\\u03A7',\n  'CircleDot': '\\u2299',\n  'odot': '\\u2299',\n  'CircleMinus': '\\u2296',\n  'ominus': '\\u2296',\n  'CirclePlus': '\\u2295',\n  'oplus': '\\u2295',\n  'CircleTimes': '\\u2297',\n  'otimes': '\\u2297',\n  'ClockwiseContourIntegral': '\\u2232',\n  'cwconint': '\\u2232',\n  'CloseCurlyDoubleQuote': '\\u201D',\n  'rdquo': '\\u201D',\n  'rdquor': '\\u201D',\n  'CloseCurlyQuote': '\\u2019',\n  'rsquo': '\\u2019',\n  'rsquor': '\\u2019',\n  'Colon': '\\u2237',\n  'Proportion': '\\u2237',\n  'Colone': '\\u2A74',\n  'Congruent': '\\u2261',\n  'equiv': '\\u2261',\n  'Conint': '\\u222F',\n  'DoubleContourIntegral': '\\u222F',\n  'ContourIntegral': '\\u222E',\n  'conint': '\\u222E',\n  'oint': '\\u222E',\n  'Copf': '\\u2102',\n  'complexes': '\\u2102',\n  'Coproduct': '\\u2210',\n  'coprod': '\\u2210',\n  'CounterClockwiseContourIntegral': '\\u2233',\n  'awconint': '\\u2233',\n  'Cross': '\\u2A2F',\n  'Cscr': '\\uD835\\uDC9E',\n  'Cup': '\\u22D3',\n  'CupCap': '\\u224D',\n  'asympeq': '\\u224D',\n  'DDotrahd': '\\u2911',\n  'DJcy': '\\u0402',\n  'DScy': '\\u0405',\n  'DZcy': '\\u040F',\n  'Dagger': '\\u2021',\n  'ddagger': '\\u2021',\n  'Darr': '\\u21A1',\n  'Dashv': '\\u2AE4',\n  'DoubleLeftTee': '\\u2AE4',\n  'Dcaron': '\\u010E',\n  'Dcy': '\\u0414',\n  'Del': '\\u2207',\n  'nabla': '\\u2207',\n  'Delta': '\\u0394',\n  'Dfr': '\\uD835\\uDD07',\n  'DiacriticalAcute': '\\u00B4',\n  'acute': '\\u00B4',\n  'DiacriticalDot': '\\u02D9',\n  'dot': '\\u02D9',\n  'DiacriticalDoubleAcute': '\\u02DD',\n  'dblac': '\\u02DD',\n  'DiacriticalGrave': '\\u0060',\n  'grave': '\\u0060',\n  'DiacriticalTilde': '\\u02DC',\n  'tilde': '\\u02DC',\n  'Diamond': '\\u22C4',\n  'diam': '\\u22C4',\n  'diamond': '\\u22C4',\n  'DifferentialD': '\\u2146',\n  'dd': '\\u2146',\n  'Dopf': '\\uD835\\uDD3B',\n  'Dot': '\\u00A8',\n  'DoubleDot': '\\u00A8',\n  'die': '\\u00A8',\n  'uml': '\\u00A8',\n  'DotDot': '\\u20DC',\n  'DotEqual': '\\u2250',\n  'doteq': '\\u2250',\n  'esdot': '\\u2250',\n  'DoubleDownArrow': '\\u21D3',\n  'Downarrow': '\\u21D3',\n  'dArr': '\\u21D3',\n  'DoubleLeftArrow': '\\u21D0',\n  'Leftarrow': '\\u21D0',\n  'lArr': '\\u21D0',\n  'DoubleLeftRightArrow': '\\u21D4',\n  'Leftrightarrow': '\\u21D4',\n  'hArr': '\\u21D4',\n  'iff': '\\u21D4',\n  'DoubleLongLeftArrow': '\\u27F8',\n  'Longleftarrow': '\\u27F8',\n  'xlArr': '\\u27F8',\n  'DoubleLongLeftRightArrow': '\\u27FA',\n  'Longleftrightarrow': '\\u27FA',\n  'xhArr': '\\u27FA',\n  'DoubleLongRightArrow': '\\u27F9',\n  'Longrightarrow': '\\u27F9',\n  'xrArr': '\\u27F9',\n  'DoubleRightArrow': '\\u21D2',\n  'Implies': '\\u21D2',\n  'Rightarrow': '\\u21D2',\n  'rArr': '\\u21D2',\n  'DoubleRightTee': '\\u22A8',\n  'vDash': '\\u22A8',\n  'DoubleUpArrow': '\\u21D1',\n  'Uparrow': '\\u21D1',\n  'uArr': '\\u21D1',\n  'DoubleUpDownArrow': '\\u21D5',\n  'Updownarrow': '\\u21D5',\n  'vArr': '\\u21D5',\n  'DoubleVerticalBar': '\\u2225',\n  'par': '\\u2225',\n  'parallel': '\\u2225',\n  'shortparallel': '\\u2225',\n  'spar': '\\u2225',\n  'DownArrow': '\\u2193',\n  'ShortDownArrow': '\\u2193',\n  'darr': '\\u2193',\n  'downarrow': '\\u2193',\n  'DownArrowBar': '\\u2913',\n  'DownArrowUpArrow': '\\u21F5',\n  'duarr': '\\u21F5',\n  'DownBreve': '\\u0311',\n  'DownLeftRightVector': '\\u2950',\n  'DownLeftTeeVector': '\\u295E',\n  'DownLeftVector': '\\u21BD',\n  'leftharpoondown': '\\u21BD',\n  'lhard': '\\u21BD',\n  'DownLeftVectorBar': '\\u2956',\n  'DownRightTeeVector': '\\u295F',\n  'DownRightVector': '\\u21C1',\n  'rhard': '\\u21C1',\n  'rightharpoondown': '\\u21C1',\n  'DownRightVectorBar': '\\u2957',\n  'DownTee': '\\u22A4',\n  'top': '\\u22A4',\n  'DownTeeArrow': '\\u21A7',\n  'mapstodown': '\\u21A7',\n  'Dscr': '\\uD835\\uDC9F',\n  'Dstrok': '\\u0110',\n  'ENG': '\\u014A',\n  'ETH': '\\u00D0',\n  'Eacute': '\\u00C9',\n  'Ecaron': '\\u011A',\n  'Ecirc': '\\u00CA',\n  'Ecy': '\\u042D',\n  'Edot': '\\u0116',\n  'Efr': '\\uD835\\uDD08',\n  'Egrave': '\\u00C8',\n  'Element': '\\u2208',\n  'in': '\\u2208',\n  'isin': '\\u2208',\n  'isinv': '\\u2208',\n  'Emacr': '\\u0112',\n  'EmptySmallSquare': '\\u25FB',\n  'EmptyVerySmallSquare': '\\u25AB',\n  'Eogon': '\\u0118',\n  'Eopf': '\\uD835\\uDD3C',\n  'Epsilon': '\\u0395',\n  'Equal': '\\u2A75',\n  'EqualTilde': '\\u2242',\n  'eqsim': '\\u2242',\n  'esim': '\\u2242',\n  'Equilibrium': '\\u21CC',\n  'rightleftharpoons': '\\u21CC',\n  'rlhar': '\\u21CC',\n  'Escr': '\\u2130',\n  'expectation': '\\u2130',\n  'Esim': '\\u2A73',\n  'Eta': '\\u0397',\n  'Euml': '\\u00CB',\n  'Exists': '\\u2203',\n  'exist': '\\u2203',\n  'ExponentialE': '\\u2147',\n  'ee': '\\u2147',\n  'exponentiale': '\\u2147',\n  'Fcy': '\\u0424',\n  'Ffr': '\\uD835\\uDD09',\n  'FilledSmallSquare': '\\u25FC',\n  'FilledVerySmallSquare': '\\u25AA',\n  'blacksquare': '\\u25AA',\n  'squarf': '\\u25AA',\n  'squf': '\\u25AA',\n  'Fopf': '\\uD835\\uDD3D',\n  'ForAll': '\\u2200',\n  'forall': '\\u2200',\n  'Fouriertrf': '\\u2131',\n  'Fscr': '\\u2131',\n  'GJcy': '\\u0403',\n  'GT': '\\u003E',\n  'gt': '\\u003E',\n  'Gamma': '\\u0393',\n  'Gammad': '\\u03DC',\n  'Gbreve': '\\u011E',\n  'Gcedil': '\\u0122',\n  'Gcirc': '\\u011C',\n  'Gcy': '\\u0413',\n  'Gdot': '\\u0120',\n  'Gfr': '\\uD835\\uDD0A',\n  'Gg': '\\u22D9',\n  'ggg': '\\u22D9',\n  'Gopf': '\\uD835\\uDD3E',\n  'GreaterEqual': '\\u2265',\n  'ge': '\\u2265',\n  'geq': '\\u2265',\n  'GreaterEqualLess': '\\u22DB',\n  'gel': '\\u22DB',\n  'gtreqless': '\\u22DB',\n  'GreaterFullEqual': '\\u2267',\n  'gE': '\\u2267',\n  'geqq': '\\u2267',\n  'GreaterGreater': '\\u2AA2',\n  'GreaterLess': '\\u2277',\n  'gl': '\\u2277',\n  'gtrless': '\\u2277',\n  'GreaterSlantEqual': '\\u2A7E',\n  'geqslant': '\\u2A7E',\n  'ges': '\\u2A7E',\n  'GreaterTilde': '\\u2273',\n  'gsim': '\\u2273',\n  'gtrsim': '\\u2273',\n  'Gscr': '\\uD835\\uDCA2',\n  'Gt': '\\u226B',\n  'NestedGreaterGreater': '\\u226B',\n  'gg': '\\u226B',\n  'HARDcy': '\\u042A',\n  'Hacek': '\\u02C7',\n  'caron': '\\u02C7',\n  'Hat': '\\u005E',\n  'Hcirc': '\\u0124',\n  'Hfr': '\\u210C',\n  'Poincareplane': '\\u210C',\n  'HilbertSpace': '\\u210B',\n  'Hscr': '\\u210B',\n  'hamilt': '\\u210B',\n  'Hopf': '\\u210D',\n  'quaternions': '\\u210D',\n  'HorizontalLine': '\\u2500',\n  'boxh': '\\u2500',\n  'Hstrok': '\\u0126',\n  'HumpEqual': '\\u224F',\n  'bumpe': '\\u224F',\n  'bumpeq': '\\u224F',\n  'IEcy': '\\u0415',\n  'IJlig': '\\u0132',\n  'IOcy': '\\u0401',\n  'Iacute': '\\u00CD',\n  'Icirc': '\\u00CE',\n  'Icy': '\\u0418',\n  'Idot': '\\u0130',\n  'Ifr': '\\u2111',\n  'Im': '\\u2111',\n  'image': '\\u2111',\n  'imagpart': '\\u2111',\n  'Igrave': '\\u00CC',\n  'Imacr': '\\u012A',\n  'ImaginaryI': '\\u2148',\n  'ii': '\\u2148',\n  'Int': '\\u222C',\n  'Integral': '\\u222B',\n  'int': '\\u222B',\n  'Intersection': '\\u22C2',\n  'bigcap': '\\u22C2',\n  'xcap': '\\u22C2',\n  'InvisibleComma': '\\u2063',\n  'ic': '\\u2063',\n  'InvisibleTimes': '\\u2062',\n  'it': '\\u2062',\n  'Iogon': '\\u012E',\n  'Iopf': '\\uD835\\uDD40',\n  'Iota': '\\u0399',\n  'Iscr': '\\u2110',\n  'imagline': '\\u2110',\n  'Itilde': '\\u0128',\n  'Iukcy': '\\u0406',\n  'Iuml': '\\u00CF',\n  'Jcirc': '\\u0134',\n  'Jcy': '\\u0419',\n  'Jfr': '\\uD835\\uDD0D',\n  'Jopf': '\\uD835\\uDD41',\n  'Jscr': '\\uD835\\uDCA5',\n  'Jsercy': '\\u0408',\n  'Jukcy': '\\u0404',\n  'KHcy': '\\u0425',\n  'KJcy': '\\u040C',\n  'Kappa': '\\u039A',\n  'Kcedil': '\\u0136',\n  'Kcy': '\\u041A',\n  'Kfr': '\\uD835\\uDD0E',\n  'Kopf': '\\uD835\\uDD42',\n  'Kscr': '\\uD835\\uDCA6',\n  'LJcy': '\\u0409',\n  'LT': '\\u003C',\n  'lt': '\\u003C',\n  'Lacute': '\\u0139',\n  'Lambda': '\\u039B',\n  'Lang': '\\u27EA',\n  'Laplacetrf': '\\u2112',\n  'Lscr': '\\u2112',\n  'lagran': '\\u2112',\n  'Larr': '\\u219E',\n  'twoheadleftarrow': '\\u219E',\n  'Lcaron': '\\u013D',\n  'Lcedil': '\\u013B',\n  'Lcy': '\\u041B',\n  'LeftAngleBracket': '\\u27E8',\n  'lang': '\\u27E8',\n  'langle': '\\u27E8',\n  'LeftArrow': '\\u2190',\n  'ShortLeftArrow': '\\u2190',\n  'larr': '\\u2190',\n  'leftarrow': '\\u2190',\n  'slarr': '\\u2190',\n  'LeftArrowBar': '\\u21E4',\n  'larrb': '\\u21E4',\n  'LeftArrowRightArrow': '\\u21C6',\n  'leftrightarrows': '\\u21C6',\n  'lrarr': '\\u21C6',\n  'LeftCeiling': '\\u2308',\n  'lceil': '\\u2308',\n  'LeftDoubleBracket': '\\u27E6',\n  'lobrk': '\\u27E6',\n  'LeftDownTeeVector': '\\u2961',\n  'LeftDownVector': '\\u21C3',\n  'dharl': '\\u21C3',\n  'downharpoonleft': '\\u21C3',\n  'LeftDownVectorBar': '\\u2959',\n  'LeftFloor': '\\u230A',\n  'lfloor': '\\u230A',\n  'LeftRightArrow': '\\u2194',\n  'harr': '\\u2194',\n  'leftrightarrow': '\\u2194',\n  'LeftRightVector': '\\u294E',\n  'LeftTee': '\\u22A3',\n  'dashv': '\\u22A3',\n  'LeftTeeArrow': '\\u21A4',\n  'mapstoleft': '\\u21A4',\n  'LeftTeeVector': '\\u295A',\n  'LeftTriangle': '\\u22B2',\n  'vartriangleleft': '\\u22B2',\n  'vltri': '\\u22B2',\n  'LeftTriangleBar': '\\u29CF',\n  'LeftTriangleEqual': '\\u22B4',\n  'ltrie': '\\u22B4',\n  'trianglelefteq': '\\u22B4',\n  'LeftUpDownVector': '\\u2951',\n  'LeftUpTeeVector': '\\u2960',\n  'LeftUpVector': '\\u21BF',\n  'uharl': '\\u21BF',\n  'upharpoonleft': '\\u21BF',\n  'LeftUpVectorBar': '\\u2958',\n  'LeftVector': '\\u21BC',\n  'leftharpoonup': '\\u21BC',\n  'lharu': '\\u21BC',\n  'LeftVectorBar': '\\u2952',\n  'LessEqualGreater': '\\u22DA',\n  'leg': '\\u22DA',\n  'lesseqgtr': '\\u22DA',\n  'LessFullEqual': '\\u2266',\n  'lE': '\\u2266',\n  'leqq': '\\u2266',\n  'LessGreater': '\\u2276',\n  'lessgtr': '\\u2276',\n  'lg': '\\u2276',\n  'LessLess': '\\u2AA1',\n  'LessSlantEqual': '\\u2A7D',\n  'leqslant': '\\u2A7D',\n  'les': '\\u2A7D',\n  'LessTilde': '\\u2272',\n  'lesssim': '\\u2272',\n  'lsim': '\\u2272',\n  'Lfr': '\\uD835\\uDD0F',\n  'Ll': '\\u22D8',\n  'Lleftarrow': '\\u21DA',\n  'lAarr': '\\u21DA',\n  'Lmidot': '\\u013F',\n  'LongLeftArrow': '\\u27F5',\n  'longleftarrow': '\\u27F5',\n  'xlarr': '\\u27F5',\n  'LongLeftRightArrow': '\\u27F7',\n  'longleftrightarrow': '\\u27F7',\n  'xharr': '\\u27F7',\n  'LongRightArrow': '\\u27F6',\n  'longrightarrow': '\\u27F6',\n  'xrarr': '\\u27F6',\n  'Lopf': '\\uD835\\uDD43',\n  'LowerLeftArrow': '\\u2199',\n  'swarr': '\\u2199',\n  'swarrow': '\\u2199',\n  'LowerRightArrow': '\\u2198',\n  'searr': '\\u2198',\n  'searrow': '\\u2198',\n  'Lsh': '\\u21B0',\n  'lsh': '\\u21B0',\n  'Lstrok': '\\u0141',\n  'Lt': '\\u226A',\n  'NestedLessLess': '\\u226A',\n  'll': '\\u226A',\n  'Map': '\\u2905',\n  'Mcy': '\\u041C',\n  'MediumSpace': '\\u205F',\n  'Mellintrf': '\\u2133',\n  'Mscr': '\\u2133',\n  'phmmat': '\\u2133',\n  'Mfr': '\\uD835\\uDD10',\n  'MinusPlus': '\\u2213',\n  'mnplus': '\\u2213',\n  'mp': '\\u2213',\n  'Mopf': '\\uD835\\uDD44',\n  'Mu': '\\u039C',\n  'NJcy': '\\u040A',\n  'Nacute': '\\u0143',\n  'Ncaron': '\\u0147',\n  'Ncedil': '\\u0145',\n  'Ncy': '\\u041D',\n  'NegativeMediumSpace': '\\u200B',\n  'NegativeThickSpace': '\\u200B',\n  'NegativeThinSpace': '\\u200B',\n  'NegativeVeryThinSpace': '\\u200B',\n  'ZeroWidthSpace': '\\u200B',\n  'NewLine': '\\u000A',\n  'Nfr': '\\uD835\\uDD11',\n  'NoBreak': '\\u2060',\n  'NonBreakingSpace': '\\u00A0',\n  'nbsp': '\\u00A0',\n  'Nopf': '\\u2115',\n  'naturals': '\\u2115',\n  'Not': '\\u2AEC',\n  'NotCongruent': '\\u2262',\n  'nequiv': '\\u2262',\n  'NotCupCap': '\\u226D',\n  'NotDoubleVerticalBar': '\\u2226',\n  'npar': '\\u2226',\n  'nparallel': '\\u2226',\n  'nshortparallel': '\\u2226',\n  'nspar': '\\u2226',\n  'NotElement': '\\u2209',\n  'notin': '\\u2209',\n  'notinva': '\\u2209',\n  'NotEqual': '\\u2260',\n  'ne': '\\u2260',\n  'NotEqualTilde': '\\u2242\\u0338',\n  'nesim': '\\u2242\\u0338',\n  'NotExists': '\\u2204',\n  'nexist': '\\u2204',\n  'nexists': '\\u2204',\n  'NotGreater': '\\u226F',\n  'ngt': '\\u226F',\n  'ngtr': '\\u226F',\n  'NotGreaterEqual': '\\u2271',\n  'nge': '\\u2271',\n  'ngeq': '\\u2271',\n  'NotGreaterFullEqual': '\\u2267\\u0338',\n  'ngE': '\\u2267\\u0338',\n  'ngeqq': '\\u2267\\u0338',\n  'NotGreaterGreater': '\\u226B\\u0338',\n  'nGtv': '\\u226B\\u0338',\n  'NotGreaterLess': '\\u2279',\n  'ntgl': '\\u2279',\n  'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n  'ngeqslant': '\\u2A7E\\u0338',\n  'nges': '\\u2A7E\\u0338',\n  'NotGreaterTilde': '\\u2275',\n  'ngsim': '\\u2275',\n  'NotHumpDownHump': '\\u224E\\u0338',\n  'nbump': '\\u224E\\u0338',\n  'NotHumpEqual': '\\u224F\\u0338',\n  'nbumpe': '\\u224F\\u0338',\n  'NotLeftTriangle': '\\u22EA',\n  'nltri': '\\u22EA',\n  'ntriangleleft': '\\u22EA',\n  'NotLeftTriangleBar': '\\u29CF\\u0338',\n  'NotLeftTriangleEqual': '\\u22EC',\n  'nltrie': '\\u22EC',\n  'ntrianglelefteq': '\\u22EC',\n  'NotLess': '\\u226E',\n  'nless': '\\u226E',\n  'nlt': '\\u226E',\n  'NotLessEqual': '\\u2270',\n  'nle': '\\u2270',\n  'nleq': '\\u2270',\n  'NotLessGreater': '\\u2278',\n  'ntlg': '\\u2278',\n  'NotLessLess': '\\u226A\\u0338',\n  'nLtv': '\\u226A\\u0338',\n  'NotLessSlantEqual': '\\u2A7D\\u0338',\n  'nleqslant': '\\u2A7D\\u0338',\n  'nles': '\\u2A7D\\u0338',\n  'NotLessTilde': '\\u2274',\n  'nlsim': '\\u2274',\n  'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n  'NotNestedLessLess': '\\u2AA1\\u0338',\n  'NotPrecedes': '\\u2280',\n  'npr': '\\u2280',\n  'nprec': '\\u2280',\n  'NotPrecedesEqual': '\\u2AAF\\u0338',\n  'npre': '\\u2AAF\\u0338',\n  'npreceq': '\\u2AAF\\u0338',\n  'NotPrecedesSlantEqual': '\\u22E0',\n  'nprcue': '\\u22E0',\n  'NotReverseElement': '\\u220C',\n  'notni': '\\u220C',\n  'notniva': '\\u220C',\n  'NotRightTriangle': '\\u22EB',\n  'nrtri': '\\u22EB',\n  'ntriangleright': '\\u22EB',\n  'NotRightTriangleBar': '\\u29D0\\u0338',\n  'NotRightTriangleEqual': '\\u22ED',\n  'nrtrie': '\\u22ED',\n  'ntrianglerighteq': '\\u22ED',\n  'NotSquareSubset': '\\u228F\\u0338',\n  'NotSquareSubsetEqual': '\\u22E2',\n  'nsqsube': '\\u22E2',\n  'NotSquareSuperset': '\\u2290\\u0338',\n  'NotSquareSupersetEqual': '\\u22E3',\n  'nsqsupe': '\\u22E3',\n  'NotSubset': '\\u2282\\u20D2',\n  'nsubset': '\\u2282\\u20D2',\n  'vnsub': '\\u2282\\u20D2',\n  'NotSubsetEqual': '\\u2288',\n  'nsube': '\\u2288',\n  'nsubseteq': '\\u2288',\n  'NotSucceeds': '\\u2281',\n  'nsc': '\\u2281',\n  'nsucc': '\\u2281',\n  'NotSucceedsEqual': '\\u2AB0\\u0338',\n  'nsce': '\\u2AB0\\u0338',\n  'nsucceq': '\\u2AB0\\u0338',\n  'NotSucceedsSlantEqual': '\\u22E1',\n  'nsccue': '\\u22E1',\n  'NotSucceedsTilde': '\\u227F\\u0338',\n  'NotSuperset': '\\u2283\\u20D2',\n  'nsupset': '\\u2283\\u20D2',\n  'vnsup': '\\u2283\\u20D2',\n  'NotSupersetEqual': '\\u2289',\n  'nsupe': '\\u2289',\n  'nsupseteq': '\\u2289',\n  'NotTilde': '\\u2241',\n  'nsim': '\\u2241',\n  'NotTildeEqual': '\\u2244',\n  'nsime': '\\u2244',\n  'nsimeq': '\\u2244',\n  'NotTildeFullEqual': '\\u2247',\n  'ncong': '\\u2247',\n  'NotTildeTilde': '\\u2249',\n  'nap': '\\u2249',\n  'napprox': '\\u2249',\n  'NotVerticalBar': '\\u2224',\n  'nmid': '\\u2224',\n  'nshortmid': '\\u2224',\n  'nsmid': '\\u2224',\n  'Nscr': '\\uD835\\uDCA9',\n  'Ntilde': '\\u00D1',\n  'Nu': '\\u039D',\n  'OElig': '\\u0152',\n  'Oacute': '\\u00D3',\n  'Ocirc': '\\u00D4',\n  'Ocy': '\\u041E',\n  'Odblac': '\\u0150',\n  'Ofr': '\\uD835\\uDD12',\n  'Ograve': '\\u00D2',\n  'Omacr': '\\u014C',\n  'Omega': '\\u03A9',\n  'ohm': '\\u03A9',\n  'Omicron': '\\u039F',\n  'Oopf': '\\uD835\\uDD46',\n  'OpenCurlyDoubleQuote': '\\u201C',\n  'ldquo': '\\u201C',\n  'OpenCurlyQuote': '\\u2018',\n  'lsquo': '\\u2018',\n  'Or': '\\u2A54',\n  'Oscr': '\\uD835\\uDCAA',\n  'Oslash': '\\u00D8',\n  'Otilde': '\\u00D5',\n  'Otimes': '\\u2A37',\n  'Ouml': '\\u00D6',\n  'OverBar': '\\u203E',\n  'oline': '\\u203E',\n  'OverBrace': '\\u23DE',\n  'OverBracket': '\\u23B4',\n  'tbrk': '\\u23B4',\n  'OverParenthesis': '\\u23DC',\n  'PartialD': '\\u2202',\n  'part': '\\u2202',\n  'Pcy': '\\u041F',\n  'Pfr': '\\uD835\\uDD13',\n  'Phi': '\\u03A6',\n  'Pi': '\\u03A0',\n  'PlusMinus': '\\u00B1',\n  'plusmn': '\\u00B1',\n  'pm': '\\u00B1',\n  'Popf': '\\u2119',\n  'primes': '\\u2119',\n  'Pr': '\\u2ABB',\n  'Precedes': '\\u227A',\n  'pr': '\\u227A',\n  'prec': '\\u227A',\n  'PrecedesEqual': '\\u2AAF',\n  'pre': '\\u2AAF',\n  'preceq': '\\u2AAF',\n  'PrecedesSlantEqual': '\\u227C',\n  'prcue': '\\u227C',\n  'preccurlyeq': '\\u227C',\n  'PrecedesTilde': '\\u227E',\n  'precsim': '\\u227E',\n  'prsim': '\\u227E',\n  'Prime': '\\u2033',\n  'Product': '\\u220F',\n  'prod': '\\u220F',\n  'Proportional': '\\u221D',\n  'prop': '\\u221D',\n  'propto': '\\u221D',\n  'varpropto': '\\u221D',\n  'vprop': '\\u221D',\n  'Pscr': '\\uD835\\uDCAB',\n  'Psi': '\\u03A8',\n  'QUOT': '\\u0022',\n  'quot': '\\u0022',\n  'Qfr': '\\uD835\\uDD14',\n  'Qopf': '\\u211A',\n  'rationals': '\\u211A',\n  'Qscr': '\\uD835\\uDCAC',\n  'RBarr': '\\u2910',\n  'drbkarow': '\\u2910',\n  'REG': '\\u00AE',\n  'circledR': '\\u00AE',\n  'reg': '\\u00AE',\n  'Racute': '\\u0154',\n  'Rang': '\\u27EB',\n  'Rarr': '\\u21A0',\n  'twoheadrightarrow': '\\u21A0',\n  'Rarrtl': '\\u2916',\n  'Rcaron': '\\u0158',\n  'Rcedil': '\\u0156',\n  'Rcy': '\\u0420',\n  'Re': '\\u211C',\n  'Rfr': '\\u211C',\n  'real': '\\u211C',\n  'realpart': '\\u211C',\n  'ReverseElement': '\\u220B',\n  'SuchThat': '\\u220B',\n  'ni': '\\u220B',\n  'niv': '\\u220B',\n  'ReverseEquilibrium': '\\u21CB',\n  'leftrightharpoons': '\\u21CB',\n  'lrhar': '\\u21CB',\n  'ReverseUpEquilibrium': '\\u296F',\n  'duhar': '\\u296F',\n  'Rho': '\\u03A1',\n  'RightAngleBracket': '\\u27E9',\n  'rang': '\\u27E9',\n  'rangle': '\\u27E9',\n  'RightArrow': '\\u2192',\n  'ShortRightArrow': '\\u2192',\n  'rarr': '\\u2192',\n  'rightarrow': '\\u2192',\n  'srarr': '\\u2192',\n  'RightArrowBar': '\\u21E5',\n  'rarrb': '\\u21E5',\n  'RightArrowLeftArrow': '\\u21C4',\n  'rightleftarrows': '\\u21C4',\n  'rlarr': '\\u21C4',\n  'RightCeiling': '\\u2309',\n  'rceil': '\\u2309',\n  'RightDoubleBracket': '\\u27E7',\n  'robrk': '\\u27E7',\n  'RightDownTeeVector': '\\u295D',\n  'RightDownVector': '\\u21C2',\n  'dharr': '\\u21C2',\n  'downharpoonright': '\\u21C2',\n  'RightDownVectorBar': '\\u2955',\n  'RightFloor': '\\u230B',\n  'rfloor': '\\u230B',\n  'RightTee': '\\u22A2',\n  'vdash': '\\u22A2',\n  'RightTeeArrow': '\\u21A6',\n  'map': '\\u21A6',\n  'mapsto': '\\u21A6',\n  'RightTeeVector': '\\u295B',\n  'RightTriangle': '\\u22B3',\n  'vartriangleright': '\\u22B3',\n  'vrtri': '\\u22B3',\n  'RightTriangleBar': '\\u29D0',\n  'RightTriangleEqual': '\\u22B5',\n  'rtrie': '\\u22B5',\n  'trianglerighteq': '\\u22B5',\n  'RightUpDownVector': '\\u294F',\n  'RightUpTeeVector': '\\u295C',\n  'RightUpVector': '\\u21BE',\n  'uharr': '\\u21BE',\n  'upharpoonright': '\\u21BE',\n  'RightUpVectorBar': '\\u2954',\n  'RightVector': '\\u21C0',\n  'rharu': '\\u21C0',\n  'rightharpoonup': '\\u21C0',\n  'RightVectorBar': '\\u2953',\n  'Ropf': '\\u211D',\n  'reals': '\\u211D',\n  'RoundImplies': '\\u2970',\n  'Rrightarrow': '\\u21DB',\n  'rAarr': '\\u21DB',\n  'Rscr': '\\u211B',\n  'realine': '\\u211B',\n  'Rsh': '\\u21B1',\n  'rsh': '\\u21B1',\n  'RuleDelayed': '\\u29F4',\n  'SHCHcy': '\\u0429',\n  'SHcy': '\\u0428',\n  'SOFTcy': '\\u042C',\n  'Sacute': '\\u015A',\n  'Sc': '\\u2ABC',\n  'Scaron': '\\u0160',\n  'Scedil': '\\u015E',\n  'Scirc': '\\u015C',\n  'Scy': '\\u0421',\n  'Sfr': '\\uD835\\uDD16',\n  'ShortUpArrow': '\\u2191',\n  'UpArrow': '\\u2191',\n  'uarr': '\\u2191',\n  'uparrow': '\\u2191',\n  'Sigma': '\\u03A3',\n  'SmallCircle': '\\u2218',\n  'compfn': '\\u2218',\n  'Sopf': '\\uD835\\uDD4A',\n  'Sqrt': '\\u221A',\n  'radic': '\\u221A',\n  'Square': '\\u25A1',\n  'squ': '\\u25A1',\n  'square': '\\u25A1',\n  'SquareIntersection': '\\u2293',\n  'sqcap': '\\u2293',\n  'SquareSubset': '\\u228F',\n  'sqsub': '\\u228F',\n  'sqsubset': '\\u228F',\n  'SquareSubsetEqual': '\\u2291',\n  'sqsube': '\\u2291',\n  'sqsubseteq': '\\u2291',\n  'SquareSuperset': '\\u2290',\n  'sqsup': '\\u2290',\n  'sqsupset': '\\u2290',\n  'SquareSupersetEqual': '\\u2292',\n  'sqsupe': '\\u2292',\n  'sqsupseteq': '\\u2292',\n  'SquareUnion': '\\u2294',\n  'sqcup': '\\u2294',\n  'Sscr': '\\uD835\\uDCAE',\n  'Star': '\\u22C6',\n  'sstarf': '\\u22C6',\n  'Sub': '\\u22D0',\n  'Subset': '\\u22D0',\n  'SubsetEqual': '\\u2286',\n  'sube': '\\u2286',\n  'subseteq': '\\u2286',\n  'Succeeds': '\\u227B',\n  'sc': '\\u227B',\n  'succ': '\\u227B',\n  'SucceedsEqual': '\\u2AB0',\n  'sce': '\\u2AB0',\n  'succeq': '\\u2AB0',\n  'SucceedsSlantEqual': '\\u227D',\n  'sccue': '\\u227D',\n  'succcurlyeq': '\\u227D',\n  'SucceedsTilde': '\\u227F',\n  'scsim': '\\u227F',\n  'succsim': '\\u227F',\n  'Sum': '\\u2211',\n  'sum': '\\u2211',\n  'Sup': '\\u22D1',\n  'Supset': '\\u22D1',\n  'Superset': '\\u2283',\n  'sup': '\\u2283',\n  'supset': '\\u2283',\n  'SupersetEqual': '\\u2287',\n  'supe': '\\u2287',\n  'supseteq': '\\u2287',\n  'THORN': '\\u00DE',\n  'TRADE': '\\u2122',\n  'trade': '\\u2122',\n  'TSHcy': '\\u040B',\n  'TScy': '\\u0426',\n  'Tab': '\\u0009',\n  'Tau': '\\u03A4',\n  'Tcaron': '\\u0164',\n  'Tcedil': '\\u0162',\n  'Tcy': '\\u0422',\n  'Tfr': '\\uD835\\uDD17',\n  'Therefore': '\\u2234',\n  'there4': '\\u2234',\n  'therefore': '\\u2234',\n  'Theta': '\\u0398',\n  'ThickSpace': '\\u205F\\u200A',\n  'ThinSpace': '\\u2009',\n  'thinsp': '\\u2009',\n  'Tilde': '\\u223C',\n  'sim': '\\u223C',\n  'thicksim': '\\u223C',\n  'thksim': '\\u223C',\n  'TildeEqual': '\\u2243',\n  'sime': '\\u2243',\n  'simeq': '\\u2243',\n  'TildeFullEqual': '\\u2245',\n  'cong': '\\u2245',\n  'TildeTilde': '\\u2248',\n  'ap': '\\u2248',\n  'approx': '\\u2248',\n  'asymp': '\\u2248',\n  'thickapprox': '\\u2248',\n  'thkap': '\\u2248',\n  'Topf': '\\uD835\\uDD4B',\n  'TripleDot': '\\u20DB',\n  'tdot': '\\u20DB',\n  'Tscr': '\\uD835\\uDCAF',\n  'Tstrok': '\\u0166',\n  'Uacute': '\\u00DA',\n  'Uarr': '\\u219F',\n  'Uarrocir': '\\u2949',\n  'Ubrcy': '\\u040E',\n  'Ubreve': '\\u016C',\n  'Ucirc': '\\u00DB',\n  'Ucy': '\\u0423',\n  'Udblac': '\\u0170',\n  'Ufr': '\\uD835\\uDD18',\n  'Ugrave': '\\u00D9',\n  'Umacr': '\\u016A',\n  'UnderBar': '\\u005F',\n  'lowbar': '\\u005F',\n  'UnderBrace': '\\u23DF',\n  'UnderBracket': '\\u23B5',\n  'bbrk': '\\u23B5',\n  'UnderParenthesis': '\\u23DD',\n  'Union': '\\u22C3',\n  'bigcup': '\\u22C3',\n  'xcup': '\\u22C3',\n  'UnionPlus': '\\u228E',\n  'uplus': '\\u228E',\n  'Uogon': '\\u0172',\n  'Uopf': '\\uD835\\uDD4C',\n  'UpArrowBar': '\\u2912',\n  'UpArrowDownArrow': '\\u21C5',\n  'udarr': '\\u21C5',\n  'UpDownArrow': '\\u2195',\n  'updownarrow': '\\u2195',\n  'varr': '\\u2195',\n  'UpEquilibrium': '\\u296E',\n  'udhar': '\\u296E',\n  'UpTee': '\\u22A5',\n  'bot': '\\u22A5',\n  'bottom': '\\u22A5',\n  'perp': '\\u22A5',\n  'UpTeeArrow': '\\u21A5',\n  'mapstoup': '\\u21A5',\n  'UpperLeftArrow': '\\u2196',\n  'nwarr': '\\u2196',\n  'nwarrow': '\\u2196',\n  'UpperRightArrow': '\\u2197',\n  'nearr': '\\u2197',\n  'nearrow': '\\u2197',\n  'Upsi': '\\u03D2',\n  'upsih': '\\u03D2',\n  'Upsilon': '\\u03A5',\n  'Uring': '\\u016E',\n  'Uscr': '\\uD835\\uDCB0',\n  'Utilde': '\\u0168',\n  'Uuml': '\\u00DC',\n  'VDash': '\\u22AB',\n  'Vbar': '\\u2AEB',\n  'Vcy': '\\u0412',\n  'Vdash': '\\u22A9',\n  'Vdashl': '\\u2AE6',\n  'Vee': '\\u22C1',\n  'bigvee': '\\u22C1',\n  'xvee': '\\u22C1',\n  'Verbar': '\\u2016',\n  'Vert': '\\u2016',\n  'VerticalBar': '\\u2223',\n  'mid': '\\u2223',\n  'shortmid': '\\u2223',\n  'smid': '\\u2223',\n  'VerticalLine': '\\u007C',\n  'verbar': '\\u007C',\n  'vert': '\\u007C',\n  'VerticalSeparator': '\\u2758',\n  'VerticalTilde': '\\u2240',\n  'wr': '\\u2240',\n  'wreath': '\\u2240',\n  'VeryThinSpace': '\\u200A',\n  'hairsp': '\\u200A',\n  'Vfr': '\\uD835\\uDD19',\n  'Vopf': '\\uD835\\uDD4D',\n  'Vscr': '\\uD835\\uDCB1',\n  'Vvdash': '\\u22AA',\n  'Wcirc': '\\u0174',\n  'Wedge': '\\u22C0',\n  'bigwedge': '\\u22C0',\n  'xwedge': '\\u22C0',\n  'Wfr': '\\uD835\\uDD1A',\n  'Wopf': '\\uD835\\uDD4E',\n  'Wscr': '\\uD835\\uDCB2',\n  'Xfr': '\\uD835\\uDD1B',\n  'Xi': '\\u039E',\n  'Xopf': '\\uD835\\uDD4F',\n  'Xscr': '\\uD835\\uDCB3',\n  'YAcy': '\\u042F',\n  'YIcy': '\\u0407',\n  'YUcy': '\\u042E',\n  'Yacute': '\\u00DD',\n  'Ycirc': '\\u0176',\n  'Ycy': '\\u042B',\n  'Yfr': '\\uD835\\uDD1C',\n  'Yopf': '\\uD835\\uDD50',\n  'Yscr': '\\uD835\\uDCB4',\n  'Yuml': '\\u0178',\n  'ZHcy': '\\u0416',\n  'Zacute': '\\u0179',\n  'Zcaron': '\\u017D',\n  'Zcy': '\\u0417',\n  'Zdot': '\\u017B',\n  'Zeta': '\\u0396',\n  'Zfr': '\\u2128',\n  'zeetrf': '\\u2128',\n  'Zopf': '\\u2124',\n  'integers': '\\u2124',\n  'Zscr': '\\uD835\\uDCB5',\n  'aacute': '\\u00E1',\n  'abreve': '\\u0103',\n  'ac': '\\u223E',\n  'mstpos': '\\u223E',\n  'acE': '\\u223E\\u0333',\n  'acd': '\\u223F',\n  'acirc': '\\u00E2',\n  'acy': '\\u0430',\n  'aelig': '\\u00E6',\n  'afr': '\\uD835\\uDD1E',\n  'agrave': '\\u00E0',\n  'alefsym': '\\u2135',\n  'aleph': '\\u2135',\n  'alpha': '\\u03B1',\n  'amacr': '\\u0101',\n  'amalg': '\\u2A3F',\n  'and': '\\u2227',\n  'wedge': '\\u2227',\n  'andand': '\\u2A55',\n  'andd': '\\u2A5C',\n  'andslope': '\\u2A58',\n  'andv': '\\u2A5A',\n  'ang': '\\u2220',\n  'angle': '\\u2220',\n  'ange': '\\u29A4',\n  'angmsd': '\\u2221',\n  'measuredangle': '\\u2221',\n  'angmsdaa': '\\u29A8',\n  'angmsdab': '\\u29A9',\n  'angmsdac': '\\u29AA',\n  'angmsdad': '\\u29AB',\n  'angmsdae': '\\u29AC',\n  'angmsdaf': '\\u29AD',\n  'angmsdag': '\\u29AE',\n  'angmsdah': '\\u29AF',\n  'angrt': '\\u221F',\n  'angrtvb': '\\u22BE',\n  'angrtvbd': '\\u299D',\n  'angsph': '\\u2222',\n  'angzarr': '\\u237C',\n  'aogon': '\\u0105',\n  'aopf': '\\uD835\\uDD52',\n  'apE': '\\u2A70',\n  'apacir': '\\u2A6F',\n  'ape': '\\u224A',\n  'approxeq': '\\u224A',\n  'apid': '\\u224B',\n  'apos': '\\u0027',\n  'aring': '\\u00E5',\n  'ascr': '\\uD835\\uDCB6',\n  'ast': '\\u002A',\n  'midast': '\\u002A',\n  'atilde': '\\u00E3',\n  'auml': '\\u00E4',\n  'awint': '\\u2A11',\n  'bNot': '\\u2AED',\n  'backcong': '\\u224C',\n  'bcong': '\\u224C',\n  'backepsilon': '\\u03F6',\n  'bepsi': '\\u03F6',\n  'backprime': '\\u2035',\n  'bprime': '\\u2035',\n  'backsim': '\\u223D',\n  'bsim': '\\u223D',\n  'backsimeq': '\\u22CD',\n  'bsime': '\\u22CD',\n  'barvee': '\\u22BD',\n  'barwed': '\\u2305',\n  'barwedge': '\\u2305',\n  'bbrktbrk': '\\u23B6',\n  'bcy': '\\u0431',\n  'bdquo': '\\u201E',\n  'ldquor': '\\u201E',\n  'bemptyv': '\\u29B0',\n  'beta': '\\u03B2',\n  'beth': '\\u2136',\n  'between': '\\u226C',\n  'twixt': '\\u226C',\n  'bfr': '\\uD835\\uDD1F',\n  'bigcirc': '\\u25EF',\n  'xcirc': '\\u25EF',\n  'bigodot': '\\u2A00',\n  'xodot': '\\u2A00',\n  'bigoplus': '\\u2A01',\n  'xoplus': '\\u2A01',\n  'bigotimes': '\\u2A02',\n  'xotime': '\\u2A02',\n  'bigsqcup': '\\u2A06',\n  'xsqcup': '\\u2A06',\n  'bigstar': '\\u2605',\n  'starf': '\\u2605',\n  'bigtriangledown': '\\u25BD',\n  'xdtri': '\\u25BD',\n  'bigtriangleup': '\\u25B3',\n  'xutri': '\\u25B3',\n  'biguplus': '\\u2A04',\n  'xuplus': '\\u2A04',\n  'bkarow': '\\u290D',\n  'rbarr': '\\u290D',\n  'blacklozenge': '\\u29EB',\n  'lozf': '\\u29EB',\n  'blacktriangle': '\\u25B4',\n  'utrif': '\\u25B4',\n  'blacktriangledown': '\\u25BE',\n  'dtrif': '\\u25BE',\n  'blacktriangleleft': '\\u25C2',\n  'ltrif': '\\u25C2',\n  'blacktriangleright': '\\u25B8',\n  'rtrif': '\\u25B8',\n  'blank': '\\u2423',\n  'blk12': '\\u2592',\n  'blk14': '\\u2591',\n  'blk34': '\\u2593',\n  'block': '\\u2588',\n  'bne': '\\u003D\\u20E5',\n  'bnequiv': '\\u2261\\u20E5',\n  'bnot': '\\u2310',\n  'bopf': '\\uD835\\uDD53',\n  'bowtie': '\\u22C8',\n  'boxDL': '\\u2557',\n  'boxDR': '\\u2554',\n  'boxDl': '\\u2556',\n  'boxDr': '\\u2553',\n  'boxH': '\\u2550',\n  'boxHD': '\\u2566',\n  'boxHU': '\\u2569',\n  'boxHd': '\\u2564',\n  'boxHu': '\\u2567',\n  'boxUL': '\\u255D',\n  'boxUR': '\\u255A',\n  'boxUl': '\\u255C',\n  'boxUr': '\\u2559',\n  'boxV': '\\u2551',\n  'boxVH': '\\u256C',\n  'boxVL': '\\u2563',\n  'boxVR': '\\u2560',\n  'boxVh': '\\u256B',\n  'boxVl': '\\u2562',\n  'boxVr': '\\u255F',\n  'boxbox': '\\u29C9',\n  'boxdL': '\\u2555',\n  'boxdR': '\\u2552',\n  'boxdl': '\\u2510',\n  'boxdr': '\\u250C',\n  'boxhD': '\\u2565',\n  'boxhU': '\\u2568',\n  'boxhd': '\\u252C',\n  'boxhu': '\\u2534',\n  'boxminus': '\\u229F',\n  'minusb': '\\u229F',\n  'boxplus': '\\u229E',\n  'plusb': '\\u229E',\n  'boxtimes': '\\u22A0',\n  'timesb': '\\u22A0',\n  'boxuL': '\\u255B',\n  'boxuR': '\\u2558',\n  'boxul': '\\u2518',\n  'boxur': '\\u2514',\n  'boxv': '\\u2502',\n  'boxvH': '\\u256A',\n  'boxvL': '\\u2561',\n  'boxvR': '\\u255E',\n  'boxvh': '\\u253C',\n  'boxvl': '\\u2524',\n  'boxvr': '\\u251C',\n  'brvbar': '\\u00A6',\n  'bscr': '\\uD835\\uDCB7',\n  'bsemi': '\\u204F',\n  'bsol': '\\u005C',\n  'bsolb': '\\u29C5',\n  'bsolhsub': '\\u27C8',\n  'bull': '\\u2022',\n  'bullet': '\\u2022',\n  'bumpE': '\\u2AAE',\n  'cacute': '\\u0107',\n  'cap': '\\u2229',\n  'capand': '\\u2A44',\n  'capbrcup': '\\u2A49',\n  'capcap': '\\u2A4B',\n  'capcup': '\\u2A47',\n  'capdot': '\\u2A40',\n  'caps': '\\u2229\\uFE00',\n  'caret': '\\u2041',\n  'ccaps': '\\u2A4D',\n  'ccaron': '\\u010D',\n  'ccedil': '\\u00E7',\n  'ccirc': '\\u0109',\n  'ccups': '\\u2A4C',\n  'ccupssm': '\\u2A50',\n  'cdot': '\\u010B',\n  'cemptyv': '\\u29B2',\n  'cent': '\\u00A2',\n  'cfr': '\\uD835\\uDD20',\n  'chcy': '\\u0447',\n  'check': '\\u2713',\n  'checkmark': '\\u2713',\n  'chi': '\\u03C7',\n  'cir': '\\u25CB',\n  'cirE': '\\u29C3',\n  'circ': '\\u02C6',\n  'circeq': '\\u2257',\n  'cire': '\\u2257',\n  'circlearrowleft': '\\u21BA',\n  'olarr': '\\u21BA',\n  'circlearrowright': '\\u21BB',\n  'orarr': '\\u21BB',\n  'circledS': '\\u24C8',\n  'oS': '\\u24C8',\n  'circledast': '\\u229B',\n  'oast': '\\u229B',\n  'circledcirc': '\\u229A',\n  'ocir': '\\u229A',\n  'circleddash': '\\u229D',\n  'odash': '\\u229D',\n  'cirfnint': '\\u2A10',\n  'cirmid': '\\u2AEF',\n  'cirscir': '\\u29C2',\n  'clubs': '\\u2663',\n  'clubsuit': '\\u2663',\n  'colon': '\\u003A',\n  'comma': '\\u002C',\n  'commat': '\\u0040',\n  'comp': '\\u2201',\n  'complement': '\\u2201',\n  'congdot': '\\u2A6D',\n  'copf': '\\uD835\\uDD54',\n  'copysr': '\\u2117',\n  'crarr': '\\u21B5',\n  'cross': '\\u2717',\n  'cscr': '\\uD835\\uDCB8',\n  'csub': '\\u2ACF',\n  'csube': '\\u2AD1',\n  'csup': '\\u2AD0',\n  'csupe': '\\u2AD2',\n  'ctdot': '\\u22EF',\n  'cudarrl': '\\u2938',\n  'cudarrr': '\\u2935',\n  'cuepr': '\\u22DE',\n  'curlyeqprec': '\\u22DE',\n  'cuesc': '\\u22DF',\n  'curlyeqsucc': '\\u22DF',\n  'cularr': '\\u21B6',\n  'curvearrowleft': '\\u21B6',\n  'cularrp': '\\u293D',\n  'cup': '\\u222A',\n  'cupbrcap': '\\u2A48',\n  'cupcap': '\\u2A46',\n  'cupcup': '\\u2A4A',\n  'cupdot': '\\u228D',\n  'cupor': '\\u2A45',\n  'cups': '\\u222A\\uFE00',\n  'curarr': '\\u21B7',\n  'curvearrowright': '\\u21B7',\n  'curarrm': '\\u293C',\n  'curlyvee': '\\u22CE',\n  'cuvee': '\\u22CE',\n  'curlywedge': '\\u22CF',\n  'cuwed': '\\u22CF',\n  'curren': '\\u00A4',\n  'cwint': '\\u2231',\n  'cylcty': '\\u232D',\n  'dHar': '\\u2965',\n  'dagger': '\\u2020',\n  'daleth': '\\u2138',\n  'dash': '\\u2010',\n  'hyphen': '\\u2010',\n  'dbkarow': '\\u290F',\n  'rBarr': '\\u290F',\n  'dcaron': '\\u010F',\n  'dcy': '\\u0434',\n  'ddarr': '\\u21CA',\n  'downdownarrows': '\\u21CA',\n  'ddotseq': '\\u2A77',\n  'eDDot': '\\u2A77',\n  'deg': '\\u00B0',\n  'delta': '\\u03B4',\n  'demptyv': '\\u29B1',\n  'dfisht': '\\u297F',\n  'dfr': '\\uD835\\uDD21',\n  'diamondsuit': '\\u2666',\n  'diams': '\\u2666',\n  'digamma': '\\u03DD',\n  'gammad': '\\u03DD',\n  'disin': '\\u22F2',\n  'div': '\\u00F7',\n  'divide': '\\u00F7',\n  'divideontimes': '\\u22C7',\n  'divonx': '\\u22C7',\n  'djcy': '\\u0452',\n  'dlcorn': '\\u231E',\n  'llcorner': '\\u231E',\n  'dlcrop': '\\u230D',\n  'dollar': '\\u0024',\n  'dopf': '\\uD835\\uDD55',\n  'doteqdot': '\\u2251',\n  'eDot': '\\u2251',\n  'dotminus': '\\u2238',\n  'minusd': '\\u2238',\n  'dotplus': '\\u2214',\n  'plusdo': '\\u2214',\n  'dotsquare': '\\u22A1',\n  'sdotb': '\\u22A1',\n  'drcorn': '\\u231F',\n  'lrcorner': '\\u231F',\n  'drcrop': '\\u230C',\n  'dscr': '\\uD835\\uDCB9',\n  'dscy': '\\u0455',\n  'dsol': '\\u29F6',\n  'dstrok': '\\u0111',\n  'dtdot': '\\u22F1',\n  'dtri': '\\u25BF',\n  'triangledown': '\\u25BF',\n  'dwangle': '\\u29A6',\n  'dzcy': '\\u045F',\n  'dzigrarr': '\\u27FF',\n  'eacute': '\\u00E9',\n  'easter': '\\u2A6E',\n  'ecaron': '\\u011B',\n  'ecir': '\\u2256',\n  'eqcirc': '\\u2256',\n  'ecirc': '\\u00EA',\n  'ecolon': '\\u2255',\n  'eqcolon': '\\u2255',\n  'ecy': '\\u044D',\n  'edot': '\\u0117',\n  'efDot': '\\u2252',\n  'fallingdotseq': '\\u2252',\n  'efr': '\\uD835\\uDD22',\n  'eg': '\\u2A9A',\n  'egrave': '\\u00E8',\n  'egs': '\\u2A96',\n  'eqslantgtr': '\\u2A96',\n  'egsdot': '\\u2A98',\n  'el': '\\u2A99',\n  'elinters': '\\u23E7',\n  'ell': '\\u2113',\n  'els': '\\u2A95',\n  'eqslantless': '\\u2A95',\n  'elsdot': '\\u2A97',\n  'emacr': '\\u0113',\n  'empty': '\\u2205',\n  'emptyset': '\\u2205',\n  'emptyv': '\\u2205',\n  'varnothing': '\\u2205',\n  'emsp13': '\\u2004',\n  'emsp14': '\\u2005',\n  'emsp': '\\u2003',\n  'eng': '\\u014B',\n  'ensp': '\\u2002',\n  'eogon': '\\u0119',\n  'eopf': '\\uD835\\uDD56',\n  'epar': '\\u22D5',\n  'eparsl': '\\u29E3',\n  'eplus': '\\u2A71',\n  'epsi': '\\u03B5',\n  'epsilon': '\\u03B5',\n  'epsiv': '\\u03F5',\n  'straightepsilon': '\\u03F5',\n  'varepsilon': '\\u03F5',\n  'equals': '\\u003D',\n  'equest': '\\u225F',\n  'questeq': '\\u225F',\n  'equivDD': '\\u2A78',\n  'eqvparsl': '\\u29E5',\n  'erDot': '\\u2253',\n  'risingdotseq': '\\u2253',\n  'erarr': '\\u2971',\n  'escr': '\\u212F',\n  'eta': '\\u03B7',\n  'eth': '\\u00F0',\n  'euml': '\\u00EB',\n  'euro': '\\u20AC',\n  'excl': '\\u0021',\n  'fcy': '\\u0444',\n  'female': '\\u2640',\n  'ffilig': '\\uFB03',\n  'fflig': '\\uFB00',\n  'ffllig': '\\uFB04',\n  'ffr': '\\uD835\\uDD23',\n  'filig': '\\uFB01',\n  'fjlig': '\\u0066\\u006A',\n  'flat': '\\u266D',\n  'fllig': '\\uFB02',\n  'fltns': '\\u25B1',\n  'fnof': '\\u0192',\n  'fopf': '\\uD835\\uDD57',\n  'fork': '\\u22D4',\n  'pitchfork': '\\u22D4',\n  'forkv': '\\u2AD9',\n  'fpartint': '\\u2A0D',\n  'frac12': '\\u00BD',\n  'half': '\\u00BD',\n  'frac13': '\\u2153',\n  'frac14': '\\u00BC',\n  'frac15': '\\u2155',\n  'frac16': '\\u2159',\n  'frac18': '\\u215B',\n  'frac23': '\\u2154',\n  'frac25': '\\u2156',\n  'frac34': '\\u00BE',\n  'frac35': '\\u2157',\n  'frac38': '\\u215C',\n  'frac45': '\\u2158',\n  'frac56': '\\u215A',\n  'frac58': '\\u215D',\n  'frac78': '\\u215E',\n  'frasl': '\\u2044',\n  'frown': '\\u2322',\n  'sfrown': '\\u2322',\n  'fscr': '\\uD835\\uDCBB',\n  'gEl': '\\u2A8C',\n  'gtreqqless': '\\u2A8C',\n  'gacute': '\\u01F5',\n  'gamma': '\\u03B3',\n  'gap': '\\u2A86',\n  'gtrapprox': '\\u2A86',\n  'gbreve': '\\u011F',\n  'gcirc': '\\u011D',\n  'gcy': '\\u0433',\n  'gdot': '\\u0121',\n  'gescc': '\\u2AA9',\n  'gesdot': '\\u2A80',\n  'gesdoto': '\\u2A82',\n  'gesdotol': '\\u2A84',\n  'gesl': '\\u22DB\\uFE00',\n  'gesles': '\\u2A94',\n  'gfr': '\\uD835\\uDD24',\n  'gimel': '\\u2137',\n  'gjcy': '\\u0453',\n  'glE': '\\u2A92',\n  'gla': '\\u2AA5',\n  'glj': '\\u2AA4',\n  'gnE': '\\u2269',\n  'gneqq': '\\u2269',\n  'gnap': '\\u2A8A',\n  'gnapprox': '\\u2A8A',\n  'gne': '\\u2A88',\n  'gneq': '\\u2A88',\n  'gnsim': '\\u22E7',\n  'gopf': '\\uD835\\uDD58',\n  'gscr': '\\u210A',\n  'gsime': '\\u2A8E',\n  'gsiml': '\\u2A90',\n  'gtcc': '\\u2AA7',\n  'gtcir': '\\u2A7A',\n  'gtdot': '\\u22D7',\n  'gtrdot': '\\u22D7',\n  'gtlPar': '\\u2995',\n  'gtquest': '\\u2A7C',\n  'gtrarr': '\\u2978',\n  'gvertneqq': '\\u2269\\uFE00',\n  'gvnE': '\\u2269\\uFE00',\n  'hardcy': '\\u044A',\n  'harrcir': '\\u2948',\n  'harrw': '\\u21AD',\n  'leftrightsquigarrow': '\\u21AD',\n  'hbar': '\\u210F',\n  'hslash': '\\u210F',\n  'planck': '\\u210F',\n  'plankv': '\\u210F',\n  'hcirc': '\\u0125',\n  'hearts': '\\u2665',\n  'heartsuit': '\\u2665',\n  'hellip': '\\u2026',\n  'mldr': '\\u2026',\n  'hercon': '\\u22B9',\n  'hfr': '\\uD835\\uDD25',\n  'hksearow': '\\u2925',\n  'searhk': '\\u2925',\n  'hkswarow': '\\u2926',\n  'swarhk': '\\u2926',\n  'hoarr': '\\u21FF',\n  'homtht': '\\u223B',\n  'hookleftarrow': '\\u21A9',\n  'larrhk': '\\u21A9',\n  'hookrightarrow': '\\u21AA',\n  'rarrhk': '\\u21AA',\n  'hopf': '\\uD835\\uDD59',\n  'horbar': '\\u2015',\n  'hscr': '\\uD835\\uDCBD',\n  'hstrok': '\\u0127',\n  'hybull': '\\u2043',\n  'iacute': '\\u00ED',\n  'icirc': '\\u00EE',\n  'icy': '\\u0438',\n  'iecy': '\\u0435',\n  'iexcl': '\\u00A1',\n  'ifr': '\\uD835\\uDD26',\n  'igrave': '\\u00EC',\n  'iiiint': '\\u2A0C',\n  'qint': '\\u2A0C',\n  'iiint': '\\u222D',\n  'tint': '\\u222D',\n  'iinfin': '\\u29DC',\n  'iiota': '\\u2129',\n  'ijlig': '\\u0133',\n  'imacr': '\\u012B',\n  'imath': '\\u0131',\n  'inodot': '\\u0131',\n  'imof': '\\u22B7',\n  'imped': '\\u01B5',\n  'incare': '\\u2105',\n  'infin': '\\u221E',\n  'infintie': '\\u29DD',\n  'intcal': '\\u22BA',\n  'intercal': '\\u22BA',\n  'intlarhk': '\\u2A17',\n  'intprod': '\\u2A3C',\n  'iprod': '\\u2A3C',\n  'iocy': '\\u0451',\n  'iogon': '\\u012F',\n  'iopf': '\\uD835\\uDD5A',\n  'iota': '\\u03B9',\n  'iquest': '\\u00BF',\n  'iscr': '\\uD835\\uDCBE',\n  'isinE': '\\u22F9',\n  'isindot': '\\u22F5',\n  'isins': '\\u22F4',\n  'isinsv': '\\u22F3',\n  'itilde': '\\u0129',\n  'iukcy': '\\u0456',\n  'iuml': '\\u00EF',\n  'jcirc': '\\u0135',\n  'jcy': '\\u0439',\n  'jfr': '\\uD835\\uDD27',\n  'jmath': '\\u0237',\n  'jopf': '\\uD835\\uDD5B',\n  'jscr': '\\uD835\\uDCBF',\n  'jsercy': '\\u0458',\n  'jukcy': '\\u0454',\n  'kappa': '\\u03BA',\n  'kappav': '\\u03F0',\n  'varkappa': '\\u03F0',\n  'kcedil': '\\u0137',\n  'kcy': '\\u043A',\n  'kfr': '\\uD835\\uDD28',\n  'kgreen': '\\u0138',\n  'khcy': '\\u0445',\n  'kjcy': '\\u045C',\n  'kopf': '\\uD835\\uDD5C',\n  'kscr': '\\uD835\\uDCC0',\n  'lAtail': '\\u291B',\n  'lBarr': '\\u290E',\n  'lEg': '\\u2A8B',\n  'lesseqqgtr': '\\u2A8B',\n  'lHar': '\\u2962',\n  'lacute': '\\u013A',\n  'laemptyv': '\\u29B4',\n  'lambda': '\\u03BB',\n  'langd': '\\u2991',\n  'lap': '\\u2A85',\n  'lessapprox': '\\u2A85',\n  'laquo': '\\u00AB',\n  'larrbfs': '\\u291F',\n  'larrfs': '\\u291D',\n  'larrlp': '\\u21AB',\n  'looparrowleft': '\\u21AB',\n  'larrpl': '\\u2939',\n  'larrsim': '\\u2973',\n  'larrtl': '\\u21A2',\n  'leftarrowtail': '\\u21A2',\n  'lat': '\\u2AAB',\n  'latail': '\\u2919',\n  'late': '\\u2AAD',\n  'lates': '\\u2AAD\\uFE00',\n  'lbarr': '\\u290C',\n  'lbbrk': '\\u2772',\n  'lbrace': '\\u007B',\n  'lcub': '\\u007B',\n  'lbrack': '\\u005B',\n  'lsqb': '\\u005B',\n  'lbrke': '\\u298B',\n  'lbrksld': '\\u298F',\n  'lbrkslu': '\\u298D',\n  'lcaron': '\\u013E',\n  'lcedil': '\\u013C',\n  'lcy': '\\u043B',\n  'ldca': '\\u2936',\n  'ldrdhar': '\\u2967',\n  'ldrushar': '\\u294B',\n  'ldsh': '\\u21B2',\n  'le': '\\u2264',\n  'leq': '\\u2264',\n  'leftleftarrows': '\\u21C7',\n  'llarr': '\\u21C7',\n  'leftthreetimes': '\\u22CB',\n  'lthree': '\\u22CB',\n  'lescc': '\\u2AA8',\n  'lesdot': '\\u2A7F',\n  'lesdoto': '\\u2A81',\n  'lesdotor': '\\u2A83',\n  'lesg': '\\u22DA\\uFE00',\n  'lesges': '\\u2A93',\n  'lessdot': '\\u22D6',\n  'ltdot': '\\u22D6',\n  'lfisht': '\\u297C',\n  'lfr': '\\uD835\\uDD29',\n  'lgE': '\\u2A91',\n  'lharul': '\\u296A',\n  'lhblk': '\\u2584',\n  'ljcy': '\\u0459',\n  'llhard': '\\u296B',\n  'lltri': '\\u25FA',\n  'lmidot': '\\u0140',\n  'lmoust': '\\u23B0',\n  'lmoustache': '\\u23B0',\n  'lnE': '\\u2268',\n  'lneqq': '\\u2268',\n  'lnap': '\\u2A89',\n  'lnapprox': '\\u2A89',\n  'lne': '\\u2A87',\n  'lneq': '\\u2A87',\n  'lnsim': '\\u22E6',\n  'loang': '\\u27EC',\n  'loarr': '\\u21FD',\n  'longmapsto': '\\u27FC',\n  'xmap': '\\u27FC',\n  'looparrowright': '\\u21AC',\n  'rarrlp': '\\u21AC',\n  'lopar': '\\u2985',\n  'lopf': '\\uD835\\uDD5D',\n  'loplus': '\\u2A2D',\n  'lotimes': '\\u2A34',\n  'lowast': '\\u2217',\n  'loz': '\\u25CA',\n  'lozenge': '\\u25CA',\n  'lpar': '\\u0028',\n  'lparlt': '\\u2993',\n  'lrhard': '\\u296D',\n  'lrm': '\\u200E',\n  'lrtri': '\\u22BF',\n  'lsaquo': '\\u2039',\n  'lscr': '\\uD835\\uDCC1',\n  'lsime': '\\u2A8D',\n  'lsimg': '\\u2A8F',\n  'lsquor': '\\u201A',\n  'sbquo': '\\u201A',\n  'lstrok': '\\u0142',\n  'ltcc': '\\u2AA6',\n  'ltcir': '\\u2A79',\n  'ltimes': '\\u22C9',\n  'ltlarr': '\\u2976',\n  'ltquest': '\\u2A7B',\n  'ltrPar': '\\u2996',\n  'ltri': '\\u25C3',\n  'triangleleft': '\\u25C3',\n  'lurdshar': '\\u294A',\n  'luruhar': '\\u2966',\n  'lvertneqq': '\\u2268\\uFE00',\n  'lvnE': '\\u2268\\uFE00',\n  'mDDot': '\\u223A',\n  'macr': '\\u00AF',\n  'strns': '\\u00AF',\n  'male': '\\u2642',\n  'malt': '\\u2720',\n  'maltese': '\\u2720',\n  'marker': '\\u25AE',\n  'mcomma': '\\u2A29',\n  'mcy': '\\u043C',\n  'mdash': '\\u2014',\n  'mfr': '\\uD835\\uDD2A',\n  'mho': '\\u2127',\n  'micro': '\\u00B5',\n  'midcir': '\\u2AF0',\n  'minus': '\\u2212',\n  'minusdu': '\\u2A2A',\n  'mlcp': '\\u2ADB',\n  'models': '\\u22A7',\n  'mopf': '\\uD835\\uDD5E',\n  'mscr': '\\uD835\\uDCC2',\n  'mu': '\\u03BC',\n  'multimap': '\\u22B8',\n  'mumap': '\\u22B8',\n  'nGg': '\\u22D9\\u0338',\n  'nGt': '\\u226B\\u20D2',\n  'nLeftarrow': '\\u21CD',\n  'nlArr': '\\u21CD',\n  'nLeftrightarrow': '\\u21CE',\n  'nhArr': '\\u21CE',\n  'nLl': '\\u22D8\\u0338',\n  'nLt': '\\u226A\\u20D2',\n  'nRightarrow': '\\u21CF',\n  'nrArr': '\\u21CF',\n  'nVDash': '\\u22AF',\n  'nVdash': '\\u22AE',\n  'nacute': '\\u0144',\n  'nang': '\\u2220\\u20D2',\n  'napE': '\\u2A70\\u0338',\n  'napid': '\\u224B\\u0338',\n  'napos': '\\u0149',\n  'natur': '\\u266E',\n  'natural': '\\u266E',\n  'ncap': '\\u2A43',\n  'ncaron': '\\u0148',\n  'ncedil': '\\u0146',\n  'ncongdot': '\\u2A6D\\u0338',\n  'ncup': '\\u2A42',\n  'ncy': '\\u043D',\n  'ndash': '\\u2013',\n  'neArr': '\\u21D7',\n  'nearhk': '\\u2924',\n  'nedot': '\\u2250\\u0338',\n  'nesear': '\\u2928',\n  'toea': '\\u2928',\n  'nfr': '\\uD835\\uDD2B',\n  'nharr': '\\u21AE',\n  'nleftrightarrow': '\\u21AE',\n  'nhpar': '\\u2AF2',\n  'nis': '\\u22FC',\n  'nisd': '\\u22FA',\n  'njcy': '\\u045A',\n  'nlE': '\\u2266\\u0338',\n  'nleqq': '\\u2266\\u0338',\n  'nlarr': '\\u219A',\n  'nleftarrow': '\\u219A',\n  'nldr': '\\u2025',\n  'nopf': '\\uD835\\uDD5F',\n  'not': '\\u00AC',\n  'notinE': '\\u22F9\\u0338',\n  'notindot': '\\u22F5\\u0338',\n  'notinvb': '\\u22F7',\n  'notinvc': '\\u22F6',\n  'notnivb': '\\u22FE',\n  'notnivc': '\\u22FD',\n  'nparsl': '\\u2AFD\\u20E5',\n  'npart': '\\u2202\\u0338',\n  'npolint': '\\u2A14',\n  'nrarr': '\\u219B',\n  'nrightarrow': '\\u219B',\n  'nrarrc': '\\u2933\\u0338',\n  'nrarrw': '\\u219D\\u0338',\n  'nscr': '\\uD835\\uDCC3',\n  'nsub': '\\u2284',\n  'nsubE': '\\u2AC5\\u0338',\n  'nsubseteqq': '\\u2AC5\\u0338',\n  'nsup': '\\u2285',\n  'nsupE': '\\u2AC6\\u0338',\n  'nsupseteqq': '\\u2AC6\\u0338',\n  'ntilde': '\\u00F1',\n  'nu': '\\u03BD',\n  'num': '\\u0023',\n  'numero': '\\u2116',\n  'numsp': '\\u2007',\n  'nvDash': '\\u22AD',\n  'nvHarr': '\\u2904',\n  'nvap': '\\u224D\\u20D2',\n  'nvdash': '\\u22AC',\n  'nvge': '\\u2265\\u20D2',\n  'nvgt': '\\u003E\\u20D2',\n  'nvinfin': '\\u29DE',\n  'nvlArr': '\\u2902',\n  'nvle': '\\u2264\\u20D2',\n  'nvlt': '\\u003C\\u20D2',\n  'nvltrie': '\\u22B4\\u20D2',\n  'nvrArr': '\\u2903',\n  'nvrtrie': '\\u22B5\\u20D2',\n  'nvsim': '\\u223C\\u20D2',\n  'nwArr': '\\u21D6',\n  'nwarhk': '\\u2923',\n  'nwnear': '\\u2927',\n  'oacute': '\\u00F3',\n  'ocirc': '\\u00F4',\n  'ocy': '\\u043E',\n  'odblac': '\\u0151',\n  'odiv': '\\u2A38',\n  'odsold': '\\u29BC',\n  'oelig': '\\u0153',\n  'ofcir': '\\u29BF',\n  'ofr': '\\uD835\\uDD2C',\n  'ogon': '\\u02DB',\n  'ograve': '\\u00F2',\n  'ogt': '\\u29C1',\n  'ohbar': '\\u29B5',\n  'olcir': '\\u29BE',\n  'olcross': '\\u29BB',\n  'olt': '\\u29C0',\n  'omacr': '\\u014D',\n  'omega': '\\u03C9',\n  'omicron': '\\u03BF',\n  'omid': '\\u29B6',\n  'oopf': '\\uD835\\uDD60',\n  'opar': '\\u29B7',\n  'operp': '\\u29B9',\n  'or': '\\u2228',\n  'vee': '\\u2228',\n  'ord': '\\u2A5D',\n  'order': '\\u2134',\n  'orderof': '\\u2134',\n  'oscr': '\\u2134',\n  'ordf': '\\u00AA',\n  'ordm': '\\u00BA',\n  'origof': '\\u22B6',\n  'oror': '\\u2A56',\n  'orslope': '\\u2A57',\n  'orv': '\\u2A5B',\n  'oslash': '\\u00F8',\n  'osol': '\\u2298',\n  'otilde': '\\u00F5',\n  'otimesas': '\\u2A36',\n  'ouml': '\\u00F6',\n  'ovbar': '\\u233D',\n  'para': '\\u00B6',\n  'parsim': '\\u2AF3',\n  'parsl': '\\u2AFD',\n  'pcy': '\\u043F',\n  'percnt': '\\u0025',\n  'period': '\\u002E',\n  'permil': '\\u2030',\n  'pertenk': '\\u2031',\n  'pfr': '\\uD835\\uDD2D',\n  'phi': '\\u03C6',\n  'phiv': '\\u03D5',\n  'straightphi': '\\u03D5',\n  'varphi': '\\u03D5',\n  'phone': '\\u260E',\n  'pi': '\\u03C0',\n  'piv': '\\u03D6',\n  'varpi': '\\u03D6',\n  'planckh': '\\u210E',\n  'plus': '\\u002B',\n  'plusacir': '\\u2A23',\n  'pluscir': '\\u2A22',\n  'plusdu': '\\u2A25',\n  'pluse': '\\u2A72',\n  'plussim': '\\u2A26',\n  'plustwo': '\\u2A27',\n  'pointint': '\\u2A15',\n  'popf': '\\uD835\\uDD61',\n  'pound': '\\u00A3',\n  'prE': '\\u2AB3',\n  'prap': '\\u2AB7',\n  'precapprox': '\\u2AB7',\n  'precnapprox': '\\u2AB9',\n  'prnap': '\\u2AB9',\n  'precneqq': '\\u2AB5',\n  'prnE': '\\u2AB5',\n  'precnsim': '\\u22E8',\n  'prnsim': '\\u22E8',\n  'prime': '\\u2032',\n  'profalar': '\\u232E',\n  'profline': '\\u2312',\n  'profsurf': '\\u2313',\n  'prurel': '\\u22B0',\n  'pscr': '\\uD835\\uDCC5',\n  'psi': '\\u03C8',\n  'puncsp': '\\u2008',\n  'qfr': '\\uD835\\uDD2E',\n  'qopf': '\\uD835\\uDD62',\n  'qprime': '\\u2057',\n  'qscr': '\\uD835\\uDCC6',\n  'quatint': '\\u2A16',\n  'quest': '\\u003F',\n  'rAtail': '\\u291C',\n  'rHar': '\\u2964',\n  'race': '\\u223D\\u0331',\n  'racute': '\\u0155',\n  'raemptyv': '\\u29B3',\n  'rangd': '\\u2992',\n  'range': '\\u29A5',\n  'raquo': '\\u00BB',\n  'rarrap': '\\u2975',\n  'rarrbfs': '\\u2920',\n  'rarrc': '\\u2933',\n  'rarrfs': '\\u291E',\n  'rarrpl': '\\u2945',\n  'rarrsim': '\\u2974',\n  'rarrtl': '\\u21A3',\n  'rightarrowtail': '\\u21A3',\n  'rarrw': '\\u219D',\n  'rightsquigarrow': '\\u219D',\n  'ratail': '\\u291A',\n  'ratio': '\\u2236',\n  'rbbrk': '\\u2773',\n  'rbrace': '\\u007D',\n  'rcub': '\\u007D',\n  'rbrack': '\\u005D',\n  'rsqb': '\\u005D',\n  'rbrke': '\\u298C',\n  'rbrksld': '\\u298E',\n  'rbrkslu': '\\u2990',\n  'rcaron': '\\u0159',\n  'rcedil': '\\u0157',\n  'rcy': '\\u0440',\n  'rdca': '\\u2937',\n  'rdldhar': '\\u2969',\n  'rdsh': '\\u21B3',\n  'rect': '\\u25AD',\n  'rfisht': '\\u297D',\n  'rfr': '\\uD835\\uDD2F',\n  'rharul': '\\u296C',\n  'rho': '\\u03C1',\n  'rhov': '\\u03F1',\n  'varrho': '\\u03F1',\n  'rightrightarrows': '\\u21C9',\n  'rrarr': '\\u21C9',\n  'rightthreetimes': '\\u22CC',\n  'rthree': '\\u22CC',\n  'ring': '\\u02DA',\n  'rlm': '\\u200F',\n  'rmoust': '\\u23B1',\n  'rmoustache': '\\u23B1',\n  'rnmid': '\\u2AEE',\n  'roang': '\\u27ED',\n  'roarr': '\\u21FE',\n  'ropar': '\\u2986',\n  'ropf': '\\uD835\\uDD63',\n  'roplus': '\\u2A2E',\n  'rotimes': '\\u2A35',\n  'rpar': '\\u0029',\n  'rpargt': '\\u2994',\n  'rppolint': '\\u2A12',\n  'rsaquo': '\\u203A',\n  'rscr': '\\uD835\\uDCC7',\n  'rtimes': '\\u22CA',\n  'rtri': '\\u25B9',\n  'triangleright': '\\u25B9',\n  'rtriltri': '\\u29CE',\n  'ruluhar': '\\u2968',\n  'rx': '\\u211E',\n  'sacute': '\\u015B',\n  'scE': '\\u2AB4',\n  'scap': '\\u2AB8',\n  'succapprox': '\\u2AB8',\n  'scaron': '\\u0161',\n  'scedil': '\\u015F',\n  'scirc': '\\u015D',\n  'scnE': '\\u2AB6',\n  'succneqq': '\\u2AB6',\n  'scnap': '\\u2ABA',\n  'succnapprox': '\\u2ABA',\n  'scnsim': '\\u22E9',\n  'succnsim': '\\u22E9',\n  'scpolint': '\\u2A13',\n  'scy': '\\u0441',\n  'sdot': '\\u22C5',\n  'sdote': '\\u2A66',\n  'seArr': '\\u21D8',\n  'sect': '\\u00A7',\n  'semi': '\\u003B',\n  'seswar': '\\u2929',\n  'tosa': '\\u2929',\n  'sext': '\\u2736',\n  'sfr': '\\uD835\\uDD30',\n  'sharp': '\\u266F',\n  'shchcy': '\\u0449',\n  'shcy': '\\u0448',\n  'shy': '\\u00AD',\n  'sigma': '\\u03C3',\n  'sigmaf': '\\u03C2',\n  'sigmav': '\\u03C2',\n  'varsigma': '\\u03C2',\n  'simdot': '\\u2A6A',\n  'simg': '\\u2A9E',\n  'simgE': '\\u2AA0',\n  'siml': '\\u2A9D',\n  'simlE': '\\u2A9F',\n  'simne': '\\u2246',\n  'simplus': '\\u2A24',\n  'simrarr': '\\u2972',\n  'smashp': '\\u2A33',\n  'smeparsl': '\\u29E4',\n  'smile': '\\u2323',\n  'ssmile': '\\u2323',\n  'smt': '\\u2AAA',\n  'smte': '\\u2AAC',\n  'smtes': '\\u2AAC\\uFE00',\n  'softcy': '\\u044C',\n  'sol': '\\u002F',\n  'solb': '\\u29C4',\n  'solbar': '\\u233F',\n  'sopf': '\\uD835\\uDD64',\n  'spades': '\\u2660',\n  'spadesuit': '\\u2660',\n  'sqcaps': '\\u2293\\uFE00',\n  'sqcups': '\\u2294\\uFE00',\n  'sscr': '\\uD835\\uDCC8',\n  'star': '\\u2606',\n  'sub': '\\u2282',\n  'subset': '\\u2282',\n  'subE': '\\u2AC5',\n  'subseteqq': '\\u2AC5',\n  'subdot': '\\u2ABD',\n  'subedot': '\\u2AC3',\n  'submult': '\\u2AC1',\n  'subnE': '\\u2ACB',\n  'subsetneqq': '\\u2ACB',\n  'subne': '\\u228A',\n  'subsetneq': '\\u228A',\n  'subplus': '\\u2ABF',\n  'subrarr': '\\u2979',\n  'subsim': '\\u2AC7',\n  'subsub': '\\u2AD5',\n  'subsup': '\\u2AD3',\n  'sung': '\\u266A',\n  'sup1': '\\u00B9',\n  'sup2': '\\u00B2',\n  'sup3': '\\u00B3',\n  'supE': '\\u2AC6',\n  'supseteqq': '\\u2AC6',\n  'supdot': '\\u2ABE',\n  'supdsub': '\\u2AD8',\n  'supedot': '\\u2AC4',\n  'suphsol': '\\u27C9',\n  'suphsub': '\\u2AD7',\n  'suplarr': '\\u297B',\n  'supmult': '\\u2AC2',\n  'supnE': '\\u2ACC',\n  'supsetneqq': '\\u2ACC',\n  'supne': '\\u228B',\n  'supsetneq': '\\u228B',\n  'supplus': '\\u2AC0',\n  'supsim': '\\u2AC8',\n  'supsub': '\\u2AD4',\n  'supsup': '\\u2AD6',\n  'swArr': '\\u21D9',\n  'swnwar': '\\u292A',\n  'szlig': '\\u00DF',\n  'target': '\\u2316',\n  'tau': '\\u03C4',\n  'tcaron': '\\u0165',\n  'tcedil': '\\u0163',\n  'tcy': '\\u0442',\n  'telrec': '\\u2315',\n  'tfr': '\\uD835\\uDD31',\n  'theta': '\\u03B8',\n  'thetasym': '\\u03D1',\n  'thetav': '\\u03D1',\n  'vartheta': '\\u03D1',\n  'thorn': '\\u00FE',\n  'times': '\\u00D7',\n  'timesbar': '\\u2A31',\n  'timesd': '\\u2A30',\n  'topbot': '\\u2336',\n  'topcir': '\\u2AF1',\n  'topf': '\\uD835\\uDD65',\n  'topfork': '\\u2ADA',\n  'tprime': '\\u2034',\n  'triangle': '\\u25B5',\n  'utri': '\\u25B5',\n  'triangleq': '\\u225C',\n  'trie': '\\u225C',\n  'tridot': '\\u25EC',\n  'triminus': '\\u2A3A',\n  'triplus': '\\u2A39',\n  'trisb': '\\u29CD',\n  'tritime': '\\u2A3B',\n  'trpezium': '\\u23E2',\n  'tscr': '\\uD835\\uDCC9',\n  'tscy': '\\u0446',\n  'tshcy': '\\u045B',\n  'tstrok': '\\u0167',\n  'uHar': '\\u2963',\n  'uacute': '\\u00FA',\n  'ubrcy': '\\u045E',\n  'ubreve': '\\u016D',\n  'ucirc': '\\u00FB',\n  'ucy': '\\u0443',\n  'udblac': '\\u0171',\n  'ufisht': '\\u297E',\n  'ufr': '\\uD835\\uDD32',\n  'ugrave': '\\u00F9',\n  'uhblk': '\\u2580',\n  'ulcorn': '\\u231C',\n  'ulcorner': '\\u231C',\n  'ulcrop': '\\u230F',\n  'ultri': '\\u25F8',\n  'umacr': '\\u016B',\n  'uogon': '\\u0173',\n  'uopf': '\\uD835\\uDD66',\n  'upsi': '\\u03C5',\n  'upsilon': '\\u03C5',\n  'upuparrows': '\\u21C8',\n  'uuarr': '\\u21C8',\n  'urcorn': '\\u231D',\n  'urcorner': '\\u231D',\n  'urcrop': '\\u230E',\n  'uring': '\\u016F',\n  'urtri': '\\u25F9',\n  'uscr': '\\uD835\\uDCCA',\n  'utdot': '\\u22F0',\n  'utilde': '\\u0169',\n  'uuml': '\\u00FC',\n  'uwangle': '\\u29A7',\n  'vBar': '\\u2AE8',\n  'vBarv': '\\u2AE9',\n  'vangrt': '\\u299C',\n  'varsubsetneq': '\\u228A\\uFE00',\n  'vsubne': '\\u228A\\uFE00',\n  'varsubsetneqq': '\\u2ACB\\uFE00',\n  'vsubnE': '\\u2ACB\\uFE00',\n  'varsupsetneq': '\\u228B\\uFE00',\n  'vsupne': '\\u228B\\uFE00',\n  'varsupsetneqq': '\\u2ACC\\uFE00',\n  'vsupnE': '\\u2ACC\\uFE00',\n  'vcy': '\\u0432',\n  'veebar': '\\u22BB',\n  'veeeq': '\\u225A',\n  'vellip': '\\u22EE',\n  'vfr': '\\uD835\\uDD33',\n  'vopf': '\\uD835\\uDD67',\n  'vscr': '\\uD835\\uDCCB',\n  'vzigzag': '\\u299A',\n  'wcirc': '\\u0175',\n  'wedbar': '\\u2A5F',\n  'wedgeq': '\\u2259',\n  'weierp': '\\u2118',\n  'wp': '\\u2118',\n  'wfr': '\\uD835\\uDD34',\n  'wopf': '\\uD835\\uDD68',\n  'wscr': '\\uD835\\uDCCC',\n  'xfr': '\\uD835\\uDD35',\n  'xi': '\\u03BE',\n  'xnis': '\\u22FB',\n  'xopf': '\\uD835\\uDD69',\n  'xscr': '\\uD835\\uDCCD',\n  'yacute': '\\u00FD',\n  'yacy': '\\u044F',\n  'ycirc': '\\u0177',\n  'ycy': '\\u044B',\n  'yen': '\\u00A5',\n  'yfr': '\\uD835\\uDD36',\n  'yicy': '\\u0457',\n  'yopf': '\\uD835\\uDD6A',\n  'yscr': '\\uD835\\uDCC